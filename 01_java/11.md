<h1>Collections (Coleções)</h1>



A linguagem Java oferece suporte ao uso de arrays para armazenar múltiplos objetos. No entanto, ao criar um array, seu tamanho precisa ser definido no momento da instanciação, como vimos anteriormente. Essa limitação pode causar dificuldades para nós, pessoas desenvolvedoras, especialmente quando lidamos com grandes volumes de dados, pois nem sempre é possível prever quantos elementos precisaremos armazenar.

Para lidar com essa limitação, o Java disponibiliza o **Collections Framework**, um conjunto de interfaces e classes que permite trabalhar com estruturas de dados mais flexíveis e dinâmicas, como **listas**, **conjuntos**, **filas** e **mapas**. Esse framework facilita o armazenamento, a organização e o acesso a dados de forma eficiente, sem a necessidade de definir previamente o tamanho das estruturas.

Uma **coleção** é uma estrutura de dados que agrupa elementos relacionados e permite manipulá-los por meio de métodos pré-definidos, como adicionar, remover ou buscar elementos. Internamente, muitas coleções utilizam arrays, mas escondem essa complexidade da pessoa desenvolvedora, ajustando automaticamente o tamanho conforme necessário.

As coleções em Java são pensadas para oferecer soluções eficientes com base em diferentes critérios, como:

- Agilidade na inserção, remoção e busca de elementos;
- Organização dos dados (ordenada, única, em pares, etc.);
- Facilidade de acesso e iteração.

Além disso, a classe utilitária `Collections` fornece métodos auxiliares para ordenar, embaralhar ou buscar elementos nas coleções, tornando o trabalho ainda mais prático.

<br />

<h2>1. Collections</h2>



O **Collections Framework** é uma biblioteca do Java, localizada no pacote **`java.util`**, composta por interfaces e classes que implementam as principais estruturas de dados de forma reutilizável e padronizada. Ele é baseado em duas interfaces principais: **`Collection`** e **`Map`**, a partir das quais diversas estruturas como listas, conjuntos e filas são derivadas.

Esse framework também oferece suporte à **iteração uniforme** sobre os elementos por meio da interface **`Iterator`**, permitindo que diferentes estruturas de dados sejam percorridas de forma consistente, independentemente da implementação utilizada. Além disso, a classe utilitária **`Collections`** fornece diversos métodos estáticos para operações comuns como ordenação, busca, reversão e embaralhamento de elementos, facilitando o trabalho com coleções.

As **Collections não aceitam tipos primitivos** como `int`, `float` ou `double` de forma direta. Para contornar isso, é necessário utilizar as **classes wrapper** correspondentes, que veremos a seguir.

<br />

<h3>1.1. Classes Wrappers</h3>



No contexto da linguagem Java, as **Classes Wrappers** (ou classes empacotadoras) são versões em forma de **objeto** dos tipos primitivos, como `int`, `float`, `double`, `boolean`, entre outros.

Elas fazem parte do pacote **`java.lang`** e permitem que valores primitivos sejam utilizados onde apenas objetos são aceitos — como em coleções do tipo `ArrayList`, `HashMap`, entre outras, que não suportam tipos primitivos diretamente.

As Classes Wrappers são úteis quando precisamos:

- **Armazenar tipos primitivos em coleções**, como `List`, `Set` e `Map`;
- **Converter valores entre tipos primitivos e objetos**;
- **Utilizar métodos utilitários**, como conversões, comparações e conversões de strings para números.

**✅ - Tabela - Classes Wrappers**

| Tipo Primitivo | Classe Wrapper |
| -------------- | -------------- |
| `byte`         | `Byte`         |
| `short`        | `Short`        |
| `int`          | `Integer`      |
| `long`         | `Long`         |
| `float`        | `Float`        |
| `double`       | `Double`       |
| `char`         | `Character`    |
| `boolean`      | `Boolean`      |

**Wrapper:** Vem do verbo inglês “wrap” que  significa envolver. São Classes que adicionam funcionalidades aos tipos primitivos. A Classe Wrapper transforma um primitivo em Objeto e  adiciona Métodos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01 - Classes Wrappers

```java
package exemplos_collections;

public class Exemplo01 {
	
    public static void main(String[] args) {
    	
        // Criando variáveis com Classes Wrappers
        Integer idade = 30;
        Double altura = 1.80;
        Boolean ativo = true;

        // Armazenando os valores em um array de Object
        Object[] wrappers = { idade, altura, ativo };

        // Exibindo os valores armazenados
        System.out.println("Valores armazenados usando Wrappers:");
        for (Object wrapper : wrappers) {
            System.out.println(wrapper);
        }
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Valores armazenados usando Wrappers:
30
1.8
true
```

No exemplo acima, criamos objetos das Classes Wrappers `Integer`, `Double` e `Boolean`, que encapsulam os tipos primitivos `int`, `double` e `boolean` em objetos. Em seguida, armazenamos essas variáveis em um array comum do tipo `Object[]`, que é uma referência genérica para qualquer objeto em Java, permitindo guardar diferentes tipos de wrappers no mesmo array. 

Por fim, usamos um laço `for-each` para percorrer o array e imprimir os valores. Essa abordagem demonstra como os wrappers funcionam como objetos e como o tipo `Object` serve como uma “caixa genérica” para armazenar qualquer instância de classe.

<br />

<h3>1.2. Collections Framework e suas implementações</h3>



Neste tópico, vamos apresentar um panorama geral das principais interfaces e implementações do pacote **java.util.Collections**, destacando suas características, usos e diferenças. Além disso, serão feitas analogias simples para facilitar a compreensão dos conceitos, tornando o conteúdo acessível mesmo para quem está começando na linguagem.

Nos organogramas abaixo, temos uma visão geral das principais classes e interfaces que compõem o pacote **Collections**:

> Uma **interface** em Java é uma estrutura que representa uma classe abstrata pura. Ela não possui atributos de dados nem métodos construtores, e todos os seus métodos são abstratos. Além disso, é declarada como interface, não como classe. Aprofundaremos esse conceito mais adiante.

<br />

<h4>Collections - Parte 01</h4>



<div align="center"><img src="https://i.imgur.com/PHjCJzj.png" title="source: imgur.com" /></div>

A interface **List** é uma extensão da interface **Collection**. Os elementos em uma lista são organizados em sequência ordenada, permitindo que o usuário acesse qualquer elemento pelo índice, o que garante controle total sobre a posição dos dados. Podemos pensar em uma **List** como um array de tamanho dinâmico.

Fazendo uma analogia com blocos de montar, uma **List** é como uma sequência de blocos de montar numerados, em que cada bloco ocupa uma posição específica (índice), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/0Oq8S5J.png" title="source: imgur.com" /></div>

As implementações **ArrayList** e **Vector** são muito semelhantes, porém a principal diferença está na performance: **ArrayList** é mais eficiente porque não é sincronizado, ou seja, não realiza bloqueios em suas operações, que impedem vários acesso simultâneos. Nos próximos tópicos, abordaremos a estrutura **ArrayList** com mais detalhes.

Já a implementação **LinkedList** é uma estrutura linear em que os elementos não ficam armazenados em posições contíguas na memória. Eles são ligados por ponteiros, que apontam para o próximo elemento (**lista ligada simples**) ou para o próximo e o anterior (**lista duplamente ligada**).

> Ponteiros são variáveis especiais que indicam onde a informação está armazenada na memória. Em Java, o uso de ponteiros é gerenciado internamente pela linguagem, sem exposição direta ao desenvolvedor, ao contrário de linguagens como C.

Fazendo uma analogia com blocos de montar, uma **LinkedList** é uma sequência de blocos conectados entre si, onde cada bloco está ligado ao próximo (no caso da lista ligada simples) e, no caso duplamente ligada, também ao anterior, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yccszbp.png" title="source: imgur.com" /></div>

A implementação **Stack** representa a estrutura de dados chamada pilha, que segue a lógica **LIFO** (*Last In, First Out*): o último elemento inserido é o primeiro a ser removido.

Fazendo uma analogia com Blocos de montar, uma **Stack** seria como uma pilha de blocos, empilhados um sobre o outro, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/WNPT9AV.png" title="source: imgur.com" /></div>

A interface **Queue** (fila) também estende **Collection**. Ela implementa a estrutura de dados fila, onde o primeiro elemento a entrar é o primeiro a sair, seguindo a lógica **FIFO** (*First In, First Out*).

Fazendo uma analogia com Blocos de montar, uma **Fila** seria como uma fila de blocos organizados em sequência, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/R4NFtpj.png" title="source: imgur.com" /></div>

Importante destacar que as implementações **PriorityQueue** e **ArrayDeque** não seguem estritamente o princípio FIFO, pois permitem inserção e remoção tanto no início quanto no fim da fila. Como **Queue** e **Deque** são interfaces, elas apenas definem assinaturas de métodos, cabendo às classes que as implementam definir o comportamento.

No mundo real, podemos comparar uma fila do tipo **PriorityQueue** com pessoas aguardando atendimento: quem chega primeiro é atendido primeiro; entretanto, existem casos em que atendimentos prioritários alteram essa ordem (idosos, gestantes, entre outros.).

A interface **Set** herda de **Collection** e representa uma coleção que não permite elementos duplicados e aceita no máximo um elemento nulo. Seu comportamento segue a definição matemática de conjunto.

Fazendo uma analogia com Blocos de montar, um **Set** seria como uma coleção de blocos, ou seja, um conjunto, sem elementos repetidos, não ordenados, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/ZLO7x3I.png" title="source: imgur.com" /></div>

A implementação **HashSet** é a mais rápida, pois usa internamente uma tabela hash e não mantém os elementos ordenados. É indicada quando a prioridade é a performance, e a ordem dos elementos não importa.

Já a implementação **TreeSet** mantém os elementos ordenados automaticamente, pois implementa a interface **SortedSet**. Essa ordenação, no entanto, traz um custo em performance comparado ao **HashSet**.

Fazendo uma analogia com Blocos de montar, uma **Tree** seria como uma pirâmide de blocos, que inicia com um bloco no topo e vai crescendo para baixo como se fossem as raízes da árvore, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/ejHofrZ.png" title="source: imgur.com" /></div>

A implementação **`LinkedHashSet`** é uma subclasse de **`HashSet`** que **mantém a ordem de inserção dos elementos**, ao contrário de `HashSet`, que não garante ordem. Embora ofereça um desempenho ligeiramente inferior ao `HashSet` em algumas operações, o `LinkedHashSet` é útil quando se deseja preservar a sequência em que os dados foram adicionados. Ele **implementa a interface `Set`**, mas **não ordena os elementos automaticamente**, como faz o `TreeSet`.

<br />

<h4>Collections - Parte 02</h4>



<div align="center"><img src="https://i.imgur.com/zuFuBH4.png" title="source: imgur.com" width="75%"/></div>

A interface **Map** define um array associativo, onde objetos são armazenados em pares **chave-valor**. As chaves são únicas, mas os valores podem se repetir. Não há garantia de ordem ao percorrer os elementos.

Fazendo uma analogia com Blocos de montar, um **Map** seria como uma coleção de blocos, ou seja, um conjunto, não ordenados, onde cada elemento possui uma Chave e um Valor, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/lyMrafp.png" title="source: imgur.com" /></div>

A implementação **HashMap** armazena pares chave-valor sem manter ordem, não permite chaves duplicadas e aceita valores nulos.

**LinkedHashMap** mantém a ordem de inserção dos elementos e também não permite chaves duplicadas.

**TreeMap** armazena os elementos em ordem crescente de chave, não permitindo duplicatas.

Por fim, **Hashtable** é uma implementação que usa o método `hashCode()` para posicionar elementos, não permite chaves duplicadas e é sincronizada, diferente do **HashMap**.

Cada interface possui diversas implementações que representam diferentes estruturas de dados, permitindo escolher a que melhor se adapta às necessidades específicas da aplicação.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html" target="_blank"><b>Artigo: Java Tutorials: Collections</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html" target="_blank"><b>Documentação: Collections</b></a></div>

<br />

<h2>2. Iterator</h2>



A interface **Iterable** é a raiz da hierarquia das coleções em Java, o que significa que todas as classes e interfaces do pacote **Collections** a implementam direta ou indiretamente. A principal função do **Iterator** é permitir que o usuário percorra, de forma sequencial, todos os elementos presentes em qualquer coleção, como se fossem uma lista simples de itens.

O **Iterator** deve ser utilizado sempre que for necessário enumerar elementos nas coleções que implementam interfaces como **Set**, **List**, **Queue**, **Deque**, além das classes que implementam a interface **Map** (através da coleção de chaves, valores ou entradas).

**Sintaxe:**

```java
Iterator<T> nomeDoIterator = nomeDaCollection.iterator();
```

O parâmetro genérico **`<T>`** representa o tipo dos objetos armazenados na coleção. Esse tipo deve obrigatoriamente ser um objeto, podendo ser uma **classe wrapper** para tipos primitivos ou uma classe definida pela pessoa desenvolvedora.

Na tabela abaixo, listamos os principais Métodos para trabalharmos com a Interface Iterator:

<br />

**✅ - Tabela - Métodos - Iterator**

| Método        | Descrição                                                    |
| ------------- | ------------------------------------------------------------ |
| **hasNext()** | Retorna `true` se houver mais elementos na iteração.         |
| **next()**    | Retorna o próximo elemento da iteração. Lança a exceção **NoSuchElementException** se não houver mais elementos. |

<br />

As principais vantagens da Interface Iterator são:

- Funciona com qualquer coleção que implemente a interface **Iterable**;

- É um iterador universal para todas as collections do Java;

- Os nomes dos métodos são simples e intuitivos.


As principais limitações da Interface Iterator são:

- Permite apenas iteração unidirecional, ou seja, do início ao fim da coleção;
- Não suporta iteração paralela ou concorrente, sendo restrito a iteração sequencial.

Nos próximos tópicos, veremos alguns exemplos com a Interface Iterator.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank"><b>Documentação: Java Type Generic</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank"><b>Documentação: Interface Iterator</b></a></div>

<br />

<h2>3. A Interface Collection e a Classe Collections</h2>



A interface `Collection` em Java faz parte do **Collections Framework** e serve como a **superinterface base** para estruturas `List`, `Set` e `Queue`. Ela define o comportamento geral que todas as coleções devem seguir, como métodos para adicionar, remover, verificar se um elemento está presente, esvaziar a coleção, entre outros. No entanto, por ser uma interface, ela **não implementa nenhum comportamento diretamente** — quem faz isso são as classes concretas que a implementam, como `ArrayList`, `HashSet` ou `LinkedList`.

É importante não confundir a **interface `Collection`** com o **framework completo de coleções** ou com a **classe utilitária `Collections`**: 

- A interface `Collection` é apenas **uma parte da hierarquia do framework**, e não representa por si só a biblioteca inteira. 
- O `Collections Framework` é o nome dado ao conjunto completo de interfaces (como `Collection`, `List`, `Set`, `Map`, etc.) e suas implementações. 
- A classe `Collections` (com "s" no final) é uma **classe utilitária** que oferece métodos estáticos auxiliares, como ordenação, busca e inversão de elementos, para manipular as coleções, de acordo com as características de cada uma.

Portanto, `Collection`, `Collections` e `Collections Framework` são conceitos diferentes e complementares. Entender essa diferença ajuda a evitar confusões e a utilizar corretamente os recursos oferecidos pela linguagem.

<br />

<h2>4. A Collection ArrayList</h2>



Neste curso, estudaremos mais a fundo a interface **List** e sua implementação mais utilizada, a classe **ArrayList**. 

**ArrayList** é a escolha natural quando se precisa de um vetor redimensionável que oferece alta eficiência para operações de leitura. Isso porque ela é implementada internamente com arrays, o que torna o acesso aleatório aos elementos rápido e direto.

**Sintaxe:**

```java
ArrayList<T> notas = new ArrayList<T>();
```

O construtor padrão, sem argumentos, cria um objeto novo e vazio da classe **ArrayList**.

O parâmetro genérico **`<T>`** representa o tipo de objeto que será armazenado na coleção. Esse tipo deve obrigatoriamente ser um objeto, que pode ser uma **classe wrapper** (como `Integer`, `Double`, etc.) ou uma classe criada pela pessoa desenvolvedora.

<br />

<h3>4.1. Principais Métodos da Interface List</h3>



A tabela abaixo apresenta os principais métodos para trabalhar com a coleção **List**:

<br />

**✅ - Tabela - Métodos da Classe ArrayList**

| **Método**                          | **Descrição**                                                |
| ----------------------------------- | ------------------------------------------------------------ |
| **add(Objeto)**                     | Adiciona um objeto ao final da lista.                        |
| **add(Índice, Objeto)**             | Adiciona um objeto na posição indicada, deslocando os elementos posteriores para a frente. |
| **get(Índice)**                     | Retorna o objeto armazenado na posição indicada.             |
| **indexOf(Objeto)**                 | Retorna o índice da primeira ocorrência do objeto na lista.  |
| **set(Índice, Objeto)**             | Substitui o objeto na posição indicada pelo objeto fornecido. |
| **remove(Índice)**                  | Remove o objeto na posição indicada pelo índice.             |
| **remove(Objeto)**                  | Remove a primeira ocorrência do objeto informado.            |
| **clear()**                         | Remove todos os elementos da lista, esvaziando-a.            |
| **size()**                          | Retorna o número de elementos atualmente armazenados na lista. |
| **isEmpty()**                       | Retorna `true` se a lista estiver vazia.                     |
| **contains(Objeto)**                | Retorna `true` se a lista contém ao menos uma ocorrência do objeto. |
| **sort(null)**                      | Ordena os elementos da lista em ordem natural crescente.     |
| **sort(Comparator.reverseOrder())** | Ordena os elementos da lista em ordem decrescente.           |

<br />

<h3>4.2. Comparator</h3>



No tópico anterior, na última linha da tabela, aparece como parâmetro do método `sort` um método chamado `reverseOder` , que pertence a Interface `Comparator`. Afinal de contas, O que é essa interface Comparator?

O `Comparator` em Java é uma interface funcional do pacote `java.util` usada para definir **regras de ordenação personalizada** entre objetos. Ao contrário da interface `Comparable`, que impõe uma ordem natural diretamente na classe do objeto, o `Comparator` permite **criar múltiplas formas de comparação** sem modificar a classe original. Isso é útil quando se deseja ordenar os mesmos dados de formas diferentes — por exemplo, uma lista de produtos pode ser ordenada por nome, por preço ou por data de criação, dependendo da necessidade.

> A interface **Comparable** em Java é usada para definir a ordem natural dos objetos de uma classe, permitindo que eles sejam comparados entre si. Para isso, a classe que implementa **Comparable** deve sobrescrever o método `compareTo(T o)`, que compara o objeto atual com outro do mesmo tipo, retornando um valor negativo, zero ou positivo para indicar se o objeto atual é menor, igual ou maior que o outro, respectivamente. Essa funcionalidade é fundamental para ordenar coleções de objetos, como listas ou arrays, de forma consistente e automática.

O método `Comparator.reverseOrder()` em Java retorna um comparador que impõe a **ordem inversa à ordem natural** dos elementos. Ele é útil quando se deseja ordenar uma lista de objetos que implementam a interface `Comparable`, mas em ordem decrescente — sem precisar criar um `Comparator` manualmente. Por exemplo, se uma lista de números ou Strings está ordenada do menor para o maior, o `reverseOrder()` inverte essa lógica, colocando o maior primeiro.

Esse método é geralmente usado com `Collections.sort(lista, Comparator.reverseOrder())` ou diretamente com `lista.sort(Comparator.reverseOrder())`. É importante lembrar que só funciona com elementos que implementam `Comparable`, como `String`, `Integer`, `Double` e outras classes que têm uma ordem natural.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank"><b>Documentação: Comparator</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank"><b>Documentação: Comparable</b></a></div>

<br />

Para exemplificar o uso dos métodos da coleção `List`, construiremos um CRUD simples (Create, Read, Update e Delete) que armazenará números inteiros utilizando a coleção `ArrayList`. Os números serão armazenados como objetos da classe wrapper `Integer`, já que as coleções em Java não aceitam tipos primitivos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 02 - Collection ArrayList

```java
package exemplos_collections;

import java.util.ArrayList;
import java.util.Scanner;

public class Exemplo02 {

	public static void main(String[] args) {

		// Instancia o objeto Scanner para ler os dados do teclado
		Scanner leia = new Scanner(System.in);

		// Criação da Collection ArrayList para armazenar números inteiros
		ArrayList<Integer> lista = new ArrayList<Integer>();

		// Declaração das variáveis auxiliares
		int opcao = -1;
		int numero, posicao, novoNumero;

		// Estrutura de repetição que exibe o menu até o usuário escolher sair (opção 0)
		while (opcao != 0) {
			System.out.println("\n--- CRUD Simples ---");
			System.out.println("1 - Adicionar número");
			System.out.println("2 - Listar números");
			System.out.println("3 - Procurar número específico");
			System.out.println("4 - Alterar número");
			System.out.println("5 - Remover número");
			System.out.println("0 - Sair");
			System.out.print("Escolha uma opção: ");

            // Lê a opção escolhida pelo usuário
			opcao = leia.nextInt(); 

			// Estrutura de decisão com base na opção escolhida
			switch (opcao) {
			case 1:
				// Adiciona um novo número à lista
				System.out.print("Digite o número: ");
				numero = leia.nextInt();
				
                  // Adiciona o número à ArrayList
				lista.add(numero);
				
				System.out.printf("Número %d adicionado!%n", numero);
				break;

			case 2:
				// Lista todos os números cadastrados
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
				} else {
					System.out.println("Lista de números\n");
					for (int indice = 0; indice < lista.size(); indice++) {
						System.out.printf("Lista[%d]: %d%n", indice, lista.get(indice));
					}
				}
				break;

			case 3:
				// Procura por um número específico na lista
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o número: ");
				numero = leia.nextInt();

                 // Retorna o índice do número (ou -1 se não existir)
				posicao = lista.indexOf(numero); 
                    
				if (posicao >= 0) {
					System.out.printf("Número %d encontrado no índice %d%n", numero, posicao);
				} else {
					System.out.printf("Número %d não encontrado!%n", numero);
				}
				break;

			case 4:
				// Altera o número em uma posição específica
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o índice do número: ");
				posicao = leia.nextInt();

				if (posicao < 0 || posicao >= lista.size()) {
					System.out.println("Índice inválido!");
					break;
				}

				System.out.print("Digite o novo valor: ");
				novoNumero = leia.nextInt();

				// Recupera o valor antigo, atualiza e exibe confirmação
				numero = lista.get(posicao);
				lista.set(posicao, novoNumero);
				System.out.printf("Valor no índice %d alterado de %d para %d.%n", posicao, numero, novoNumero);
				break;

			case 5:
				// Remove o número de uma posição específica
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o índice do número: ");
				posicao = leia.nextInt();

				if (posicao < 0 || posicao >= lista.size()) {
					System.out.println("Índice inválido!");
					break;
				}

                  // Remove o número e retorna o valor removido
				numero = lista.remove(posicao); 
				System.out.printf("O número %d armazenado no índice %d foi removido.%n", numero, posicao);
				break;

			case 0:
				// Encerra o programa
				System.out.println("Encerrando...");
				break;

			default:
				// Caso a opção não seja reconhecida
				System.out.println("Opção inválida.");
			}
		}

		// Fecha o Scanner ao final do programa
		leia.close();
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 1
Digite o número: 1
Número 1 adicionado!

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 1
Digite o número: 2
Número 2 adicionado!

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 1
Digite o número: 3
Número 3 adicionado!

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 1
Digite o número: 4
Número 4 adicionado!

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 1
Digite o número: 5
Número 5 adicionado!

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 2
Lista de números

Lista[0]: 1
Lista[1]: 2
Lista[2]: 3
Lista[3]: 4
Lista[4]: 5

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 3
Digite o número: 3
Número 3 encontrado no índice 2

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 4
Digite o índice do número: 2
Digite o novo valor: 10
Valor no índice 2 alterado de 3 para 10.

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 2
Lista de números

Lista[0]: 1
Lista[1]: 2
Lista[2]: 10
Lista[3]: 4
Lista[4]: 5

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 5
Digite o índice do número: 2
O número 10 armazenado no índice 2 foi removido.

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 2
Lista de números

Lista[0]: 1
Lista[1]: 2
Lista[2]: 4
Lista[3]: 5

--- CRUD Simples ---
1 - Adicionar número
2 - Listar números
3 - Procurar número específico
4 - Alterar número
5 - Remover número
0 - Sair
Escolha uma opção: 0
Encerrando...
```

Confira os comentários inseridos no código para compreender o funcionamento do programa. Eles explicam passo a passo a lógica aplicada na criação do CRUD, desde a inclusão de números inteiros na `ArrayList` até a listagem, remoção e atualização dos dados. O exemplo utiliza a classe Wrapper `Integer` para armazenar os dados, garantindo compatibilidade com a Collection, que não aceita tipos primitivos.

<br />

<h3>4.3. Como a Collection ArrayList irá armazenar os dados?</h3>



Na imagem abaixo, temos uma representação gráfica da Collection ArrayList chamada **numeros**:

 <div align="left"><img src="https://i.imgur.com/8l8bjEv.png" /></div>

Observe que a Collection **numeros** será do tipo **Integer** (classe wrapper para o tipo primitivo `int`). Cada novo valor inteiro será armazenado como um objeto da classe `Integer` e adicionado em uma linha da coleção `ArrayList`. Assim como nos vetores, cada linha (ou posição) é identificada por um índice numérico inteiro.

A `ArrayList` mantém a ordem de inserção dos elementos, ou seja, cada novo número adicionado será posicionado após o último elemento inserido, respeitando a sequência de entrada.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html" target="_blank"><b>Artigo: Java Tutorials: Collection List</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank"><b>Documentação: Collection List</b></a></div>

<br />

<h2>5. A Collection Set </h2>



A interface **Set** representa uma coleção que **não permite elementos duplicados**. Ou seja, ela garante que cada elemento inserido seja único. Essa interface faz parte do pacote `java.util` e estende a interface `Collection`, herdando seus principais métodos. No entanto, ao contrário de uma `List`, um `Set` **não mantém a ordem dos elementos**, e essa ordem **pode variar com o tempo**, especialmente após inserções e remoções.

Embora seja possível inserir um único valor `null`, essa prática **não é recomendada**, pois pode causar comportamentos inesperados em algumas implementações.

Diferente das listas, a interface `Set` **não permite acessar elementos por índice**, ou seja, não é possível usar métodos como `get(int index)` para recuperar um item. Os elementos são organizados internamente com base em seu **hash code**, calculado pelo método `hashCode()` de cada objeto. Esse hash code é um valor inteiro que determina a posição do objeto na estrutura subjacente — por exemplo, em um `HashSet`, os elementos são armazenados com base na estrutura de um `HashMap`.

Quando criamos um `HashSet`, ele internamente utiliza um objeto `HashMap` para armazenar os elementos. Cada elemento inserido no `HashSet` é armazenado como uma **chave** no `HashMap`, enquanto o **valor associado** é uma constante interna chamada `PRESENT`. Isso garante a unicidade dos elementos, já que as chaves de um `Map` também não podem se repetir.

Veja a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/xSBwPjD.png" title="source: imgur.com" /></div>

Observe na imagem acima que, para cada objeto inserido na coleção do tipo **Set**, a função de **hash** é executada, ou seja, o método `hashCode()` do objeto é calculado. A partir desse valor, é determinada a posição do objeto na estrutura interna do **HashMap**, sem considerar a ordem de inserção dos elementos.

No **HashSet**, os elementos adicionados são armazenados como chaves (**keys**) no `HashMap` interno, enquanto o valor (**value**) associado a cada chave é uma constante fixa, geralmente chamada de `PRESENT`. Essa implementação garante a unicidade dos elementos no conjunto.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Orientação aos Detalhes*
>
> O principal objetivo da coleção **Set** não é preservar a ordem ou a posição de inserção dos elementos, mas sim garantir a exclusividade dos seus valores, assegurando que não haja repetições.

<br />

**Sintaxe:**

```java
Set<T> setNumeros = new HashSet<T>();
```

No nosso curso, vamos estudar a **Collection Set**, focando na subclasse **HashSet**. O construtor padrão, sem argumentos, cria um novo objeto da classe **HashSet** vazio.

O parâmetro genérico **`<T>`** em Java representa um **Tipo Genérico**. Ele é usado para definir o tipo de objeto que será armazenado na coleção. Esse tipo precisa ser obrigatoriamente um objeto, podendo ser uma **classe wrapper** (como `Integer`, `Double`, entre outros.) ou uma **classe personalizada criada pelo desenvolvedor**.

<br />

<h3>5.1. Métodos da Collection Set</h3>



Na tabela abaixo, listamos os principais métodos para trabalhar com a **Collection Set**:

<br />

**✅ - Tabela - Métodos da Classe Set**

| **Método**           | **Descrição**                                                |
| -------------------- | ------------------------------------------------------------ |
| **add(Objeto)**      | Adiciona um objeto à coleção Set.                            |
| **remove(Objeto)**   | Remove o objeto armazenado na coleção Set.                   |
| **clear()**          | Limpa todos os elementos da coleção Set.                     |
| **size()**           | Retorna o tamanho da coleção Set (número de elementos armazenados). |
| **isEmpty()**        | Retorna `true` se a coleção Set estiver vazia.               |
| **contains(Objeto)** | Retorna `true` se o objeto existe na coleção Set.            |
| **hashCode()**       | Retorna o **hash code** do elemento.                         |

<br />

Para exemplificar o uso dos métodos da coleção `Set`, construiremos um CRUD simples (Create, Read, Update e Delete) que armazenará nomes de frutas utilizando a coleção `HashSet`. Os nomes serão armazenados como objetos da classe  `String`, lembrando que as coleções em Java não aceitam tipos primitivos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 03 - Collection Set:

```java
package exemplos_collections;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Set;

public class Exemplo03 {

	public static void main(String[] args) {

		// Cria um objeto Scanner para capturar entrada do teclado
		Scanner scanner = new Scanner(System.in);
		
		// Cria uma coleção do tipo Set (HashSet) para armazenar frutas
		Set<String> frutas = new HashSet<>();
		
		// Variável de controle para manter o loop do menu ativo
		boolean executar = true;

		// Loop principal do menu
		while (executar) {

			// Exibe o menu de opções
			System.out.println("\n--- CRUD de Frutas ---");
			System.out.println("1. Adicionar fruta");
			System.out.println("2. Listar frutas");
			System.out.println("3. Atualizar fruta");
			System.out.println("4. Remover fruta");
			System.out.println("5. Sair");
			System.out.print("Escolha uma opção: ");

			// Lê a opção escolhida pelo usuário
			int opcao = scanner.nextInt();
			
			// Consome a quebra de linha pendente após o nextInt
			scanner.nextLine();

			// Estrutura de decisão com base na opção escolhida
			switch (opcao) {

				case 1:
					// Solicita o nome da fruta a ser adicionada
					System.out.print("Digite o nome da fruta para adicionar: ");
					
					// Lê o nome e converte para minúsculas para evitar duplicatas
					String frutaAdd = scanner.nextLine().toLowerCase();

					// Tenta adicionar a fruta ao Set
					boolean adicionou = frutas.add(frutaAdd);

					// Verifica se a fruta foi realmente adicionada
					if (adicionou) {
						System.out.printf("Fruta '%s' adicionada com sucesso!%n", frutaAdd);
					} else {
						System.out.printf("Fruta '%s' já existe na lista.%n", frutaAdd);
					}
					break;

				case 2:
					// Verifica se o Set está vazio antes de listar
					if (frutas.isEmpty()) {
						System.out.println("Nenhuma fruta cadastrada.");
					} else {
						System.out.println("Frutas cadastradas:");

						// Cria um novo Iterator para percorrer a coleção
						Iterator<String> iteratorFrutas = frutas.iterator();

						// Percorre os elementos enquanto houver próximos
						while (iteratorFrutas.hasNext()) {
							String fruta = iteratorFrutas.next();
							System.out.printf("- %s%n", fruta);
						}
					}
					break;

				case 3:
					// Solicita o nome da fruta que será atualizada
					System.out.print("Digite o nome da fruta que deseja atualizar: ");
					String frutaAntiga = scanner.nextLine();

					// Verifica se a fruta antiga existe no Set
					if (frutas.contains(frutaAntiga)) {

						// Solicita o novo nome da fruta
						System.out.print("Digite o novo nome da fruta: ");
						String frutaNova = scanner.nextLine();

						// Remove a fruta antiga e adiciona a nova
						frutas.remove(frutaAntiga);
						frutas.add(frutaNova);

						System.out.printf("Fruta '%s' atualizada para '%s' com sucesso!%n", frutaAntiga, frutaNova);
					} else {
						System.out.printf("Fruta '%s' não encontrada.%n", frutaAntiga);
					}
					break;

				case 4:
					// Solicita o nome da fruta que será removida
					System.out.print("Digite o nome da fruta para remover: ");
					String frutaRemover = scanner.nextLine();

					// Tenta remover a fruta
					boolean removeu = frutas.remove(frutaRemover);

					// Informa se a fruta foi removida ou não encontrada
					if (removeu) {
						System.out.printf("Fruta '%s' removida com sucesso!%n", frutaRemover);
					} else {
						System.out.printf("Fruta '%s' não encontrada.%n", frutaRemover);
					}
					break;

				case 5:
					// Encerra o loop e finaliza o programa
					executar = false;
					System.out.println("Encerrando o programa...");
					break;

				default:
					// Mensagem para opção inválida
					System.out.println("Opção inválida. Tente novamente.");
			}
		}

		// Fecha o Scanner ao final da execução
		scanner.close();
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 1
Digite o nome da fruta para adicionar: abacate
Fruta 'abacate' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 1
Digite o nome da fruta para adicionar: amora
Fruta 'amora' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 1
Digite o nome da fruta para adicionar: morango
Fruta 'morango' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 2
Frutas cadastradas:
- morango
- abacate
- amora

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 3
Digite o nome da fruta que deseja atualizar: amora
Digite o novo nome da fruta: manga
Fruta 'amora' atualizada para 'manga' com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 4
Digite o nome da fruta para remover: morango
Fruta 'morango' removida com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 2
Frutas cadastradas:
- abacate
- manga

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma opção: 5
Encerrando o programa...

```

Confira os comentários inseridos no código para compreender o funcionamento do programa. Eles explicam, passo a passo, a lógica aplicada na criação do CRUD, desde a inclusão dos nomes na coleção `HashSet` até a listagem, remoção e atualização dos dados.

Note que neste exemplo utilizamos o **Iterator** para percorrer a coleção `HashSet` durante a listagem das frutas cadastradas. Como o `HashSet` não mantém uma ordem fixa e não possui índices, o Iterator fornece uma forma eficiente e segura para acessar cada elemento da coleção, um por vez.

A implementação no código segue estes passos:

1. **Obtenção do Iterator:** Usamos o método `iterator()` da coleção `HashSet` para criar um objeto do tipo `Iterator<String>`.

   ```java
   Iterator<String> iteratorFrutas = frutas.iterator();
   ```

2. **Iteração pelos elementos:** Utilizamos um laço `while` para percorrer os elementos enquanto o Iterator indicar que ainda há elementos disponíveis com o método `hasNext()`.

   ```java
   while (iteratorFrutas.hasNext()) {
       String fruta = iteratorFrutas.next();
       System.out.printf("- %s%n", fruta);
   }
   ```

3. **Acesso aos elementos:** A cada iteração, o método `next()` retorna o próximo elemento da coleção, que pode ser usado dentro do corpo do laço para exibição ou processamento.

Dessa forma, o Iterator abstrai a complexidade da estrutura interna do `HashSet`, permitindo navegar pelos seus elementos sem precisar conhecer detalhes de implementação, além de evitar problemas como erros de concorrência em coleções modificadas durante a iteração.

Observe que a cada chamada para listar as frutas no menu, é necessário criar um novo **Iterator**, pois ele mantém um estado interno que indica a posição atual na coleção e, após percorrer todos os elementos, não pode ser reutilizado para iniciar uma nova iteração. Por isso, para percorrer a coleção do início a cada listagem, é preciso obter um novo Iterator chamando `frutas.iterator()`.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html" target="_blank"><b>Artigo: Java Tutorials: Collection Set</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank"><b>Documentação: Collection List</b></a></div>

<br />

------

## 🔑**Pontos chave:**

1. **Collections (Coleções)** em Java são estruturas que permitem armazenar, organizar e manipular conjuntos de dados de forma flexível e dinâmica, sem precisar definir um tamanho fixo como nos arrays tradicionais.
2. O **Collections Framework** é um conjunto de interfaces e classes localizadas no pacote `java.util`, que oferecem suporte a estruturas como **List**, **Set**, **Queue**, **Deque** e **Map**.
3. A **classe utilitária `Collections`** fornece métodos auxiliares para ordenar, embaralhar, inverter e buscar elementos dentro de coleções.
4. A **interface `List`** representa listas ordenadas que aceitam elementos duplicados e permitem acesso por índice. As principais implementações são `ArrayList`, `LinkedList` e `Vector`.
5. A **interface `Set`** representa conjuntos que **não permitem elementos duplicados** e **não garantem ordem**. Suas principais implementações são `HashSet`, `LinkedHashSet` e `TreeSet`.
6. A **interface `Map`** armazena pares **chave-valor**, onde as chaves são únicas e os valores podem se repetir. Suas implementações mais comuns são `HashMap`, `LinkedHashMap`, `TreeMap` e `Hashtable`.
7. A **interface `Queue`** define estruturas do tipo fila (FIFO), e `Deque` permite inserção e remoção em ambas as extremidades. `ArrayDeque` e `PriorityQueue` são implementações frequentes.
8. A **interface `Iterator`** permite percorrer elementos de uma coleção de forma sequencial e segura, sendo uma alternativa ao laço `for...each`.
9. As **classes wrappers** (como `Integer`, `Double`, `Boolean`) são usadas para encapsular tipos primitivos em objetos, permitindo que sejam armazenados em coleções.
10. O **método `Comparator.reverseOrder()`** fornece uma forma simples e direta de ordenar coleções em **ordem decrescente**, especialmente útil com listas de elementos que implementam `Comparable`.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
