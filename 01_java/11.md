<h1>Collections (Cole√ß√µes)</h1>



A linguagem Java oferece suporte ao uso de arrays para armazenar m√∫ltiplos objetos. No entanto, ao criar um array, seu tamanho precisa ser definido no momento da instancia√ß√£o, como vimos anteriormente. Essa limita√ß√£o pode causar dificuldades para n√≥s, pessoas desenvolvedoras, especialmente quando lidamos com grandes volumes de dados, pois nem sempre √© poss√≠vel prever quantos elementos precisaremos armazenar.

Para lidar com essa limita√ß√£o, o Java disponibiliza o **Collections Framework**, um conjunto de interfaces e classes que permite trabalhar com estruturas de dados mais flex√≠veis e din√¢micas, como **listas**, **conjuntos**, **filas** e **mapas**. Esse framework facilita o armazenamento, a organiza√ß√£o e o acesso a dados de forma eficiente, sem a necessidade de definir previamente o tamanho das estruturas.

Uma **cole√ß√£o** √© uma estrutura de dados que agrupa elementos relacionados e permite manipul√°-los por meio de m√©todos pr√©-definidos, como adicionar, remover ou buscar elementos. Internamente, muitas cole√ß√µes utilizam arrays, mas escondem essa complexidade da pessoa desenvolvedora, ajustando automaticamente o tamanho conforme necess√°rio.

As cole√ß√µes em Java s√£o pensadas para oferecer solu√ß√µes eficientes com base em diferentes crit√©rios, como:

- Agilidade na inser√ß√£o, remo√ß√£o e busca de elementos;
- Organiza√ß√£o dos dados (ordenada, √∫nica, em pares, etc.);
- Facilidade de acesso e itera√ß√£o.

Al√©m disso, a classe utilit√°ria `Collections` fornece m√©todos auxiliares para ordenar, embaralhar ou buscar elementos nas cole√ß√µes, tornando o trabalho ainda mais pr√°tico.

<br />

<h2>1. Collections</h2>



O **Collections Framework** √© uma biblioteca do Java, localizada no pacote **`java.util`**, composta por interfaces e classes que implementam as principais estruturas de dados de forma reutiliz√°vel e padronizada. Ele √© baseado em duas interfaces principais: **`Collection`** e **`Map`**, a partir das quais diversas estruturas como listas, conjuntos e filas s√£o derivadas.

Esse framework tamb√©m oferece suporte √† **itera√ß√£o uniforme** sobre os elementos por meio da interface **`Iterator`**, permitindo que diferentes estruturas de dados sejam percorridas de forma consistente, independentemente da implementa√ß√£o utilizada. Al√©m disso, a classe utilit√°ria **`Collections`** fornece diversos m√©todos est√°ticos para opera√ß√µes comuns como ordena√ß√£o, busca, revers√£o e embaralhamento de elementos, facilitando o trabalho com cole√ß√µes.

As **Collections n√£o aceitam tipos primitivos** como `int`, `float` ou `double` de forma direta. Para contornar isso, √© necess√°rio utilizar as **classes wrapper** correspondentes, que veremos a seguir.

<br />

<h3>1.1. Classes Wrappers</h3>



No contexto da linguagem Java, as **Classes Wrappers** (ou classes empacotadoras) s√£o vers√µes em forma de **objeto** dos tipos primitivos, como `int`, `float`, `double`, `boolean`, entre outros.

Elas fazem parte do pacote **`java.lang`** e permitem que valores primitivos sejam utilizados onde apenas objetos s√£o aceitos ‚Äî como em cole√ß√µes do tipo `ArrayList`, `HashMap`, entre outras, que n√£o suportam tipos primitivos diretamente.

As Classes Wrappers s√£o √∫teis quando precisamos:

- **Armazenar tipos primitivos em cole√ß√µes**, como `List`, `Set` e `Map`;
- **Converter valores entre tipos primitivos e objetos**;
- **Utilizar m√©todos utilit√°rios**, como convers√µes, compara√ß√µes e convers√µes de strings para n√∫meros.

**‚úÖ - Tabela - Classes Wrappers**

| Tipo Primitivo | Classe Wrapper |
| -------------- | -------------- |
| `byte`         | `Byte`         |
| `short`        | `Short`        |
| `int`          | `Integer`      |
| `long`         | `Long`         |
| `float`        | `Float`        |
| `double`       | `Double`       |
| `char`         | `Character`    |
| `boolean`      | `Boolean`      |

**Wrapper:** Vem do verbo ingl√™s ‚Äúwrap‚Äù que  significa envolver. S√£o Classes que adicionam funcionalidades aos tipos primitivos. A Classe Wrapper transforma um primitivo em Objeto e  adiciona M√©todos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01 - Classes Wrappers

```java
package exemplos_collections;

public class Exemplo01 {
	
    public static void main(String[] args) {
    	
        // Criando vari√°veis com Classes Wrappers
        Integer idade = 30;
        Double altura = 1.80;
        Boolean ativo = true;

        // Armazenando os valores em um array de Object
        Object[] wrappers = { idade, altura, ativo };

        // Exibindo os valores armazenados
        System.out.println("Valores armazenados usando Wrappers:");
        for (Object wrapper : wrappers) {
            System.out.println(wrapper);
        }
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Valores armazenados usando Wrappers:
30
1.8
true
```

No exemplo acima, criamos objetos das Classes Wrappers `Integer`, `Double` e `Boolean`, que encapsulam os tipos primitivos `int`, `double` e `boolean` em objetos. Em seguida, armazenamos essas vari√°veis em um array comum do tipo `Object[]`, que √© uma refer√™ncia gen√©rica para qualquer objeto em Java, permitindo guardar diferentes tipos de wrappers no mesmo array. 

Por fim, usamos um la√ßo `for-each` para percorrer o array e imprimir os valores. Essa abordagem demonstra como os wrappers funcionam como objetos e como o tipo `Object` serve como uma ‚Äúcaixa gen√©rica‚Äù para armazenar qualquer inst√¢ncia de classe.

<br />

<h3>1.2. Collections Framework e suas implementa√ß√µes</h3>



Neste t√≥pico, vamos apresentar um panorama geral das principais interfaces e implementa√ß√µes do pacote **java.util.Collections**, destacando suas caracter√≠sticas, usos e diferen√ßas. Al√©m disso, ser√£o feitas analogias simples para facilitar a compreens√£o dos conceitos, tornando o conte√∫do acess√≠vel mesmo para quem est√° come√ßando na linguagem.

Nos organogramas abaixo, temos uma vis√£o geral das principais classes e interfaces que comp√µem o pacote **Collections**:

> Uma **interface** em Java √© uma estrutura que representa uma classe abstrata pura. Ela n√£o possui atributos de dados nem m√©todos construtores, e todos os seus m√©todos s√£o abstratos. Al√©m disso, √© declarada como interface, n√£o como classe. Aprofundaremos esse conceito mais adiante.

<br />

<h4>Collections - Parte 01</h4>



<div align="center"><img src="https://i.imgur.com/PHjCJzj.png" title="source: imgur.com" /></div>

A interface **List** √© uma extens√£o da interface **Collection**. Os elementos em uma lista s√£o organizados em sequ√™ncia ordenada, permitindo que o usu√°rio acesse qualquer elemento pelo √≠ndice, o que garante controle total sobre a posi√ß√£o dos dados. Podemos pensar em uma **List** como um array de tamanho din√¢mico.

Fazendo uma analogia com blocos de montar, uma **List** √© como uma sequ√™ncia de blocos de montar numerados, em que cada bloco ocupa uma posi√ß√£o espec√≠fica (√≠ndice), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/0Oq8S5J.png" title="source: imgur.com" /></div>

As implementa√ß√µes **ArrayList** e **Vector** s√£o muito semelhantes, por√©m a principal diferen√ßa est√° na performance: **ArrayList** √© mais eficiente porque n√£o √© sincronizado, ou seja, n√£o realiza bloqueios em suas opera√ß√µes, que impedem v√°rios acesso simult√¢neos. Nos pr√≥ximos t√≥picos, abordaremos a estrutura **ArrayList** com mais detalhes.

J√° a implementa√ß√£o **LinkedList** √© uma estrutura linear em que os elementos n√£o ficam armazenados em posi√ß√µes cont√≠guas na mem√≥ria. Eles s√£o ligados por ponteiros, que apontam para o pr√≥ximo elemento (**lista ligada simples**) ou para o pr√≥ximo e o anterior (**lista duplamente ligada**).

> Ponteiros s√£o vari√°veis especiais que indicam onde a informa√ß√£o est√° armazenada na mem√≥ria. Em Java, o uso de ponteiros √© gerenciado internamente pela linguagem, sem exposi√ß√£o direta ao desenvolvedor, ao contr√°rio de linguagens como C.

Fazendo uma analogia com blocos de montar, uma **LinkedList** √© uma sequ√™ncia de blocos conectados entre si, onde cada bloco est√° ligado ao pr√≥ximo (no caso da lista ligada simples) e, no caso duplamente ligada, tamb√©m ao anterior, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yccszbp.png" title="source: imgur.com" /></div>

A implementa√ß√£o **Stack** representa a estrutura de dados chamada pilha, que segue a l√≥gica **LIFO** (*Last In, First Out*): o √∫ltimo elemento inserido √© o primeiro a ser removido.

Fazendo uma analogia com Blocos de montar, uma **Stack** seria como uma pilha de blocos, empilhados um sobre o outro, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/WNPT9AV.png" title="source: imgur.com" /></div>

A interface **Queue** (fila) tamb√©m estende **Collection**. Ela implementa a estrutura de dados fila, onde o primeiro elemento a entrar √© o primeiro a sair, seguindo a l√≥gica **FIFO** (*First In, First Out*).

Fazendo uma analogia com Blocos de montar, uma **Fila** seria como uma fila de blocos organizados em sequ√™ncia, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/R4NFtpj.png" title="source: imgur.com" /></div>

Importante destacar que as implementa√ß√µes **PriorityQueue** e **ArrayDeque** n√£o seguem estritamente o princ√≠pio FIFO, pois permitem inser√ß√£o e remo√ß√£o tanto no in√≠cio quanto no fim da fila. Como **Queue** e **Deque** s√£o interfaces, elas apenas definem assinaturas de m√©todos, cabendo √†s classes que as implementam definir o comportamento.

No mundo real, podemos comparar uma fila do tipo **PriorityQueue** com pessoas aguardando atendimento: quem chega primeiro √© atendido primeiro; entretanto, existem casos em que atendimentos priorit√°rios alteram essa ordem (idosos, gestantes, entre outros.).

A interface **Set** herda de **Collection** e representa uma cole√ß√£o que n√£o permite elementos duplicados e aceita no m√°ximo um elemento nulo. Seu comportamento segue a defini√ß√£o matem√°tica de conjunto.

Fazendo uma analogia com Blocos de montar, um **Set** seria como uma cole√ß√£o de blocos, ou seja, um conjunto, sem elementos repetidos, n√£o ordenados, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/ZLO7x3I.png" title="source: imgur.com" /></div>

A implementa√ß√£o **HashSet** √© a mais r√°pida, pois usa internamente uma tabela hash e n√£o mant√©m os elementos ordenados. √â indicada quando a prioridade √© a performance, e a ordem dos elementos n√£o importa.

J√° a implementa√ß√£o **TreeSet** mant√©m os elementos ordenados automaticamente, pois implementa a interface **SortedSet**. Essa ordena√ß√£o, no entanto, traz um custo em performance comparado ao **HashSet**.

Fazendo uma analogia com Blocos de montar, uma **Tree** seria como uma pir√¢mide de blocos, que inicia com um bloco no topo e vai crescendo para baixo como se fossem as ra√≠zes da √°rvore, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/ejHofrZ.png" title="source: imgur.com" /></div>

A implementa√ß√£o **`LinkedHashSet`** √© uma subclasse de **`HashSet`** que **mant√©m a ordem de inser√ß√£o dos elementos**, ao contr√°rio de `HashSet`, que n√£o garante ordem. Embora ofere√ßa um desempenho ligeiramente inferior ao `HashSet` em algumas opera√ß√µes, o `LinkedHashSet` √© √∫til quando se deseja preservar a sequ√™ncia em que os dados foram adicionados. Ele **implementa a interface `Set`**, mas **n√£o ordena os elementos automaticamente**, como faz o `TreeSet`.

<br />

<h4>Collections - Parte 02</h4>



<div align="center"><img src="https://i.imgur.com/zuFuBH4.png" title="source: imgur.com" width="75%"/></div>

A interface **Map** define um array associativo, onde objetos s√£o armazenados em pares **chave-valor**. As chaves s√£o √∫nicas, mas os valores podem se repetir. N√£o h√° garantia de ordem ao percorrer os elementos.

Fazendo uma analogia com Blocos de montar, um **Map** seria como uma cole√ß√£o de blocos, ou seja, um conjunto, n√£o ordenados, onde cada elemento possui uma Chave e um Valor, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/lyMrafp.png" title="source: imgur.com" /></div>

A implementa√ß√£o **HashMap** armazena pares chave-valor sem manter ordem, n√£o permite chaves duplicadas e aceita valores nulos.

**LinkedHashMap** mant√©m a ordem de inser√ß√£o dos elementos e tamb√©m n√£o permite chaves duplicadas.

**TreeMap** armazena os elementos em ordem crescente de chave, n√£o permitindo duplicatas.

Por fim, **Hashtable** √© uma implementa√ß√£o que usa o m√©todo `hashCode()` para posicionar elementos, n√£o permite chaves duplicadas e √© sincronizada, diferente do **HashMap**.

Cada interface possui diversas implementa√ß√µes que representam diferentes estruturas de dados, permitindo escolher a que melhor se adapta √†s necessidades espec√≠ficas da aplica√ß√£o.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html" target="_blank"><b>Artigo: Java Tutorials: Collections</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html" target="_blank"><b>Documenta√ß√£o: Collections</b></a></div>

<br />

<h2>2. Iterator</h2>



A interface **Iterable** √© a raiz da hierarquia das cole√ß√µes em Java, o que significa que todas as classes e interfaces do pacote **Collections** a implementam direta ou indiretamente. A principal fun√ß√£o do **Iterator** √© permitir que o usu√°rio percorra, de forma sequencial, todos os elementos presentes em qualquer cole√ß√£o, como se fossem uma lista simples de itens.

O **Iterator** deve ser utilizado sempre que for necess√°rio enumerar elementos nas cole√ß√µes que implementam interfaces como **Set**, **List**, **Queue**, **Deque**, al√©m das classes que implementam a interface **Map** (atrav√©s da cole√ß√£o de chaves, valores ou entradas).

**Sintaxe:**

```java
Iterator<T> nomeDoIterator = nomeDaCollection.iterator();
```

O par√¢metro gen√©rico **`<T>`** representa o tipo dos objetos armazenados na cole√ß√£o. Esse tipo deve obrigatoriamente ser um objeto, podendo ser uma **classe wrapper** para tipos primitivos ou uma classe definida pela pessoa desenvolvedora.

Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Interface Iterator:

<br />

**‚úÖ - Tabela - M√©todos - Iterator**

| M√©todo        | Descri√ß√£o                                                    |
| ------------- | ------------------------------------------------------------ |
| **hasNext()** | Retorna `true` se houver mais elementos na itera√ß√£o.         |
| **next()**    | Retorna o pr√≥ximo elemento da itera√ß√£o. Lan√ßa a exce√ß√£o **NoSuchElementException** se n√£o houver mais elementos. |

<br />

As principais vantagens da Interface Iterator s√£o:

- Funciona com qualquer cole√ß√£o que implemente a interface **Iterable**;

- √â um iterador universal para todas as collections do Java;

- Os nomes dos m√©todos s√£o simples e intuitivos.


As principais limita√ß√µes da Interface Iterator s√£o:

- Permite apenas itera√ß√£o unidirecional, ou seja, do in√≠cio ao fim da cole√ß√£o;
- N√£o suporta itera√ß√£o paralela ou concorrente, sendo restrito a itera√ß√£o sequencial.

Nos pr√≥ximos t√≥picos, veremos alguns exemplos com a Interface Iterator.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank"><b>Documenta√ß√£o: Java Type Generic</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank"><b>Documenta√ß√£o: Interface Iterator</b></a></div>

<br />

<h2>3. A Interface Collection e a Classe Collections</h2>



A interface `Collection` em Java faz parte do **Collections Framework** e serve como a **superinterface base** para estruturas `List`, `Set` e `Queue`. Ela define o comportamento geral que todas as cole√ß√µes devem seguir, como m√©todos para adicionar, remover, verificar se um elemento est√° presente, esvaziar a cole√ß√£o, entre outros. No entanto, por ser uma interface, ela **n√£o implementa nenhum comportamento diretamente** ‚Äî quem faz isso s√£o as classes concretas que a implementam, como `ArrayList`, `HashSet` ou `LinkedList`.

√â importante n√£o confundir a **interface `Collection`** com o **framework completo de cole√ß√µes** ou com a **classe utilit√°ria `Collections`**: 

- A interface `Collection` √© apenas **uma parte da hierarquia do framework**, e n√£o representa por si s√≥ a biblioteca inteira. 
- O `Collections Framework` √© o nome dado ao conjunto completo de interfaces (como `Collection`, `List`, `Set`, `Map`, etc.) e suas implementa√ß√µes. 
- A classe `Collections` (com "s" no final) √© uma **classe utilit√°ria** que oferece m√©todos est√°ticos auxiliares, como ordena√ß√£o, busca e invers√£o de elementos, para manipular as cole√ß√µes, de acordo com as caracter√≠sticas de cada uma.

Portanto, `Collection`, `Collections` e `Collections Framework` s√£o conceitos diferentes e complementares. Entender essa diferen√ßa ajuda a evitar confus√µes e a utilizar corretamente os recursos oferecidos pela linguagem.

<br />

<h2>4. A Collection ArrayList</h2>



Neste curso, estudaremos mais a fundo a interface **List** e sua implementa√ß√£o mais utilizada, a classe **ArrayList**. 

**ArrayList** √© a escolha natural quando se precisa de um vetor redimension√°vel que oferece alta efici√™ncia para opera√ß√µes de leitura. Isso porque ela √© implementada internamente com arrays, o que torna o acesso aleat√≥rio aos elementos r√°pido e direto.

**Sintaxe:**

```java
ArrayList<T> notas = new ArrayList<T>();
```

O construtor padr√£o, sem argumentos, cria um objeto novo e vazio da classe **ArrayList**.

O par√¢metro gen√©rico **`<T>`** representa o tipo de objeto que ser√° armazenado na cole√ß√£o. Esse tipo deve obrigatoriamente ser um objeto, que pode ser uma **classe wrapper** (como `Integer`, `Double`, etc.) ou uma classe criada pela pessoa desenvolvedora.

<br />

<h3>4.1. Principais M√©todos da Interface List</h3>



A tabela abaixo apresenta os principais m√©todos para trabalhar com a cole√ß√£o **List**:

<br />

**‚úÖ - Tabela - M√©todos da Classe ArrayList**

| **M√©todo**                          | **Descri√ß√£o**                                                |
| ----------------------------------- | ------------------------------------------------------------ |
| **add(Objeto)**                     | Adiciona um objeto ao final da lista.                        |
| **add(√çndice, Objeto)**             | Adiciona um objeto na posi√ß√£o indicada, deslocando os elementos posteriores para a frente. |
| **get(√çndice)**                     | Retorna o objeto armazenado na posi√ß√£o indicada.             |
| **indexOf(Objeto)**                 | Retorna o √≠ndice da primeira ocorr√™ncia do objeto na lista.  |
| **set(√çndice, Objeto)**             | Substitui o objeto na posi√ß√£o indicada pelo objeto fornecido. |
| **remove(√çndice)**                  | Remove o objeto na posi√ß√£o indicada pelo √≠ndice.             |
| **remove(Objeto)**                  | Remove a primeira ocorr√™ncia do objeto informado.            |
| **clear()**                         | Remove todos os elementos da lista, esvaziando-a.            |
| **size()**                          | Retorna o n√∫mero de elementos atualmente armazenados na lista. |
| **isEmpty()**                       | Retorna `true` se a lista estiver vazia.                     |
| **contains(Objeto)**                | Retorna `true` se a lista cont√©m ao menos uma ocorr√™ncia do objeto. |
| **sort(null)**                      | Ordena os elementos da lista em ordem natural crescente.     |
| **sort(Comparator.reverseOrder())** | Ordena os elementos da lista em ordem decrescente.           |

<br />

<h3>4.2. Comparator</h3>



No t√≥pico anterior, na √∫ltima linha da tabela, aparece como par√¢metro do m√©todo `sort` um m√©todo chamado `reverseOder` , que pertence a Interface `Comparator`. Afinal de contas, O que √© essa interface Comparator?

O `Comparator` em Java √© uma interface funcional do pacote `java.util` usada para definir **regras de ordena√ß√£o personalizada** entre objetos. Ao contr√°rio da interface `Comparable`, que imp√µe uma ordem natural diretamente na classe do objeto, o `Comparator` permite **criar m√∫ltiplas formas de compara√ß√£o** sem modificar a classe original. Isso √© √∫til quando se deseja ordenar os mesmos dados de formas diferentes ‚Äî por exemplo, uma lista de produtos pode ser ordenada por nome, por pre√ßo ou por data de cria√ß√£o, dependendo da necessidade.

> A interface **Comparable** em Java √© usada para definir a ordem natural dos objetos de uma classe, permitindo que eles sejam comparados entre si. Para isso, a classe que implementa **Comparable** deve sobrescrever o m√©todo `compareTo(T o)`, que compara o objeto atual com outro do mesmo tipo, retornando um valor negativo, zero ou positivo para indicar se o objeto atual √© menor, igual ou maior que o outro, respectivamente. Essa funcionalidade √© fundamental para ordenar cole√ß√µes de objetos, como listas ou arrays, de forma consistente e autom√°tica.

O m√©todo `Comparator.reverseOrder()` em Java retorna um comparador que imp√µe a **ordem inversa √† ordem natural** dos elementos. Ele √© √∫til quando se deseja ordenar uma lista de objetos que implementam a interface `Comparable`, mas em ordem decrescente ‚Äî sem precisar criar um `Comparator` manualmente. Por exemplo, se uma lista de n√∫meros ou Strings est√° ordenada do menor para o maior, o `reverseOrder()` inverte essa l√≥gica, colocando o maior primeiro.

Esse m√©todo √© geralmente usado com `Collections.sort(lista, Comparator.reverseOrder())` ou diretamente com `lista.sort(Comparator.reverseOrder())`. √â importante lembrar que s√≥ funciona com elementos que implementam `Comparable`, como `String`, `Integer`, `Double` e outras classes que t√™m uma ordem natural.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank"><b>Documenta√ß√£o: Comparator</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank"><b>Documenta√ß√£o: Comparable</b></a></div>

<br />

Para exemplificar o uso dos m√©todos da cole√ß√£o `List`, construiremos um CRUD simples (Create, Read, Update e Delete) que armazenar√° n√∫meros inteiros utilizando a cole√ß√£o `ArrayList`. Os n√∫meros ser√£o armazenados como objetos da classe wrapper `Integer`, j√° que as cole√ß√µes em Java n√£o aceitam tipos primitivos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 02 - Collection ArrayList

```java
package exemplos_collections;

import java.util.ArrayList;
import java.util.Scanner;

public class Exemplo02 {

	public static void main(String[] args) {

		// Instancia o objeto Scanner para ler os dados do teclado
		Scanner leia = new Scanner(System.in);

		// Cria√ß√£o da Collection ArrayList para armazenar n√∫meros inteiros
		ArrayList<Integer> lista = new ArrayList<Integer>();

		// Declara√ß√£o das vari√°veis auxiliares
		int opcao = -1;
		int numero, posicao, novoNumero;

		// Estrutura de repeti√ß√£o que exibe o menu at√© o usu√°rio escolher sair (op√ß√£o 0)
		while (opcao != 0) {
			System.out.println("\n--- CRUD Simples ---");
			System.out.println("1 - Adicionar n√∫mero");
			System.out.println("2 - Listar n√∫meros");
			System.out.println("3 - Procurar n√∫mero espec√≠fico");
			System.out.println("4 - Alterar n√∫mero");
			System.out.println("5 - Remover n√∫mero");
			System.out.println("0 - Sair");
			System.out.print("Escolha uma op√ß√£o: ");

            // L√™ a op√ß√£o escolhida pelo usu√°rio
			opcao = leia.nextInt(); 

			// Estrutura de decis√£o com base na op√ß√£o escolhida
			switch (opcao) {
			case 1:
				// Adiciona um novo n√∫mero √† lista
				System.out.print("Digite o n√∫mero: ");
				numero = leia.nextInt();
				
                  // Adiciona o n√∫mero √† ArrayList
				lista.add(numero);
				
				System.out.printf("N√∫mero %d adicionado!%n", numero);
				break;

			case 2:
				// Lista todos os n√∫meros cadastrados
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
				} else {
					System.out.println("Lista de n√∫meros\n");
					for (int indice = 0; indice < lista.size(); indice++) {
						System.out.printf("Lista[%d]: %d%n", indice, lista.get(indice));
					}
				}
				break;

			case 3:
				// Procura por um n√∫mero espec√≠fico na lista
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o n√∫mero: ");
				numero = leia.nextInt();

                 // Retorna o √≠ndice do n√∫mero (ou -1 se n√£o existir)
				posicao = lista.indexOf(numero); 
                    
				if (posicao >= 0) {
					System.out.printf("N√∫mero %d encontrado no √≠ndice %d%n", numero, posicao);
				} else {
					System.out.printf("N√∫mero %d n√£o encontrado!%n", numero);
				}
				break;

			case 4:
				// Altera o n√∫mero em uma posi√ß√£o espec√≠fica
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o √≠ndice do n√∫mero: ");
				posicao = leia.nextInt();

				if (posicao < 0 || posicao >= lista.size()) {
					System.out.println("√çndice inv√°lido!");
					break;
				}

				System.out.print("Digite o novo valor: ");
				novoNumero = leia.nextInt();

				// Recupera o valor antigo, atualiza e exibe confirma√ß√£o
				numero = lista.get(posicao);
				lista.set(posicao, novoNumero);
				System.out.printf("Valor no √≠ndice %d alterado de %d para %d.%n", posicao, numero, novoNumero);
				break;

			case 5:
				// Remove o n√∫mero de uma posi√ß√£o espec√≠fica
				if (lista.isEmpty()) {
					System.out.println("Lista vazia!");
					break;
				}
				
				System.out.print("Digite o √≠ndice do n√∫mero: ");
				posicao = leia.nextInt();

				if (posicao < 0 || posicao >= lista.size()) {
					System.out.println("√çndice inv√°lido!");
					break;
				}

                  // Remove o n√∫mero e retorna o valor removido
				numero = lista.remove(posicao); 
				System.out.printf("O n√∫mero %d armazenado no √≠ndice %d foi removido.%n", numero, posicao);
				break;

			case 0:
				// Encerra o programa
				System.out.println("Encerrando...");
				break;

			default:
				// Caso a op√ß√£o n√£o seja reconhecida
				System.out.println("Op√ß√£o inv√°lida.");
			}
		}

		// Fecha o Scanner ao final do programa
		leia.close();
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 1
Digite o n√∫mero: 1
N√∫mero 1 adicionado!

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 1
Digite o n√∫mero: 2
N√∫mero 2 adicionado!

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 1
Digite o n√∫mero: 3
N√∫mero 3 adicionado!

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 1
Digite o n√∫mero: 4
N√∫mero 4 adicionado!

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 1
Digite o n√∫mero: 5
N√∫mero 5 adicionado!

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 2
Lista de n√∫meros

Lista[0]: 1
Lista[1]: 2
Lista[2]: 3
Lista[3]: 4
Lista[4]: 5

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 3
Digite o n√∫mero: 3
N√∫mero 3 encontrado no √≠ndice 2

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 4
Digite o √≠ndice do n√∫mero: 2
Digite o novo valor: 10
Valor no √≠ndice 2 alterado de 3 para 10.

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 2
Lista de n√∫meros

Lista[0]: 1
Lista[1]: 2
Lista[2]: 10
Lista[3]: 4
Lista[4]: 5

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 5
Digite o √≠ndice do n√∫mero: 2
O n√∫mero 10 armazenado no √≠ndice 2 foi removido.

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 2
Lista de n√∫meros

Lista[0]: 1
Lista[1]: 2
Lista[2]: 4
Lista[3]: 5

--- CRUD Simples ---
1 - Adicionar n√∫mero
2 - Listar n√∫meros
3 - Procurar n√∫mero espec√≠fico
4 - Alterar n√∫mero
5 - Remover n√∫mero
0 - Sair
Escolha uma op√ß√£o: 0
Encerrando...
```

Confira os coment√°rios inseridos no c√≥digo para compreender o funcionamento do programa. Eles explicam passo a passo a l√≥gica aplicada na cria√ß√£o do CRUD, desde a inclus√£o de n√∫meros inteiros na `ArrayList` at√© a listagem, remo√ß√£o e atualiza√ß√£o dos dados. O exemplo utiliza a classe Wrapper `Integer` para armazenar os dados, garantindo compatibilidade com a Collection, que n√£o aceita tipos primitivos.

<br />

<h3>4.3. Como a Collection ArrayList ir√° armazenar os dados?</h3>



Na imagem abaixo, temos uma representa√ß√£o gr√°fica da Collection ArrayList chamada **numeros**:

 <div align="left"><img src="https://i.imgur.com/8l8bjEv.png" /></div>

Observe que a Collection **numeros** ser√° do tipo **Integer** (classe wrapper para o tipo primitivo `int`). Cada novo valor inteiro ser√° armazenado como um objeto da classe `Integer` e adicionado em uma linha da cole√ß√£o `ArrayList`. Assim como nos vetores, cada linha (ou posi√ß√£o) √© identificada por um √≠ndice num√©rico inteiro.

A `ArrayList` mant√©m a ordem de inser√ß√£o dos elementos, ou seja, cada novo n√∫mero adicionado ser√° posicionado ap√≥s o √∫ltimo elemento inserido, respeitando a sequ√™ncia de entrada.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html" target="_blank"><b>Artigo: Java Tutorials: Collection List</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank"><b>Documenta√ß√£o: Collection List</b></a></div>

<br />

<h2>5. A Collection Set </h2>



A interface **Set** representa uma cole√ß√£o que **n√£o permite elementos duplicados**. Ou seja, ela garante que cada elemento inserido seja √∫nico. Essa interface faz parte do pacote `java.util` e estende a interface `Collection`, herdando seus principais m√©todos. No entanto, ao contr√°rio de uma `List`, um `Set` **n√£o mant√©m a ordem dos elementos**, e essa ordem **pode variar com o tempo**, especialmente ap√≥s inser√ß√µes e remo√ß√µes.

Embora seja poss√≠vel inserir um √∫nico valor `null`, essa pr√°tica **n√£o √© recomendada**, pois pode causar comportamentos inesperados em algumas implementa√ß√µes.

Diferente das listas, a interface `Set` **n√£o permite acessar elementos por √≠ndice**, ou seja, n√£o √© poss√≠vel usar m√©todos como `get(int index)` para recuperar um item. Os elementos s√£o organizados internamente com base em seu **hash code**, calculado pelo m√©todo `hashCode()` de cada objeto. Esse hash code √© um valor inteiro que determina a posi√ß√£o do objeto na estrutura subjacente ‚Äî por exemplo, em um `HashSet`, os elementos s√£o armazenados com base na estrutura de um `HashMap`.

Quando criamos um `HashSet`, ele internamente utiliza um objeto `HashMap` para armazenar os elementos. Cada elemento inserido no `HashSet` √© armazenado como uma **chave** no `HashMap`, enquanto o **valor associado** √© uma constante interna chamada `PRESENT`. Isso garante a unicidade dos elementos, j√° que as chaves de um `Map` tamb√©m n√£o podem se repetir.

Veja a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/xSBwPjD.png" title="source: imgur.com" /></div>

Observe na imagem acima que, para cada objeto inserido na cole√ß√£o do tipo **Set**, a fun√ß√£o de **hash** √© executada, ou seja, o m√©todo `hashCode()` do objeto √© calculado. A partir desse valor, √© determinada a posi√ß√£o do objeto na estrutura interna do **HashMap**, sem considerar a ordem de inser√ß√£o dos elementos.

No **HashSet**, os elementos adicionados s√£o armazenados como chaves (**keys**) no `HashMap` interno, enquanto o valor (**value**) associado a cada chave √© uma constante fixa, geralmente chamada de `PRESENT`. Essa implementa√ß√£o garante a unicidade dos elementos no conjunto.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Orienta√ß√£o aos Detalhes*
>
> O principal objetivo da cole√ß√£o **Set** n√£o √© preservar a ordem ou a posi√ß√£o de inser√ß√£o dos elementos, mas sim garantir a exclusividade dos seus valores, assegurando que n√£o haja repeti√ß√µes.

<br />

**Sintaxe:**

```java
Set<T> setNumeros = new HashSet<T>();
```

No nosso curso, vamos estudar a **Collection Set**, focando na subclasse **HashSet**. O construtor padr√£o, sem argumentos, cria um novo objeto da classe **HashSet** vazio.

O par√¢metro gen√©rico **`<T>`** em Java representa um **Tipo Gen√©rico**. Ele √© usado para definir o tipo de objeto que ser√° armazenado na cole√ß√£o. Esse tipo precisa ser obrigatoriamente um objeto, podendo ser uma **classe wrapper** (como `Integer`, `Double`, entre outros.) ou uma **classe personalizada criada pelo desenvolvedor**.

<br />

<h3>5.1. M√©todos da Collection Set</h3>



Na tabela abaixo, listamos os principais m√©todos para trabalhar com a **Collection Set**:

<br />

**‚úÖ - Tabela - M√©todos da Classe Set**

| **M√©todo**           | **Descri√ß√£o**                                                |
| -------------------- | ------------------------------------------------------------ |
| **add(Objeto)**      | Adiciona um objeto √† cole√ß√£o Set.                            |
| **remove(Objeto)**   | Remove o objeto armazenado na cole√ß√£o Set.                   |
| **clear()**          | Limpa todos os elementos da cole√ß√£o Set.                     |
| **size()**           | Retorna o tamanho da cole√ß√£o Set (n√∫mero de elementos armazenados). |
| **isEmpty()**        | Retorna `true` se a cole√ß√£o Set estiver vazia.               |
| **contains(Objeto)** | Retorna `true` se o objeto existe na cole√ß√£o Set.            |
| **hashCode()**       | Retorna o **hash code** do elemento.                         |

<br />

Para exemplificar o uso dos m√©todos da cole√ß√£o `Set`, construiremos um CRUD simples (Create, Read, Update e Delete) que armazenar√° nomes de frutas utilizando a cole√ß√£o `HashSet`. Os nomes ser√£o armazenados como objetos da classe  `String`, lembrando que as cole√ß√µes em Java n√£o aceitam tipos primitivos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 03 - Collection Set:

```java
package exemplos_collections;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Set;

public class Exemplo03 {

	public static void main(String[] args) {

		// Cria um objeto Scanner para capturar entrada do teclado
		Scanner scanner = new Scanner(System.in);
		
		// Cria uma cole√ß√£o do tipo Set (HashSet) para armazenar frutas
		Set<String> frutas = new HashSet<>();
		
		// Vari√°vel de controle para manter o loop do menu ativo
		boolean executar = true;

		// Loop principal do menu
		while (executar) {

			// Exibe o menu de op√ß√µes
			System.out.println("\n--- CRUD de Frutas ---");
			System.out.println("1. Adicionar fruta");
			System.out.println("2. Listar frutas");
			System.out.println("3. Atualizar fruta");
			System.out.println("4. Remover fruta");
			System.out.println("5. Sair");
			System.out.print("Escolha uma op√ß√£o: ");

			// L√™ a op√ß√£o escolhida pelo usu√°rio
			int opcao = scanner.nextInt();
			
			// Consome a quebra de linha pendente ap√≥s o nextInt
			scanner.nextLine();

			// Estrutura de decis√£o com base na op√ß√£o escolhida
			switch (opcao) {

				case 1:
					// Solicita o nome da fruta a ser adicionada
					System.out.print("Digite o nome da fruta para adicionar: ");
					
					// L√™ o nome e converte para min√∫sculas para evitar duplicatas
					String frutaAdd = scanner.nextLine().toLowerCase();

					// Tenta adicionar a fruta ao Set
					boolean adicionou = frutas.add(frutaAdd);

					// Verifica se a fruta foi realmente adicionada
					if (adicionou) {
						System.out.printf("Fruta '%s' adicionada com sucesso!%n", frutaAdd);
					} else {
						System.out.printf("Fruta '%s' j√° existe na lista.%n", frutaAdd);
					}
					break;

				case 2:
					// Verifica se o Set est√° vazio antes de listar
					if (frutas.isEmpty()) {
						System.out.println("Nenhuma fruta cadastrada.");
					} else {
						System.out.println("Frutas cadastradas:");

						// Cria um novo Iterator para percorrer a cole√ß√£o
						Iterator<String> iteratorFrutas = frutas.iterator();

						// Percorre os elementos enquanto houver pr√≥ximos
						while (iteratorFrutas.hasNext()) {
							String fruta = iteratorFrutas.next();
							System.out.printf("- %s%n", fruta);
						}
					}
					break;

				case 3:
					// Solicita o nome da fruta que ser√° atualizada
					System.out.print("Digite o nome da fruta que deseja atualizar: ");
					String frutaAntiga = scanner.nextLine();

					// Verifica se a fruta antiga existe no Set
					if (frutas.contains(frutaAntiga)) {

						// Solicita o novo nome da fruta
						System.out.print("Digite o novo nome da fruta: ");
						String frutaNova = scanner.nextLine();

						// Remove a fruta antiga e adiciona a nova
						frutas.remove(frutaAntiga);
						frutas.add(frutaNova);

						System.out.printf("Fruta '%s' atualizada para '%s' com sucesso!%n", frutaAntiga, frutaNova);
					} else {
						System.out.printf("Fruta '%s' n√£o encontrada.%n", frutaAntiga);
					}
					break;

				case 4:
					// Solicita o nome da fruta que ser√° removida
					System.out.print("Digite o nome da fruta para remover: ");
					String frutaRemover = scanner.nextLine();

					// Tenta remover a fruta
					boolean removeu = frutas.remove(frutaRemover);

					// Informa se a fruta foi removida ou n√£o encontrada
					if (removeu) {
						System.out.printf("Fruta '%s' removida com sucesso!%n", frutaRemover);
					} else {
						System.out.printf("Fruta '%s' n√£o encontrada.%n", frutaRemover);
					}
					break;

				case 5:
					// Encerra o loop e finaliza o programa
					executar = false;
					System.out.println("Encerrando o programa...");
					break;

				default:
					// Mensagem para op√ß√£o inv√°lida
					System.out.println("Op√ß√£o inv√°lida. Tente novamente.");
			}
		}

		// Fecha o Scanner ao final da execu√ß√£o
		scanner.close();
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 1
Digite o nome da fruta para adicionar: abacate
Fruta 'abacate' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 1
Digite o nome da fruta para adicionar: amora
Fruta 'amora' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 1
Digite o nome da fruta para adicionar: morango
Fruta 'morango' adicionada com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 2
Frutas cadastradas:
- morango
- abacate
- amora

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 3
Digite o nome da fruta que deseja atualizar: amora
Digite o novo nome da fruta: manga
Fruta 'amora' atualizada para 'manga' com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 4
Digite o nome da fruta para remover: morango
Fruta 'morango' removida com sucesso!

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 2
Frutas cadastradas:
- abacate
- manga

--- CRUD de Frutas ---
1. Adicionar fruta
2. Listar frutas
3. Atualizar fruta
4. Remover fruta
5. Sair
Escolha uma op√ß√£o: 5
Encerrando o programa...

```

Confira os coment√°rios inseridos no c√≥digo para compreender o funcionamento do programa. Eles explicam, passo a passo, a l√≥gica aplicada na cria√ß√£o do CRUD, desde a inclus√£o dos nomes na cole√ß√£o `HashSet` at√© a listagem, remo√ß√£o e atualiza√ß√£o dos dados.

Note que neste exemplo utilizamos o **Iterator** para percorrer a cole√ß√£o `HashSet` durante a listagem das frutas cadastradas. Como o `HashSet` n√£o mant√©m uma ordem fixa e n√£o possui √≠ndices, o Iterator fornece uma forma eficiente e segura para acessar cada elemento da cole√ß√£o, um por vez.

A implementa√ß√£o no c√≥digo segue estes passos:

1. **Obten√ß√£o do Iterator:** Usamos o m√©todo `iterator()` da cole√ß√£o `HashSet` para criar um objeto do tipo `Iterator<String>`.

   ```java
   Iterator<String> iteratorFrutas = frutas.iterator();
   ```

2. **Itera√ß√£o pelos elementos:** Utilizamos um la√ßo `while` para percorrer os elementos enquanto o Iterator indicar que ainda h√° elementos dispon√≠veis com o m√©todo `hasNext()`.

   ```java
   while (iteratorFrutas.hasNext()) {
       String fruta = iteratorFrutas.next();
       System.out.printf("- %s%n", fruta);
   }
   ```

3. **Acesso aos elementos:** A cada itera√ß√£o, o m√©todo `next()` retorna o pr√≥ximo elemento da cole√ß√£o, que pode ser usado dentro do corpo do la√ßo para exibi√ß√£o ou processamento.

Dessa forma, o Iterator abstrai a complexidade da estrutura interna do `HashSet`, permitindo navegar pelos seus elementos sem precisar conhecer detalhes de implementa√ß√£o, al√©m de evitar problemas como erros de concorr√™ncia em cole√ß√µes modificadas durante a itera√ß√£o.

Observe que a cada chamada para listar as frutas no menu, √© necess√°rio criar um novo **Iterator**, pois ele mant√©m um estado interno que indica a posi√ß√£o atual na cole√ß√£o e, ap√≥s percorrer todos os elementos, n√£o pode ser reutilizado para iniciar uma nova itera√ß√£o. Por isso, para percorrer a cole√ß√£o do in√≠cio a cada listagem, √© preciso obter um novo Iterator chamando `frutas.iterator()`.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html" target="_blank"><b>Artigo: Java Tutorials: Collection Set</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank"><b>Documenta√ß√£o: Collection List</b></a></div>

<br />

------

## üîë**Pontos chave:**

1. **Collections (Cole√ß√µes)** em Java s√£o estruturas que permitem armazenar, organizar e manipular conjuntos de dados de forma flex√≠vel e din√¢mica, sem precisar definir um tamanho fixo como nos arrays tradicionais.
2. O **Collections Framework** √© um conjunto de interfaces e classes localizadas no pacote `java.util`, que oferecem suporte a estruturas como **List**, **Set**, **Queue**, **Deque** e **Map**.
3. A **classe utilit√°ria `Collections`** fornece m√©todos auxiliares para ordenar, embaralhar, inverter e buscar elementos dentro de cole√ß√µes.
4. A **interface `List`** representa listas ordenadas que aceitam elementos duplicados e permitem acesso por √≠ndice. As principais implementa√ß√µes s√£o `ArrayList`, `LinkedList` e `Vector`.
5. A **interface `Set`** representa conjuntos que **n√£o permitem elementos duplicados** e **n√£o garantem ordem**. Suas principais implementa√ß√µes s√£o `HashSet`, `LinkedHashSet` e `TreeSet`.
6. A **interface `Map`** armazena pares **chave-valor**, onde as chaves s√£o √∫nicas e os valores podem se repetir. Suas implementa√ß√µes mais comuns s√£o `HashMap`, `LinkedHashMap`, `TreeMap` e `Hashtable`.
7. A **interface `Queue`** define estruturas do tipo fila (FIFO), e `Deque` permite inser√ß√£o e remo√ß√£o em ambas as extremidades. `ArrayDeque` e `PriorityQueue` s√£o implementa√ß√µes frequentes.
8. A **interface `Iterator`** permite percorrer elementos de uma cole√ß√£o de forma sequencial e segura, sendo uma alternativa ao la√ßo `for...each`.
9. As **classes wrappers** (como `Integer`, `Double`, `Boolean`) s√£o usadas para encapsular tipos primitivos em objetos, permitindo que sejam armazenados em cole√ß√µes.
10. O **m√©todo `Comparator.reverseOrder()`** fornece uma forma simples e direta de ordenar cole√ß√µes em **ordem decrescente**, especialmente √∫til com listas de elementos que implementam `Comparable`.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
