<h1>Tratamento de erros no Java - Exceptions</h1>



Componentes de software podem apresentar problemas durante a execução, gerando erros que podem resultar em:

- Encerramento abrupto do programa;
- Retorno de mensagens de erro indicando falhas;
- Retorno e ignorância do problema, sem notificação;
- Chamada de métodos específicos para tratar o erro, entre outros.

Os problemas mais comuns são:

- Falha na aquisição de recursos (como criação de objetos com `new`, abertura de arquivos, conexão com banco de dados, entre outros.);
- Tentativa de executar operações inválidas (divisão por zero, acesso a índice inválido de um array, entre outros);
- Condições inválidas ou inesperadas (lista vazia, estouro de capacidade — overflow, entre outros.).

Para lidar com esses problemas, utilizamos o mecanismo de **Exceções (Exceptions)**.

<br />

<h2>1. Exceções (Exceptions)</h2>



**Exceções** são eventos que indicam a ocorrência de problemas durante a execução de um programa, interrompendo o fluxo normal do código e gerando erros na aplicação.

Na linguagem Java, é possível tratar essas exceções — que normalmente causariam a interrupção do programa — para que a aplicação continue funcionando ou finalize de forma controlada, tornando o código mais robusto e confiável.

As exceções em Java são objetos instanciados a partir de classes específicas do pacote `java.lang`, que são lançados (*throw*) quando condições excepcionais ocorrem durante a execução.

<br />

<h3>1.1 Tipos de erros</h2>


Os erros em aplicações Java podem ser classificados em três categorias principais:

1. **Erros de lógica:** Problemas no algoritmo ou na estrutura do programa, que devem ser identificados e corrigidos pela pessoa desenvolvedora durante a fase de implementação.

   **Exemplos:** acesso a índices inválidos em arrays, divisão por zero, uso incorreto de variáveis.

2. **Erros relacionados ao ambiente de execução:** Falhas que ocorrem devido a condições externas ao programa. Apesar de estarem fora do controle direto do desenvolvedor, esses erros podem ser tratados adequadamente em tempo de execução.

   **Exemplos:** arquivo não encontrado, falha na conexão de rede, falta de permissão de acesso.

3. **Erros graves (Errors):** Condições críticas que geralmente indicam falhas na JVM ou no ambiente, e que não podem ser tratadas pela aplicação.

   **Exemplos:** falta de memória (`OutOfMemoryError`), erro interno da JVM, falha de hardware.

O mecanismo de exceções em Java concentra-se principalmente no tratamento e prevenção dos **erros de lógica** e das **condições excepcionais de execução** (tipos 1 e 2). Já os **erros graves** (tipo 3) não costumam ser tratados, pois indicam falhas sérias no ambiente que exigem intervenção externa.

Dessa forma, **os erros de lógica devem ser corrigidos no código**, enquanto as **exceções** lidam com situações inesperadas que ocorrem em tempo de execução, oferecendo uma forma segura de manter o controle e a estabilidade da aplicação.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Código sem Tratamento de Exceções

```java
package exceptions;

import java.util.Scanner;

public class Exemplo01 {
	
	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		System.out.println("Digite o Numerador: ");
		int numerador = leia.nextInt();
				
		System.out.println("Digite o Denominador: ");
		int denominador = leia.nextInt();
				
		dividir(numerador, denominador);
        
        leia.close();
		
	}

	public static void dividir(int numerador, int denominador) {
		System.out.printf("%d / %d = %d%n" , numerador, denominador, numerador / denominador);
	}

}
```

O código apresentado acima representa um programa simples que solicita ao usuário dois números inteiros e realiza a chamada de um método responsável pela divisão entre esses dois valores.

Ao executar o programa e digitar os valores `10` e `0`, será gerada uma **exceção do tipo `ArithmeticException`**, pois a divisão por zero não é permitida em Java. Nesse caso, o bloco `catch` correspondente será acionado, exibindo uma mensagem de erro clara e controlada para o usuário, sem que a aplicação seja encerrada de forma abrupta.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/MpS8KsN.png" title="source: imgur.com" /></div>

Na imagem acima, observamos que foi disparada uma exceção do tipo **`ArithmeticException`**, indicando que ocorreu um erro durante uma operação aritmética — neste caso, a tentativa de divisão por zero. Como não houve tratamento apropriado anteriormente, o programa foi encerrado de forma abrupta, sem permitir ao usuário a chance de corrigir a entrada ou seguir com a execução normalmente.

Essa exceção é comum quando o divisor (denominador) recebe o valor **zero**, o que matematicamente não é permitido e, em Java, resulta em erro de tempo de execução.

Agora, execute o programa novamente e, desta vez, tente inserir uma **String** (por exemplo, `"oi"`) no lugar do segundo número. O que ocorrerá será a geração de uma nova exceção — desta vez do tipo **`InputMismatchException`**, indicando que o valor informado não corresponde ao tipo de dado esperado (`int`), ou seja, o programa esperava um número inteiro, mas recebeu um texto.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/6WYtzEX.png" title="source: imgur.com" /></div>

Na imagem acima, vemos que desta vez foi disparada uma outra exceção: **`InputMismatchException`**, indicando que ocorreu um erro na entrada de dados da aplicação. Como resultado, o programa foi encerrado imediatamente, sem oferecer a oportunidade de tratamento ou correção da entrada pelo usuário.

Nesse exemplo, a exceção foi gerada porque a classe `Scanner` esperava receber um valor do tipo **inteiro (`int`)**, mas recebeu uma **`String`** (texto) inválida, incompatível com o tipo esperado. Esse tipo de erro é comum em sistemas que recebem dados diretamente do usuário e não fazem validação adequada das entradas.

Quando uma exceção é lançada sem nenhum tipo de tratamento, ela interrompe o **fluxo normal** do programa, como foi observado nos dois exemplos anteriores. Caso o método onde o erro ocorreu não capture a exceção, ela será **propagada** automaticamente para o método que realizou a chamada, seguindo essa cadeia até o topo da pilha de execução. Se **nenhum** método capturar essa exceção, o programa será encerrado abruptamente.

No entanto, se em algum ponto da execução a exceção for **capturada**, o controle da aplicação pode ser **recuperado**, permitindo que o programa continue sua execução de forma segura ou finalize de maneira controlada.

Um bom **Sistema de Tratamento de Exceções** busca atender a três princípios fundamentais:

- **Antecipar-se aos problemas**: uma das responsabilidades da pessoa desenvolvedora é prever possíveis falhas e preparar o código para lidar com elas;
- **Reverter situações de erro recuperáveis**: sempre que possível, retomar o funcionamento normal após uma falha;
- **Tratar exceções de forma isolada**: buscar a **solução ideal** para lidar com erros sem comprometer a lógica principal do programa.

Com o uso do mecanismo de tratamento de exceções, o programa consegue **capturar e lidar com erros** em tempo de execução, evitando interrupções inesperadas. Para isso, a linguagem Java oferece a estrutura **`try-catch-finally`**, que permite envolver blocos de código suscetíveis a falhas e definir ações específicas para tratamento e finalização.

<br />

<h2>2. Estrutura try-catch-finally</h2>



A estrutura **`try-catch-finally`** é utilizada em Java para capturar e tratar erros (exceções) que possam ocorrer durante a execução de um bloco de código. Essa estrutura é composta por três blocos principais, cada um com uma função específica:

- **`try`**: indica o bloco de código que será monitorado quanto à ocorrência de exceções. Se uma exceção for lançada (`throw`) em qualquer ponto dentro do bloco `try`, a execução é imediatamente interrompida e o controle é passado ao primeiro bloco `catch` correspondente. Importante destacar que o bloco `try` **não pode ser utilizado isoladamente**, ou seja, ele **deve** ser seguido por pelo menos um bloco `catch` ou por um bloco `finally`.
- **`catch`**: responsável por capturar e tratar a exceção lançada no bloco `try`. Será executado **somente** se ocorrer uma exceção compatível com o tipo especificado no parâmetro. É possível declarar **vários blocos `catch`**, cada um tratando um tipo específico de exceção, porém apenas o **primeiro compatível** com a exceção lançada será executado.
- **`finally`**: é um bloco **opcional**, que será executado **sempre ao final da estrutura**, independentemente de uma exceção ter sido lançada ou não. A única exceção à execução do bloco `finally` ocorre quando a aplicação é encerrada abruptamente (por exemplo, com `System.exit(0)`). Esse bloco é comumente utilizado para **liberação de recursos**, como fechamento de arquivos, conexões com banco de dados, ou limpeza de memória. Ele também pode conter sua própria estrutura `try-catch-finally`, se necessário.

**Sintaxe padrão**

```java
try {
    // Código que pode lançar exceção
} catch (TipoDaExcecao01 e) {
    // Código para tratar a exceção 01
} catch (TipoDaExcecao02 e) {
    // Código para tratar a exceção 02
} finally {
    // Código a ser executado sempre, com ou sem erro
}
```

O **bloco `try`** contém o código que pode lançar uma exceção. É iniciado pela palavra-chave `try`, seguida de um bloco entre chaves `{}`.

O **bloco `catch`** é responsável por capturar e tratar exceções que possam ser lançadas dentro do bloco `try`. Ele é iniciado pela palavra-chave `catch`, seguida de um parâmetro entre parênteses que representa o tipo da exceção a ser tratada — normalmente uma classe que estende `Throwable`, como `Exception`, `IOException`, `ArithmeticException`, entre outras.

Cada **bloco `catch` trata uma exceção específica**, permitindo que o programa execute ações diferentes conforme o tipo de erro ocorrido. Em uma estrutura com múltiplos blocos `catch`, será executado **apenas o primeiro bloco que corresponder ao tipo da exceção lançada**.

O código dentro do bloco `catch` define **como o erro será tratado**, seja exibindo uma mensagem personalizada, registrando logs, tentando uma nova operação ou encerrando o programa de forma controlada.

O **bloco `finally`**, se declarado, será executado independentemente do fluxo anterior, seja ele normal ou excepcional. Normalmente, é usado para liberar recursos, como **fechar conexões com banco de dados**, arquivos ou sockets.

<br />

**Sintaxe - Multi-Catch**

```java
try {
    // Código que pode lançar várias exceções
} catch (TipoDaExcecao01 | TipoDaExcecao02 e) {
    // Tratamento comum para ambas as exceções
} finally {
    // Código a ser executado sempre, com ou sem erro
}
```

A sintaxe **multi-catch**, permite capturar **várias exceções diferentes** em um único bloco `catch`, desde que todas sejam **independentes entre si**, ou seja, **não tenham relação de herança direta**. Essa abordagem é útil quando diferentes tipos de exceções exigem o **mesmo tratamento**, tornando o código mais limpo, organizado e fácil de manter.

No exemplo acima, tanto a exceção `TipoDaExcecao01` quanto `TipoDaExcecao02` , separadas pelo caractere *pipe* `|`, serão capturadas pelo mesmo bloco `catch`, e tratadas da mesma forma. 

A variável `e`, que representa a exceção, é considerada **efetivamente final**, o que significa que **não pode ser reatribuída** dentro do bloco. 

A estrutura `try-catch-finally` continua sendo válida nesse contexto, com o bloco `finally` sendo executado independentemente da ocorrência de exceções — ideal para liberar recursos, como conexões ou arquivos abertos. O uso de multi-catch melhora a legibilidade e evita duplicação de código quando o tratamento para diferentes exceções é equivalente.

> [!IMPORTANT]
>
> Ao utilizar múltiplos blocos `catch`, seja individualmente ou em grupo (multi-catch), é fundamental capturar primeiro as exceções mais específicas e, somente depois, as exceções mais genéricas (como `Exception e`). 
>
> Essa ordem garante que os erros sejam tratados corretamente, evitando que exceções genéricas capturem situações que deveriam ser resolvidas por tratamentos específicos.

<br />

<h3>2.2. Comando de Saída - System.err.println()</h3>



O comando de saída **`System.err.println()`** funciona de forma semelhante ao **`System.out.println()`**, com a diferença principal de que ele é utilizado para exibir mensagens de erro no console. Enquanto `System.out` direciona a saída para o fluxo padrão (stdout), o `System.err` envia a saída para o fluxo de erro padrão (stderr).

Em ambientes de desenvolvimento, como o Eclipse, as mensagens enviadas pelo `System.err.println()` costumam ser exibidas em cores diferentes, geralmente em vermelho, para destacar que se tratam de erros ou avisos importantes, facilitando a identificação rápida de problemas durante a execução do programa.

**Sintaxe**

```java
System.err.println("Mensagem de erro");
```

<br />

<h3>2.2. Métodos da classe Throwable</h3>



A classe **`Throwable`** é a superclasse raiz de todas as exceções e erros em Java, incluindo tanto as subclasses de **`Exception`** quanto as de **`Error`**. Ela fornece um conjunto essencial de métodos que permitem acessar informações detalhadas sobre a exceção ou erro que foi lançado durante a execução do programa. Esses métodos são fundamentais para o diagnóstico, tratamento e registro dos problemas que ocorrem em tempo de execução.

A seguir, apresentamos os principais métodos disponíveis na classe `Throwable`, que auxiliam no entendimento e no gerenciamento das exceções capturadas:

| Método                | Descrição                                                    | Exemplo de uso                                     |
| --------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| `e.getMessage()`      | Retorna a mensagem de erro associada à exceção.              | `System.err.println(e.getMessage());`              |
| `e.toString()`        | Retorna uma string com o nome da classe da exceção e a mensagem de erro. | `System.err.println(e.toString());`                |
| `e.getClass()`        | Retorna a classe real (tipo) da exceção lançada.             | `System.err.println(e.getClass());`                |
| `e.printStackTrace()` | Imprime no console o rastreamento completo da pilha de chamadas no momento do erro. | `e.printStackTrace();`                             |
| `e.getCause()`        | Retorna a causa da exceção, se houver (encadeamento de exceções). | `Throwable causa = e.getCause();`                  |
| `e.getStackTrace()`   | Retorna um array de `StackTraceElement` com detalhes sobre a pilha de execução. | `for (StackTraceElement elem : e.getStackTrace())` |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - Código com Tratamento de Exceções



Vamos aprimorar o **Exemplo01**, adicionando **tratamento de exceções** para tornar a aplicação mais robusta e segura durante a execução.

No exemplo abaixo, utilizamos a estrutura `try-catch-finally` para capturar erros comuns durante a entrada de dados e a operação de divisão. O programa solicita dois valores inteiros do usuário (numerador e denominador) e realiza a divisão, tratando situações como divisão por zero e a entrada inválida.

```java
package exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Exemplo02 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		boolean continua = true;
		
		do {

			try {
				System.out.println("Digite o Numerador: ");
				int numerador = leia.nextInt();
						
				System.out.println("Digite o Denominador: ");
				int denominador = leia.nextInt();
				
				dividir(numerador, denominador);
				
				continua = false;

			} catch (ArithmeticException e) {
				System.err.println("Erro: " + e.getMessage());
				System.err.println("Erro: Divisão por zero não é permitida.");
				leia.nextLine();
			}catch(InputMismatchException e){
				System.err.println("Erro: " + e);
				System.err.println("Erro: Digite numeros inteiros.");
				leia.nextLine();
			} finally {
				if(continua) {
					System.out.println("\nPrograma reiniciado.\n");
				}else {
					System.out.println("\nExecução finalizada.");
				}
			}
		} while (continua);

		leia.close();
	}

	public static void dividir(int numerador, int denominador) {
		System.out.printf("%d / %d = %d%n" , numerador, denominador, numerador / denominador);
	}


}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

✔**Teste 01: Denominador igual a zero**

<div align="center"><img src="https://i.imgur.com/RL02uEo.png" title="source: imgur.com" /></div>

Neste teste, foi digitado o valor `0` como divisor. Como a divisão por zero não é permitida, a exceção **`ArithmeticException`** foi lançada e devidamente tratada. Uma mensagem clara foi exibida ao usuário, informando o erro. 

> [!WARNING]
>
> Para exibir a mensagem do erro ao usuário (`/ by zero`), foi utilizado o método **`e.getMessage()`**, que retorna uma descrição específica da exceção capturada.
>
> No entanto, em sistemas reais, essa mensagem normalmente **não é exibida diretamente ao usuário final**, pois pode conter detalhes técnicos. Em vez disso, ela costuma ser **registrada em logs internos do sistema**, enquanto o usuário recebe uma mensagem mais amigável e genérica, como "*Ocorreu um erro ao processar a operação.*"

O programa, em vez de ser encerrado abruptamente, foi reiniciado automaticamente, permitindo uma nova tentativa de entrada dos dados.

<br />

✔**Teste 02: String no lugar de um numero**

<div align="center"><img src="https://i.imgur.com/zAOGsjH.png" title="source: imgur.com" /></div>

Neste teste, foi inserido um texto (String) em vez de um número. Isso gerou a exceção **`InputMismatchException`**, que foi capturada, e uma mensagem informando o erro foi exibida. O `Scanner` foi resetado com `leia.nextLine()` para limpar o buffer e permitir nova entrada.

<br />

✔**Teste 03: Entrada válida (10 e 2)**

<div align="center"><img src="https://i.imgur.com/NYycqyl.png" title="source: imgur.com" /></div>

Neste caso, foram digitados os valores `10` e `2`. A operação de divisão foi realizada com sucesso, e o resultado foi exibido corretamente. Como não houve erro, o programa foi finalizado normalmente.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html" target="_blank"><b>Documentação: Try..Catch..Finally</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/util/InputMismatchException.html" target="_blank"><b>Documentação: Classe InputMismatchException</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ArithmeticException.html" target="_blank"><b>Documentação: Classe ArithmeticException</b></a></div>

<br />

<h2>3. A Classe Exceptions</h2>



No exemplo anterior, foram tratadas duas exceções dentro da aplicação: **ArithmeticException** e **InputMismatchException**. Mas de onde vêm essas exceções?

Essas classes fazem parte da hierarquia da classe **Throwable**, que é a superclasse de todas as exceções e erros em Java. Veja na imagem abaixo a estrutura da hierarquia:

<div align="center"><img src="https://i.imgur.com/01NfvQ6.png" title="source: imgur.com" /></div>

A seguir, uma descrição dos principais elementos dessa hierarquia:

- **Throwable**: Superclasse de todos os erros (**Error**) e exceções (**Exception**) em Java. Somente objetos que herdam de `Throwable` podem ser lançados (`throw`) ou capturados (`catch`).
- **Error**: Representa erros graves que não devem ser tratados pela aplicação, como **OutOfMemoryError** (estouro de memória). Em geral, indicam falhas no ambiente de execução da JVM.
- **Exception**: Representa condições anormais que podem ser tratadas pela aplicação. Por exemplo, tentar abrir um arquivo que não existe.
- **RuntimeException**: Subclasse de `Exception` que representa erros de programação, como divisão por zero ou acesso a índice inválido de um array. São exceções detectadas **em tempo de execução** e que **não são obrigatoriamente tratadas**.
- **IOException**: Subclasse de `Exception` que representa erros relacionados a operações de entrada/saída, como falhas ao ler um arquivo. Essas exceções **devem ser tratadas**.

<br />

<h3>3.1. Classificação das Exceções</h3>



Em Java, as exceções são classificadas em duas categorias:

<br />

<h4>3.1.1 Checked Exceptions (Exceções Verificadas)</h4>



São exceções verificadas em tempo de compilação. O compilador exige que essas exceções sejam tratadas com `try-catch` ou declaradas com `throws`.

Essas exceções geralmente indicam falhas externas ao programa, como problemas de rede, arquivos ou banco de dados.

**Exemplo:** `IOException`, `SQLException`.

<br />

<h4>3.1.2. Unchecked Exceptions (Exceções Não Verificadas)</h4>



São exceções que ocorrem em tempo de execução e não são verificadas pelo compilador. O tratamento é opcional. 

Normalmente, representam erros de lógica na aplicação e devem ser evitados com boas práticas de programação.

**Exemplo:** `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException` (todas herdam `RuntimeException`).

<br />

<h3>3.2. Diferenças entre Erros e Exceções</h3>



A tabela a seguir resume as principais diferenças entre **Erros** e **Exceções**:

<br />

## 🆚 Tabela Comparativa:  Erros vs Exceções

| **Erros**                                                    | **Exceções**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Não é possível se recuperar de um erro.                      | É possível se recuperar de exceções utilizando `try-catch` ou lançando para outro método. |
| Todos os erros são **Unchecked** (não verificados).          | As exceções podem ser **Checked** (verificadas) ou **Unchecked** (não verificadas). |
| São causados principalmente por falhas no ambiente de execução da aplicação. | São causadas por problemas na lógica do código ou situações esperadas em tempo de execução. |
| Podem ocorrer em tempo de compilação (ex.: erros de sintaxe) ou em tempo de execução. | Ocorrem exclusivamente em tempo de execução. Checked são conhecidas pelo compilador; Unchecked não. |
| São definidas no pacote **`java.lang.Error`**.               | São definidas no pacote **`java.lang.Exception`**.           |

<br />

<h3>3.3. Exceções Integradas</h3>



As **exceções integradas** são aquelas fornecidas pela própria linguagem Java, disponíveis principalmente nos pacotes `java.lang.Error` e `java.lang.Exception`. Elas representam erros comuns que podem ocorrer durante a execução de um programa e cobrem desde problemas de lógica até falhas de entrada e saída.

Essas exceções são divididas em duas grandes categorias: **Checked Exceptions** (verificadas) e **Unchecked Exceptions** (não verificadas). A seguir, apresentamos as mais utilizadas em cada categoria.

<br />

<h4>3.3.1. Exceções do tipo Checked</h4>



Essas exceções são **verificadas em tempo de compilação**, e o compilador exige que sejam tratadas com `try-catch` ou declaradas com `throws`. Elas geralmente representam situações externas ao programa, como falhas de I/O ou recursos ausentes.

| Exceção                    | Descrição                                                    | Exemplo                                                      |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ClassNotFoundException** | Lançada quando a aplicação tenta carregar uma classe que não foi encontrada no classpath. | Ao tentar carregar dinamicamente uma classe inexistente usando `Class.forName()`. |
| **FileNotFoundException**  | Ocorre quando um arquivo não pode ser encontrado ou acessado. | Ao tentar abrir um arquivo que não existe com `FileReader`.  |
| **NoSuchFieldException**   | Lançada quando um campo (atributo) não é encontrado em determinada classe. | Ao usar reflexão (`reflection`) para acessar um atributo inexistente. |
| **NoSuchMethodException**  | Ocorre quando um método específico não é encontrado em uma classe. | Ao tentar invocar um método que não foi definido via reflexão. |

<br />

<h4>3.3.2. Exceções do tipo Unchecked</h4>



Essas exceções são **não verificadas** e ocorrem geralmente por erros de programação ou lógica. O compilador não exige seu tratamento, mas é possível (e recomendado) tratá-las em tempo de execução quando necessário.

| Exceção                            | Descrição                                                    | Exemplo                                                      |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ArithmeticException**            | Lançada quando ocorre erro em operações matemáticas, como divisão por zero. | Dividir um número inteiro por zero.                          |
| **ArrayIndexOutOfBoundsException** | Lançada ao tentar acessar um índice inválido em um array.    | Acessar o índice 10 em um array de tamanho 5.                |
| **NullPointerException**           | Lançada ao acessar métodos ou atributos de uma referência nula. | Tentar acessar `obj.getNome()` onde `obj` é `null`.          |
| **NumberFormatException**          | Lançada ao tentar converter uma `String` inválida para número. | Usar `Integer.parseInt("abc")`.                              |
| **IllegalArgumentException**       | Lançada quando um argumento inválido é passado para um método. | Passar um número negativo para um método que espera apenas positivos. |
| **IllegalStateException**          | Lançada quando o método é chamado em um estado inapropriado do objeto. | Chamar `next()` em um `Iterator` já esgotado.                |

<br />


<h2>4. Throw</h2>



A palavra-chave **`throw`** é utilizada para **lançar uma exceção em qualquer ponto do código**, transferindo o controle do fluxo de execução para o método chamador. Diferente da cláusula `throws`, o uso de `throw` **não exige que a exceção seja tratada no local em que é lançada**, mas sim que o tratamento ocorra em algum nível da pilha de chamadas.

A instrução `throw` pode ser utilizada tanto para **exceções verificadas (checked)** quanto **não verificadas (unchecked)**. Seu uso é comum em situações em que se deseja **lançar exceções personalizadas**, criadas pela pessoa desenvolvedora, quando os tipos de exceção integrados do Java não representam adequadamente o erro ocorrido.

Abaixo, veja um exemplo de uso da cláusula `throw` com uma exceção integrada:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Throw

No exemplo abaixo, vamos construir uma aplicação para checar se uma pessoa está apta a dirigir:

```java
package exceptions;

import java.util.Scanner;

public class Exemplo03 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int idade;
		
		System.out.println("\nDigite uma idade: ");
		idade = leia.nextInt();
		
		validarIdade(idade);
		
		leia.close();
		
	}

	public static void validarIdade(int idade){
		
		if(idade < 18) {
			throw new ArithmeticException("A Pessoa não pode dirigir!!");
		}else {
			System.out.println("A Pessoa pode dirigir!!");
		}
	
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/qRqPzbl.png" title="source: imgur.com" /></div>

Observe que a exceção **`ArithmeticException`** foi lançada dentro do método **`validarIdade()`**, exibindo a mensagem padrão do erro, e o programa foi finalizado imediatamente.

Ao executar a instrução **`throw`**, o programa passa a buscar, na pilha de execução, algum bloco **`try`** que contenha uma cláusula **`catch`** compatível com o tipo da exceção lançada. Se encontrar um bloco correspondente, o controle do fluxo será transferido para esse bloco, permitindo o tratamento da exceção. Caso contrário, o programa será encerrado de forma abrupta.

Vamos, a seguir, atualizar o código inserindo um bloco **`try...catch`** para tratar a exceção de forma adequada.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Throw com Try-Catch

```java
package exceptions;

import java.util.Scanner;

public class Exemplo04{

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int idade;
		boolean continua = true;
		
		do {
		
			try {
			
				System.out.println("\nDigite uma idade: ");
				idade = leia.nextInt();
					
				validarIdade(idade);
				
				continua = false;
				
			}catch(ArithmeticException e){
				System.err.println("\nDigite um número inteiro maior ou igual a 18!");
			}
			
		}while (continua);
		
		leia.close();
		
	}

	public static void validarIdade(int idade){
		
		if(idade < 18) {
			throw new ArithmeticException("A Pessoa não pode dirigir!!");
		}else {
			System.out.println("A Pessoa pode dirigir!!");
		}
	
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/Jv8aPGN.png" title="source: imgur.com" /></div>

Observe que a exceção **`ArithmeticException`** foi lançada dentro do método **`validarIdade()`**, mas, desta vez, foi exibida uma **mensagem personalizada**: *"Digite um número inteiro maior ou igual a 18!"*.

Além disso, o **controle do tratamento do erro foi transferido para o bloco `try...catch`**, que orienta o usuário a digitar uma nova idade válida (maior ou igual a 18).

Como foi implementado um laço de repetição **`do...while`**, esse processo será repetido até que o usuário informe corretamente uma idade igual ou superior a 18.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html" target="_blank"><b>Documentação: Classe Throwable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank"><b>Documentação: Classe Exception</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html" target="_blank"><b>Documentação: Throw</b></a></div>

<br />

<h2>4. Throws</h2>



A cláusula **`throws`** é utilizada para **informar que um método pode lançar uma ou mais exceções** durante a sua execução. Ela aparece **na assinatura do método**, logo **após os parênteses de parâmetros** e **antes da abertura do corpo** do método.

Pense na cláusula `throws` como um **aviso ou promessa feita pelo método**: ele está dizendo que, ao ser executado, pode ocorrer um erro (exceção), e que quem chamou esse método deve estar preparado para tratar esse erro.

A sintaxe permite listar **uma ou mais exceções**, separadas por vírgulas, que podem ser lançadas tanto por instruções escritas dentro do corpo do método quanto por métodos chamados dentro dele.

**Sintaxe**

```java
public class TestaExcecao {

    public static void main(String[] args) throws Exception1, Exception2 {
        // código que pode gerar Exception1 ou Exception2
    }

}
```

No exemplo acima, a cláusula **`throws`** está dizendo que o método `main` **pode lançar duas exceções**: `Exception1` e `Exception2`. Isso significa que qualquer classe que chamar esse método deverá:

- **Tratar essas exceções com um bloco `try-catch`**, ou
- **Propagar essas exceções adiante**, utilizando também `throws` na assinatura do método chamador.

Essa é a principal diferença entre **`throw`** e **`throws`**:

- **`throw`**: é usado **dentro do corpo do método**, para **lançar uma exceção naquele ponto específico**.
- **`throws`**: é usado **na assinatura do método**, para **declarar que aquele método pode lançar exceções** durante sua execução.

Outro ponto importante é que, ao usar `throws`, estamos falando principalmente de **exceções verificadas (checked exceptions)** — ou seja, aquelas que o compilador exige que sejam tratadas ou propagadas. Para **exceções não verificadas (unchecked exceptions)**, o uso de `throws` não é obrigatório, embora ainda possa ser utilizado para fins de documentação.

<br />

## 🆚 Tabela Comparativa: `throw` vs `throws`

| throw                                  | throws                                    |
| -------------------------------------- | ----------------------------------------- |
| Lança uma exceção em tempo de execução | Declara que o método pode lançar exceções |
| Usado dentro do corpo do método        | Usado na assinatura do método             |
| Exige uma instância de Exception       | Lista as exceções separadas por vírgula   |
| Pode lançar checked ou unchecked       | Obrigatório para checked exceptions       |

<br />

<h3>4.1. Exceções Personalizadas</h3>



Em Java, **exceções personalizadas** são utilizadas quando os tipos de erro fornecidos pela linguagem não representam bem uma situação específica da sua aplicação. Elas permitem criar mensagens mais claras, controlar melhor o fluxo de execução e tornar o código mais expressivo. 

Para criar uma exceção personalizada, basta criar uma nova classe que **estenda `Exception`** (para exceções verificadas) ou `RuntimeException` (para não verificadas), podendo incluir construtores e mensagens específicas.

O uso de exceções personalizadas melhora a legibilidade e o tratamento de erros, permitindo que diferentes situações de falha sejam tratadas de forma distinta. Por exemplo, em um sistema de e-commerce, pode-se criar exceções como `PagamentoException`, `EstoqueInsuficienteException` ou `CarrinhoVazioException` para representar erros específicos do domínio da aplicação, oferecendo ao usuário e ao desenvolvedor mensagens mais informativas e precisas.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Throws e Exceções Personalizadas



Em um sistema de e-commerce, é comum validar se o cliente possui saldo suficiente antes de concluir uma compra. Caso o valor da compra seja superior ao saldo disponível, o sistema deve impedir o pagamento e informar o motivo ao cliente, de forma clara e controlada.

Neste exemplo, vamos implementar essa regra utilizando uma **exceção personalizada**, chamada `PagamentoException`. Essa exceção será **lançada com o comando `throw`** dentro do método responsável pelo pagamento, e **declarada na assinatura com a cláusula `throws`**, indicando que o método pode gerar esse tipo de erro.

Além disso, o erro será **tratado com um bloco `try...catch`**, permitindo exibir uma mensagem amigável ao cliente, sem encerrar o programa abruptamente.

A seguir, veremos a implementação passo a passo:

<br />

**Classe PagamentoException**

```java
package exceptions;

public class PagamentoException extends Exception {

	private static final long serialVersionUID = 1L;
	
	public PagamentoException() { }

	public PagamentoException(String mensagem) {
		super(mensagem);
	}
}
```

A classe **`PagamentoException`** é uma **exceção personalizada** criada para representar erros específicos relacionados a falhas no processo de pagamento, como saldo insuficiente. Ela foi definida como uma **subclasse da classe `Exception`**, ou seja, herda todas as características de uma exceção verificada (checked exception) em Java.

Note que dentro da classe, foi declarado o campo: `private static final long serialVersionUID = 1L;`. Esse atributo é um **identificador único da versão da classe** e está relacionado ao processo de **serialização e desserialização** de objetos em Java.

> ### 🔄 O que é Serialização?
>
> **Serialização** é o processo de transformar um objeto em uma **sequência de bytes**, permitindo que ele seja salvo em disco, transmitido pela rede ou armazenado para uso posterior. Para que uma classe possa ser serializada, ela deve implementar a interface `java.io.Serializable`.
>
> Quando um objeto é serializado, o valor do `serialVersionUID` é incluído junto com os dados. Durante a **desserialização** (o processo inverso), a JVM compara o `serialVersionUID` do objeto com o da classe carregada. Se os valores não coincidirem, será lançada uma exceção do tipo **`InvalidClassException`**, indicando incompatibilidade entre as versões.
>
> #### 💡 Comparação simples:
>
> Imagine que a serialização é como **tirar uma foto digital de um objeto** para guardá-la ou enviá-la a alguém. Essa "foto" captura todas as informações do estado atual do objeto. O `serialVersionUID` funciona como uma **etiqueta com a data e versão** da foto. Se, ao tentar usar essa foto para recriar o objeto, a etiqueta indicar uma versão diferente da atual, a reconstrução falha — é como tentar montar um quebra-cabeça com peças que já foram alteradas.
>
> ### Em resumo:
>
> - **Serialização** = Tira uma foto do objeto e transforma isso em dados (bytes).
>- **Desserialização** = Usa a foto (dados) para recriar o objeto.
> - **serialVersionUID** = O número de série da foto, garantindo que a foto é compatível com a versão do objeto.

<br />

A classe `PagamentoException` possui dois **métodos construtores**, herdados e adaptados da classe `Exception`:

- Um **construtor padrão (sem parâmetros)**: permite lançar a exceção sem definir uma mensagem específica.
- Um **construtor com o parâmetro `String mensagem`**: permite lançar a exceção com uma **mensagem personalizada**, tornando o erro mais descritivo para o usuário ou para logs de sistema.

A classe `Exception` ainda possui outros construtores com parâmetros adicionais, que podem ser utilizados conforme a necessidade da aplicação.

<br />

**Classe Cliente**

```java
package exceptions;

public class Cliente {

    private String nome;
    private float saldo;

    public Cliente(String nome, float saldo) {
        this.nome = nome;
        this.saldo = saldo;
    }

    public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public float getSaldo() {
		return saldo;
	}

	public void setSaldo(float saldo) {
		this.saldo = saldo;
	}

    public void realizarPagamento(float valorCompra) throws PagamentoException {
        if (valorCompra > saldo) {
            throw new PagamentoException("Saldo insuficiente para concluir a compra.");
        }
        saldo -= valorCompra;
        System.out.println("Pagamento aprovado! Obrigado pela compra, " + nome + ".");
        System.out.println("Saldo restante: R$ " + saldo);
    }
    
    public void visualizar() {
    	System.out.println("\n=========================================");
    	System.out.println("Dados do Cliente");
    	System.out.println("=========================================");
    	System.out.printf("Nome do cliente: %s%n", this.nome);
    	System.out.printf("Saldo do cliente: R$ %.2f%n", this.saldo);
    }
}
```

A classe **`Cliente`** representa um cliente de e-commerce, contendo os atributos `nome` e `saldo`, além de métodos para acessar e modificar esses dados.

Observe o método **`realizarPagamento(float valorCompra)`**, responsável por processar uma compra. Ele verifica se o saldo do cliente é suficiente para cobrir o valor informado. Caso não seja, **lança uma exceção personalizada do tipo `PagamentoException`** com uma mensagem clara. Se o pagamento for aprovado, o valor é descontado do saldo, e uma mensagem de confirmação é exibida.

Nesse método, é utilizada a combinação das palavras-chave **`throws`** e **`throw`**. A cláusula **`throws`**, presente na assinatura do método, informa que ele pode lançar uma exceção do tipo `PagamentoException`. Já o comando **`throw`** é utilizado dentro do método para **lançar efetivamente** a exceção, caso o valor da compra ultrapasse o saldo disponível.

Esse método ilustra bem o uso de **exceções personalizadas no controle de regras de negócio**, promovendo clareza, segurança e maior controle sobre o fluxo de execução no processo de pagamento.

<br />

**Classe Exemplo05 (classe pincipal)**

```java
package exceptions;

public class Exemplo05 {

    public static void main(String[] args) {
    	
    	Cliente cliente = new Cliente("Maria da Silva", 200.00f);
    	
    	cliente.visualizar();

        float valorCompra = 350.00f;
        
        System.out.printf("\nValor da compra: R$ %.2f%n", valorCompra);

        try {
            cliente.realizarPagamento(valorCompra);
        } catch (PagamentoException e) {
            System.err.println("\nErro no pagamento: " + e.getMessage());
            System.err.println("\nPor favor, revise o valor da compra.");
        }
        
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/V7EiHjy.png" title="source: imgur.com" /></div>

No **Exemplo05**, foi criado um objeto da classe `Cliente` com saldo inicial de **R$ 200,00**. Em seguida, foi simulada uma compra no valor de **R$ 350,00**.

O trecho dentro do bloco **`try`** tenta realizar o pagamento. Como o valor da compra excede o saldo disponível, o método **`realizarPagamento`** lança uma exceção do tipo **`PagamentoException`**, como vemos na imagem acima. Essa exceção é então capturada pelo bloco **`catch`**, que trata o erro exibindo uma mensagem personalizada ao usuário, sem interromper a execução do programa.

Esse uso do `try-catch` demonstra como **exceções personalizadas ajudam a controlar regras de negócio** e melhorar a experiência do usuário em casos de erro.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html" target="_blank"><b>Documentação: Classe Throwable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank"><b>Documentação: Classe Exception</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" target="_blank"><b>Documentação: Classe RuntimeException</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html" target="_blank"><b>Documentação: Throw</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html" target="_blank"><b>Documentação: Throws</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="_blank"><b>Documentação: Interface Serializable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="4%"/> <a href="https://www.oracle.com/br/technical-resources/articles/java/serialversionuid.html" target="_blank"><b>Documentação: <i>SerialVersionUID</i></b></a></div>

<br />

<h2>5. Por que devemos tratar as Exceções?</h2>



O tratamento de exceções é fundamental para garantir que a aplicação **reaja de forma controlada a erros inesperados**, evitando falhas críticas que possam interromper sua execução. Sem esse cuidado, qualquer erro — por menor que seja — pode causar o encerramento abrupto do sistema, resultando em perda de dados, frustração do usuário e prejuízos à confiabilidade do software.

**Exemplo do dia a dia:**

Imagine que você está utilizando um aplicativo bancário e, ao tentar consultar o saldo, a conexão com a internet falha. Sem o tratamento adequado, o aplicativo poderia simplesmente **fechar sem explicações**. Com o uso de exceções, é possível exibir uma **mensagem amigável**, como: “*Não foi possível carregar os dados. Verifique sua conexão com a internet.*”

<br />

<h3>5.1. Benefícios do tratamento de exceções</h3>



- **Evita que o programa seja interrompido** ao encontrar erros durante a execução.
- **Proporciona mensagens de erro compreensíveis e orientativas** para o usuário final.
- **Organiza melhor o código**, separando a lógica principal do tratamento de erros.
- **Facilita o diagnóstico de falhas**, permitindo o registro detalhado dos erros por meio de logs.
- **Torna o software mais robusto e profissional**, especialmente em sistemas críticos como bancos, hospitais e comércios eletrônicos.

**Tratar exceções é como implementar um plano de contingência dentro do seu código:** Ele garante que, mesmo diante de problemas, o sistema mantenha sua estabilidade e ofereça uma resposta clara e segura ao usuário.

<br />

------

## 🔑**Pontos chave:**

1. **Exceções em Java** são objetos que representam erros ou condições excepcionais que podem ocorrer durante a execução do programa. Elas permitem capturar e tratar falhas de forma controlada.

2. O bloco **try/catch/finally** é a estrutura utilizada para capturar e tratar exceções em Java:

   - **try**: bloco monitorado.

   - **catch**: trata a exceção lançada.

   - **finally**: executa sempre, independentemente da ocorrência de erro.

3. A **cláusula throws** declara que um método pode lançar uma ou mais exceções. É obrigatória para **checked exceptions** e opcional para **unchecked exceptions**.
4. A **cláusula throw** é utilizada dentro do método para lançar uma exceção em tempo de execução, transferindo o fluxo de controle para o tratamento apropriado (catch ou propagação).
5. É possível criar **exceções personalizadas** (custom exceptions) que herdam de Exception ou RuntimeException, para representar erros específicos do domínio da aplicação.
6. O tratamento de exceções torna o código **mais robusto, seguro e amigável ao usuário**, prevenindo encerramentos inesperados e permitindo uma recuperação controlada dos erros.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
