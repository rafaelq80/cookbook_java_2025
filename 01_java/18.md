<h1>Tratamento de erros no Java - Exceptions</h1>



Componentes de software podem apresentar problemas durante a execu√ß√£o, gerando erros que podem resultar em:

- Encerramento abrupto do programa;
- Retorno de mensagens de erro indicando falhas;
- Retorno e ignor√¢ncia do problema, sem notifica√ß√£o;
- Chamada de m√©todos espec√≠ficos para tratar o erro, entre outros.

Os problemas mais comuns s√£o:

- Falha na aquisi√ß√£o de recursos (como cria√ß√£o de objetos com `new`, abertura de arquivos, conex√£o com banco de dados, entre outros.);
- Tentativa de executar opera√ß√µes inv√°lidas (divis√£o por zero, acesso a √≠ndice inv√°lido de um array, entre outros);
- Condi√ß√µes inv√°lidas ou inesperadas (lista vazia, estouro de capacidade ‚Äî overflow, entre outros.).

Para lidar com esses problemas, utilizamos o mecanismo de **Exce√ß√µes (Exceptions)**.

<br />

<h2>1. Exce√ß√µes (Exceptions)</h2>



**Exce√ß√µes** s√£o eventos que indicam a ocorr√™ncia de problemas durante a execu√ß√£o de um programa, interrompendo o fluxo normal do c√≥digo e gerando erros na aplica√ß√£o.

Na linguagem Java, √© poss√≠vel tratar essas exce√ß√µes ‚Äî que normalmente causariam a interrup√ß√£o do programa ‚Äî para que a aplica√ß√£o continue funcionando ou finalize de forma controlada, tornando o c√≥digo mais robusto e confi√°vel.

As exce√ß√µes em Java s√£o objetos instanciados a partir de classes espec√≠ficas do pacote `java.lang`, que s√£o lan√ßados (*throw*) quando condi√ß√µes excepcionais ocorrem durante a execu√ß√£o.

<br />

<h3>1.1 Tipos de erros</h2>


Os erros em aplica√ß√µes Java podem ser classificados em tr√™s categorias principais:

1. **Erros de l√≥gica:** Problemas no algoritmo ou na estrutura do programa, que devem ser identificados e corrigidos pela pessoa desenvolvedora durante a fase de implementa√ß√£o.

   **Exemplos:** acesso a √≠ndices inv√°lidos em arrays, divis√£o por zero, uso incorreto de vari√°veis.

2. **Erros relacionados ao ambiente de execu√ß√£o:** Falhas que ocorrem devido a condi√ß√µes externas ao programa. Apesar de estarem fora do controle direto do desenvolvedor, esses erros podem ser tratados adequadamente em tempo de execu√ß√£o.

   **Exemplos:** arquivo n√£o encontrado, falha na conex√£o de rede, falta de permiss√£o de acesso.

3. **Erros graves (Errors):** Condi√ß√µes cr√≠ticas que geralmente indicam falhas na JVM ou no ambiente, e que n√£o podem ser tratadas pela aplica√ß√£o.

   **Exemplos:** falta de mem√≥ria (`OutOfMemoryError`), erro interno da JVM, falha de hardware.

O mecanismo de exce√ß√µes em Java concentra-se principalmente no tratamento e preven√ß√£o dos **erros de l√≥gica** e das **condi√ß√µes excepcionais de execu√ß√£o** (tipos 1 e 2). J√° os **erros graves** (tipo 3) n√£o costumam ser tratados, pois indicam falhas s√©rias no ambiente que exigem interven√ß√£o externa.

Dessa forma, **os erros de l√≥gica devem ser corrigidos no c√≥digo**, enquanto as **exce√ß√µes** lidam com situa√ß√µes inesperadas que ocorrem em tempo de execu√ß√£o, oferecendo uma forma segura de manter o controle e a estabilidade da aplica√ß√£o.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - C√≥digo sem Tratamento de Exce√ß√µes

```java
package exceptions;

import java.util.Scanner;

public class Exemplo01 {
	
	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		System.out.println("Digite o Numerador: ");
		int numerador = leia.nextInt();
				
		System.out.println("Digite o Denominador: ");
		int denominador = leia.nextInt();
				
		dividir(numerador, denominador);
        
        leia.close();
		
	}

	public static void dividir(int numerador, int denominador) {
		System.out.printf("%d / %d = %d%n" , numerador, denominador, numerador / denominador);
	}

}
```

O c√≥digo apresentado acima representa um programa simples que solicita ao usu√°rio dois n√∫meros inteiros e realiza a chamada de um m√©todo respons√°vel pela divis√£o entre esses dois valores.

Ao executar o programa e digitar os valores `10` e `0`, ser√° gerada uma **exce√ß√£o do tipo `ArithmeticException`**, pois a divis√£o por zero n√£o √© permitida em Java. Nesse caso, o bloco `catch` correspondente ser√° acionado, exibindo uma mensagem de erro clara e controlada para o usu√°rio, sem que a aplica√ß√£o seja encerrada de forma abrupta.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/MpS8KsN.png" title="source: imgur.com" /></div>

Na imagem acima, observamos que foi disparada uma exce√ß√£o do tipo **`ArithmeticException`**, indicando que ocorreu um erro durante uma opera√ß√£o aritm√©tica ‚Äî neste caso, a tentativa de divis√£o por zero. Como n√£o houve tratamento apropriado anteriormente, o programa foi encerrado de forma abrupta, sem permitir ao usu√°rio a chance de corrigir a entrada ou seguir com a execu√ß√£o normalmente.

Essa exce√ß√£o √© comum quando o divisor (denominador) recebe o valor **zero**, o que matematicamente n√£o √© permitido e, em Java, resulta em erro de tempo de execu√ß√£o.

Agora, execute o programa novamente e, desta vez, tente inserir uma **String** (por exemplo, `"oi"`) no lugar do segundo n√∫mero. O que ocorrer√° ser√° a gera√ß√£o de uma nova exce√ß√£o ‚Äî desta vez do tipo **`InputMismatchException`**, indicando que o valor informado n√£o corresponde ao tipo de dado esperado (`int`), ou seja, o programa esperava um n√∫mero inteiro, mas recebeu um texto.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/6WYtzEX.png" title="source: imgur.com" /></div>

Na imagem acima, vemos que desta vez foi disparada uma outra exce√ß√£o: **`InputMismatchException`**, indicando que ocorreu um erro na entrada de dados da aplica√ß√£o. Como resultado, o programa foi encerrado imediatamente, sem oferecer a oportunidade de tratamento ou corre√ß√£o da entrada pelo usu√°rio.

Nesse exemplo, a exce√ß√£o foi gerada porque a classe `Scanner` esperava receber um valor do tipo **inteiro (`int`)**, mas recebeu uma **`String`** (texto) inv√°lida, incompat√≠vel com o tipo esperado. Esse tipo de erro √© comum em sistemas que recebem dados diretamente do usu√°rio e n√£o fazem valida√ß√£o adequada das entradas.

Quando uma exce√ß√£o √© lan√ßada sem nenhum tipo de tratamento, ela interrompe o **fluxo normal** do programa, como foi observado nos dois exemplos anteriores. Caso o m√©todo onde o erro ocorreu n√£o capture a exce√ß√£o, ela ser√° **propagada** automaticamente para o m√©todo que realizou a chamada, seguindo essa cadeia at√© o topo da pilha de execu√ß√£o. Se **nenhum** m√©todo capturar essa exce√ß√£o, o programa ser√° encerrado abruptamente.

No entanto, se em algum ponto da execu√ß√£o a exce√ß√£o for **capturada**, o controle da aplica√ß√£o pode ser **recuperado**, permitindo que o programa continue sua execu√ß√£o de forma segura ou finalize de maneira controlada.

Um bom **Sistema de Tratamento de Exce√ß√µes** busca atender a tr√™s princ√≠pios fundamentais:

- **Antecipar-se aos problemas**: uma das responsabilidades da pessoa desenvolvedora √© prever poss√≠veis falhas e preparar o c√≥digo para lidar com elas;
- **Reverter situa√ß√µes de erro recuper√°veis**: sempre que poss√≠vel, retomar o funcionamento normal ap√≥s uma falha;
- **Tratar exce√ß√µes de forma isolada**: buscar a **solu√ß√£o ideal** para lidar com erros sem comprometer a l√≥gica principal do programa.

Com o uso do mecanismo de tratamento de exce√ß√µes, o programa consegue **capturar e lidar com erros** em tempo de execu√ß√£o, evitando interrup√ß√µes inesperadas. Para isso, a linguagem Java oferece a estrutura **`try-catch-finally`**, que permite envolver blocos de c√≥digo suscet√≠veis a falhas e definir a√ß√µes espec√≠ficas para tratamento e finaliza√ß√£o.

<br />

<h2>2. Estrutura try-catch-finally</h2>



A estrutura **`try-catch-finally`** √© utilizada em Java para capturar e tratar erros (exce√ß√µes) que possam ocorrer durante a execu√ß√£o de um bloco de c√≥digo. Essa estrutura √© composta por tr√™s blocos principais, cada um com uma fun√ß√£o espec√≠fica:

- **`try`**: indica o bloco de c√≥digo que ser√° monitorado quanto √† ocorr√™ncia de exce√ß√µes. Se uma exce√ß√£o for lan√ßada (`throw`) em qualquer ponto dentro do bloco `try`, a execu√ß√£o √© imediatamente interrompida e o controle √© passado ao primeiro bloco `catch` correspondente. Importante destacar que o bloco `try` **n√£o pode ser utilizado isoladamente**, ou seja, ele **deve** ser seguido por pelo menos um bloco `catch` ou por um bloco `finally`.
- **`catch`**: respons√°vel por capturar e tratar a exce√ß√£o lan√ßada no bloco `try`. Ser√° executado **somente** se ocorrer uma exce√ß√£o compat√≠vel com o tipo especificado no par√¢metro. √â poss√≠vel declarar **v√°rios blocos `catch`**, cada um tratando um tipo espec√≠fico de exce√ß√£o, por√©m apenas o **primeiro compat√≠vel** com a exce√ß√£o lan√ßada ser√° executado.
- **`finally`**: √© um bloco **opcional**, que ser√° executado **sempre ao final da estrutura**, independentemente de uma exce√ß√£o ter sido lan√ßada ou n√£o. A √∫nica exce√ß√£o √† execu√ß√£o do bloco `finally` ocorre quando a aplica√ß√£o √© encerrada abruptamente (por exemplo, com `System.exit(0)`). Esse bloco √© comumente utilizado para **libera√ß√£o de recursos**, como fechamento de arquivos, conex√µes com banco de dados, ou limpeza de mem√≥ria. Ele tamb√©m pode conter sua pr√≥pria estrutura `try-catch-finally`, se necess√°rio.

**Sintaxe padr√£o**

```java
try {
    // C√≥digo que pode lan√ßar exce√ß√£o
} catch (TipoDaExcecao01 e) {
    // C√≥digo para tratar a exce√ß√£o 01
} catch (TipoDaExcecao02 e) {
    // C√≥digo para tratar a exce√ß√£o 02
} finally {
    // C√≥digo a ser executado sempre, com ou sem erro
}
```

O **bloco `try`** cont√©m o c√≥digo que pode lan√ßar uma exce√ß√£o. √â iniciado pela palavra-chave `try`, seguida de um bloco entre chaves `{}`.

O **bloco `catch`** √© respons√°vel por capturar e tratar exce√ß√µes que possam ser lan√ßadas dentro do bloco `try`. Ele √© iniciado pela palavra-chave `catch`, seguida de um par√¢metro entre par√™nteses que representa o tipo da exce√ß√£o a ser tratada ‚Äî normalmente uma classe que estende `Throwable`, como `Exception`, `IOException`, `ArithmeticException`, entre outras.

Cada **bloco `catch` trata uma exce√ß√£o espec√≠fica**, permitindo que o programa execute a√ß√µes diferentes conforme o tipo de erro ocorrido. Em uma estrutura com m√∫ltiplos blocos `catch`, ser√° executado **apenas o primeiro bloco que corresponder ao tipo da exce√ß√£o lan√ßada**.

O c√≥digo dentro do bloco `catch` define **como o erro ser√° tratado**, seja exibindo uma mensagem personalizada, registrando logs, tentando uma nova opera√ß√£o ou encerrando o programa de forma controlada.

O **bloco `finally`**, se declarado, ser√° executado independentemente do fluxo anterior, seja ele normal ou excepcional. Normalmente, √© usado para liberar recursos, como **fechar conex√µes com banco de dados**, arquivos ou sockets.

<br />

**Sintaxe - Multi-Catch**

```java
try {
    // C√≥digo que pode lan√ßar v√°rias exce√ß√µes
} catch (TipoDaExcecao01 | TipoDaExcecao02 e) {
    // Tratamento comum para ambas as exce√ß√µes
} finally {
    // C√≥digo a ser executado sempre, com ou sem erro
}
```

A sintaxe **multi-catch**, permite capturar **v√°rias exce√ß√µes diferentes** em um √∫nico bloco `catch`, desde que todas sejam **independentes entre si**, ou seja, **n√£o tenham rela√ß√£o de heran√ßa direta**. Essa abordagem √© √∫til quando diferentes tipos de exce√ß√µes exigem o **mesmo tratamento**, tornando o c√≥digo mais limpo, organizado e f√°cil de manter.

No exemplo acima, tanto a exce√ß√£o `TipoDaExcecao01` quanto `TipoDaExcecao02` , separadas pelo caractere *pipe* `|`, ser√£o capturadas pelo mesmo bloco `catch`, e tratadas da mesma forma. 

A vari√°vel `e`, que representa a exce√ß√£o, √© considerada **efetivamente final**, o que significa que **n√£o pode ser reatribu√≠da** dentro do bloco. 

A estrutura `try-catch-finally` continua sendo v√°lida nesse contexto, com o bloco `finally` sendo executado independentemente da ocorr√™ncia de exce√ß√µes ‚Äî ideal para liberar recursos, como conex√µes ou arquivos abertos. O uso de multi-catch melhora a legibilidade e evita duplica√ß√£o de c√≥digo quando o tratamento para diferentes exce√ß√µes √© equivalente.

> [!IMPORTANT]
>
> Ao utilizar m√∫ltiplos blocos `catch`, seja individualmente ou em grupo (multi-catch), √© fundamental capturar primeiro as exce√ß√µes mais espec√≠ficas e, somente depois, as exce√ß√µes mais gen√©ricas (como `Exception e`). 
>
> Essa ordem garante que os erros sejam tratados corretamente, evitando que exce√ß√µes gen√©ricas capturem situa√ß√µes que deveriam ser resolvidas por tratamentos espec√≠ficos.

<br />

<h3>2.2. Comando de Sa√≠da - System.err.println()</h3>



O comando de sa√≠da **`System.err.println()`** funciona de forma semelhante ao **`System.out.println()`**, com a diferen√ßa principal de que ele √© utilizado para exibir mensagens de erro no console. Enquanto `System.out` direciona a sa√≠da para o fluxo padr√£o (stdout), o `System.err` envia a sa√≠da para o fluxo de erro padr√£o (stderr).

Em ambientes de desenvolvimento, como o Eclipse, as mensagens enviadas pelo `System.err.println()` costumam ser exibidas em cores diferentes, geralmente em vermelho, para destacar que se tratam de erros ou avisos importantes, facilitando a identifica√ß√£o r√°pida de problemas durante a execu√ß√£o do programa.

**Sintaxe**

```java
System.err.println("Mensagem de erro");
```

<br />

<h3>2.2. M√©todos da classe Throwable</h3>



A classe **`Throwable`** √© a superclasse raiz de todas as exce√ß√µes e erros em Java, incluindo tanto as subclasses de **`Exception`** quanto as de **`Error`**. Ela fornece um conjunto essencial de m√©todos que permitem acessar informa√ß√µes detalhadas sobre a exce√ß√£o ou erro que foi lan√ßado durante a execu√ß√£o do programa. Esses m√©todos s√£o fundamentais para o diagn√≥stico, tratamento e registro dos problemas que ocorrem em tempo de execu√ß√£o.

A seguir, apresentamos os principais m√©todos dispon√≠veis na classe `Throwable`, que auxiliam no entendimento e no gerenciamento das exce√ß√µes capturadas:

| M√©todo                | Descri√ß√£o                                                    | Exemplo de uso                                     |
| --------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| `e.getMessage()`      | Retorna a mensagem de erro associada √† exce√ß√£o.              | `System.err.println(e.getMessage());`              |
| `e.toString()`        | Retorna uma string com o nome da classe da exce√ß√£o e a mensagem de erro. | `System.err.println(e.toString());`                |
| `e.getClass()`        | Retorna a classe real (tipo) da exce√ß√£o lan√ßada.             | `System.err.println(e.getClass());`                |
| `e.printStackTrace()` | Imprime no console o rastreamento completo da pilha de chamadas no momento do erro. | `e.printStackTrace();`                             |
| `e.getCause()`        | Retorna a causa da exce√ß√£o, se houver (encadeamento de exce√ß√µes). | `Throwable causa = e.getCause();`                  |
| `e.getStackTrace()`   | Retorna um array de `StackTraceElement` com detalhes sobre a pilha de execu√ß√£o. | `for (StackTraceElement elem : e.getStackTrace())` |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - C√≥digo com Tratamento de Exce√ß√µes



Vamos aprimorar o **Exemplo01**, adicionando **tratamento de exce√ß√µes** para tornar a aplica√ß√£o mais robusta e segura durante a execu√ß√£o.

No exemplo abaixo, utilizamos a estrutura `try-catch-finally` para capturar erros comuns durante a entrada de dados e a opera√ß√£o de divis√£o. O programa solicita dois valores inteiros do usu√°rio (numerador e denominador) e realiza a divis√£o, tratando situa√ß√µes como divis√£o por zero e a entrada inv√°lida.

```java
package exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Exemplo02 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		boolean continua = true;
		
		do {

			try {
				System.out.println("Digite o Numerador: ");
				int numerador = leia.nextInt();
						
				System.out.println("Digite o Denominador: ");
				int denominador = leia.nextInt();
				
				dividir(numerador, denominador);
				
				continua = false;

			} catch (ArithmeticException e) {
				System.err.println("Erro: " + e.getMessage());
				System.err.println("Erro: Divis√£o por zero n√£o √© permitida.");
				leia.nextLine();
			}catch(InputMismatchException e){
				System.err.println("Erro: " + e);
				System.err.println("Erro: Digite numeros inteiros.");
				leia.nextLine();
			} finally {
				if(continua) {
					System.out.println("\nPrograma reiniciado.\n");
				}else {
					System.out.println("\nExecu√ß√£o finalizada.");
				}
			}
		} while (continua);

		leia.close();
	}

	public static void dividir(int numerador, int denominador) {
		System.out.printf("%d / %d = %d%n" , numerador, denominador, numerador / denominador);
	}


}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

‚úî**Teste 01: Denominador igual a zero**

<div align="center"><img src="https://i.imgur.com/RL02uEo.png" title="source: imgur.com" /></div>

Neste teste, foi digitado o valor `0` como divisor. Como a divis√£o por zero n√£o √© permitida, a exce√ß√£o **`ArithmeticException`** foi lan√ßada e devidamente tratada. Uma mensagem clara foi exibida ao usu√°rio, informando o erro. 

> [!WARNING]
>
> Para exibir a mensagem do erro ao usu√°rio (`/ by zero`), foi utilizado o m√©todo **`e.getMessage()`**, que retorna uma descri√ß√£o espec√≠fica da exce√ß√£o capturada.
>
> No entanto, em sistemas reais, essa mensagem normalmente **n√£o √© exibida diretamente ao usu√°rio final**, pois pode conter detalhes t√©cnicos. Em vez disso, ela costuma ser **registrada em logs internos do sistema**, enquanto o usu√°rio recebe uma mensagem mais amig√°vel e gen√©rica, como "*Ocorreu um erro ao processar a opera√ß√£o.*"

O programa, em vez de ser encerrado abruptamente, foi reiniciado automaticamente, permitindo uma nova tentativa de entrada dos dados.

<br />

‚úî**Teste 02: String no lugar de um numero**

<div align="center"><img src="https://i.imgur.com/zAOGsjH.png" title="source: imgur.com" /></div>

Neste teste, foi inserido um texto (String) em vez de um n√∫mero. Isso gerou a exce√ß√£o **`InputMismatchException`**, que foi capturada, e uma mensagem informando o erro foi exibida. O `Scanner` foi resetado com `leia.nextLine()` para limpar o buffer e permitir nova entrada.

<br />

‚úî**Teste 03: Entrada v√°lida (10 e 2)**

<div align="center"><img src="https://i.imgur.com/NYycqyl.png" title="source: imgur.com" /></div>

Neste caso, foram digitados os valores `10` e `2`. A opera√ß√£o de divis√£o foi realizada com sucesso, e o resultado foi exibido corretamente. Como n√£o houve erro, o programa foi finalizado normalmente.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html" target="_blank"><b>Documenta√ß√£o: Try..Catch..Finally</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/util/InputMismatchException.html" target="_blank"><b>Documenta√ß√£o: Classe InputMismatchException</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ArithmeticException.html" target="_blank"><b>Documenta√ß√£o: Classe ArithmeticException</b></a></div>

<br />

<h2>3. A Classe Exceptions</h2>



No exemplo anterior, foram tratadas duas exce√ß√µes dentro da aplica√ß√£o: **ArithmeticException** e **InputMismatchException**. Mas de onde v√™m essas exce√ß√µes?

Essas classes fazem parte da hierarquia da classe **Throwable**, que √© a superclasse de todas as exce√ß√µes e erros em Java. Veja na imagem abaixo a estrutura da hierarquia:

<div align="center"><img src="https://i.imgur.com/01NfvQ6.png" title="source: imgur.com" /></div>

A seguir, uma descri√ß√£o dos principais elementos dessa hierarquia:

- **Throwable**: Superclasse de todos os erros (**Error**) e exce√ß√µes (**Exception**) em Java. Somente objetos que herdam de `Throwable` podem ser lan√ßados (`throw`) ou capturados (`catch`).
- **Error**: Representa erros graves que n√£o devem ser tratados pela aplica√ß√£o, como **OutOfMemoryError** (estouro de mem√≥ria). Em geral, indicam falhas no ambiente de execu√ß√£o da JVM.
- **Exception**: Representa condi√ß√µes anormais que podem ser tratadas pela aplica√ß√£o. Por exemplo, tentar abrir um arquivo que n√£o existe.
- **RuntimeException**: Subclasse de `Exception` que representa erros de programa√ß√£o, como divis√£o por zero ou acesso a √≠ndice inv√°lido de um array. S√£o exce√ß√µes detectadas **em tempo de execu√ß√£o** e que **n√£o s√£o obrigatoriamente tratadas**.
- **IOException**: Subclasse de `Exception` que representa erros relacionados a opera√ß√µes de entrada/sa√≠da, como falhas ao ler um arquivo. Essas exce√ß√µes **devem ser tratadas**.

<br />

<h3>3.1. Classifica√ß√£o das Exce√ß√µes</h3>



Em Java, as exce√ß√µes s√£o classificadas em duas categorias:

<br />

<h4>3.1.1 Checked Exceptions (Exce√ß√µes Verificadas)</h4>



S√£o exce√ß√µes verificadas em tempo de compila√ß√£o. O compilador exige que essas exce√ß√µes sejam tratadas com `try-catch` ou declaradas com `throws`.

Essas exce√ß√µes geralmente indicam falhas externas ao programa, como problemas de rede, arquivos ou banco de dados.

**Exemplo:** `IOException`, `SQLException`.

<br />

<h4>3.1.2. Unchecked Exceptions (Exce√ß√µes N√£o Verificadas)</h4>



S√£o exce√ß√µes que ocorrem em tempo de execu√ß√£o e n√£o s√£o verificadas pelo compilador. O tratamento √© opcional. 

Normalmente, representam erros de l√≥gica na aplica√ß√£o e devem ser evitados com boas pr√°ticas de programa√ß√£o.

**Exemplo:** `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException` (todas herdam `RuntimeException`).

<br />

<h3>3.2. Diferen√ßas entre Erros e Exce√ß√µes</h3>



A tabela a seguir resume as principais diferen√ßas entre **Erros** e **Exce√ß√µes**:

<br />

## üÜö Tabela Comparativa:  Erros vs Exce√ß√µes

| **Erros**                                                    | **Exce√ß√µes**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| N√£o √© poss√≠vel se recuperar de um erro.                      | √â poss√≠vel se recuperar de exce√ß√µes utilizando `try-catch` ou lan√ßando para outro m√©todo. |
| Todos os erros s√£o **Unchecked** (n√£o verificados).          | As exce√ß√µes podem ser **Checked** (verificadas) ou **Unchecked** (n√£o verificadas). |
| S√£o causados principalmente por falhas no ambiente de execu√ß√£o da aplica√ß√£o. | S√£o causadas por problemas na l√≥gica do c√≥digo ou situa√ß√µes esperadas em tempo de execu√ß√£o. |
| Podem ocorrer em tempo de compila√ß√£o (ex.: erros de sintaxe) ou em tempo de execu√ß√£o. | Ocorrem exclusivamente em tempo de execu√ß√£o. Checked s√£o conhecidas pelo compilador; Unchecked n√£o. |
| S√£o definidas no pacote **`java.lang.Error`**.               | S√£o definidas no pacote **`java.lang.Exception`**.           |

<br />

<h3>3.3. Exce√ß√µes Integradas</h3>



As **exce√ß√µes integradas** s√£o aquelas fornecidas pela pr√≥pria linguagem Java, dispon√≠veis principalmente nos pacotes `java.lang.Error` e `java.lang.Exception`. Elas representam erros comuns que podem ocorrer durante a execu√ß√£o de um programa e cobrem desde problemas de l√≥gica at√© falhas de entrada e sa√≠da.

Essas exce√ß√µes s√£o divididas em duas grandes categorias: **Checked Exceptions** (verificadas) e **Unchecked Exceptions** (n√£o verificadas). A seguir, apresentamos as mais utilizadas em cada categoria.

<br />

<h4>3.3.1. Exce√ß√µes do tipo Checked</h4>



Essas exce√ß√µes s√£o **verificadas em tempo de compila√ß√£o**, e o compilador exige que sejam tratadas com `try-catch` ou declaradas com `throws`. Elas geralmente representam situa√ß√µes externas ao programa, como falhas de I/O ou recursos ausentes.

| Exce√ß√£o                    | Descri√ß√£o                                                    | Exemplo                                                      |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ClassNotFoundException** | Lan√ßada quando a aplica√ß√£o tenta carregar uma classe que n√£o foi encontrada no classpath. | Ao tentar carregar dinamicamente uma classe inexistente usando `Class.forName()`. |
| **FileNotFoundException**  | Ocorre quando um arquivo n√£o pode ser encontrado ou acessado. | Ao tentar abrir um arquivo que n√£o existe com `FileReader`.  |
| **NoSuchFieldException**   | Lan√ßada quando um campo (atributo) n√£o √© encontrado em determinada classe. | Ao usar reflex√£o (`reflection`) para acessar um atributo inexistente. |
| **NoSuchMethodException**  | Ocorre quando um m√©todo espec√≠fico n√£o √© encontrado em uma classe. | Ao tentar invocar um m√©todo que n√£o foi definido via reflex√£o. |

<br />

<h4>3.3.2. Exce√ß√µes do tipo Unchecked</h4>



Essas exce√ß√µes s√£o **n√£o verificadas** e ocorrem geralmente por erros de programa√ß√£o ou l√≥gica. O compilador n√£o exige seu tratamento, mas √© poss√≠vel (e recomendado) trat√°-las em tempo de execu√ß√£o quando necess√°rio.

| Exce√ß√£o                            | Descri√ß√£o                                                    | Exemplo                                                      |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ArithmeticException**            | Lan√ßada quando ocorre erro em opera√ß√µes matem√°ticas, como divis√£o por zero. | Dividir um n√∫mero inteiro por zero.                          |
| **ArrayIndexOutOfBoundsException** | Lan√ßada ao tentar acessar um √≠ndice inv√°lido em um array.    | Acessar o √≠ndice 10 em um array de tamanho 5.                |
| **NullPointerException**           | Lan√ßada ao acessar m√©todos ou atributos de uma refer√™ncia nula. | Tentar acessar `obj.getNome()` onde `obj` √© `null`.          |
| **NumberFormatException**          | Lan√ßada ao tentar converter uma `String` inv√°lida para n√∫mero. | Usar `Integer.parseInt("abc")`.                              |
| **IllegalArgumentException**       | Lan√ßada quando um argumento inv√°lido √© passado para um m√©todo. | Passar um n√∫mero negativo para um m√©todo que espera apenas positivos. |
| **IllegalStateException**          | Lan√ßada quando o m√©todo √© chamado em um estado inapropriado do objeto. | Chamar `next()` em um `Iterator` j√° esgotado.                |

<br />


<h2>4. Throw</h2>



A palavra-chave **`throw`** √© utilizada para **lan√ßar uma exce√ß√£o em qualquer ponto do c√≥digo**, transferindo o controle do fluxo de execu√ß√£o para o m√©todo chamador. Diferente da cl√°usula `throws`, o uso de `throw` **n√£o exige que a exce√ß√£o seja tratada no local em que √© lan√ßada**, mas sim que o tratamento ocorra em algum n√≠vel da pilha de chamadas.

A instru√ß√£o `throw` pode ser utilizada tanto para **exce√ß√µes verificadas (checked)** quanto **n√£o verificadas (unchecked)**. Seu uso √© comum em situa√ß√µes em que se deseja **lan√ßar exce√ß√µes personalizadas**, criadas pela pessoa desenvolvedora, quando os tipos de exce√ß√£o integrados do Java n√£o representam adequadamente o erro ocorrido.

Abaixo, veja um exemplo de uso da cl√°usula `throw` com uma exce√ß√£o integrada:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Throw

No exemplo abaixo, vamos construir uma aplica√ß√£o para checar se uma pessoa est√° apta a dirigir:

```java
package exceptions;

import java.util.Scanner;

public class Exemplo03 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int idade;
		
		System.out.println("\nDigite uma idade: ");
		idade = leia.nextInt();
		
		validarIdade(idade);
		
		leia.close();
		
	}

	public static void validarIdade(int idade){
		
		if(idade < 18) {
			throw new ArithmeticException("A Pessoa n√£o pode dirigir!!");
		}else {
			System.out.println("A Pessoa pode dirigir!!");
		}
	
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/qRqPzbl.png" title="source: imgur.com" /></div>

Observe que a exce√ß√£o **`ArithmeticException`** foi lan√ßada dentro do m√©todo **`validarIdade()`**, exibindo a mensagem padr√£o do erro, e o programa foi finalizado imediatamente.

Ao executar a instru√ß√£o **`throw`**, o programa passa a buscar, na pilha de execu√ß√£o, algum bloco **`try`** que contenha uma cl√°usula **`catch`** compat√≠vel com o tipo da exce√ß√£o lan√ßada. Se encontrar um bloco correspondente, o controle do fluxo ser√° transferido para esse bloco, permitindo o tratamento da exce√ß√£o. Caso contr√°rio, o programa ser√° encerrado de forma abrupta.

Vamos, a seguir, atualizar o c√≥digo inserindo um bloco **`try...catch`** para tratar a exce√ß√£o de forma adequada.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Throw com Try-Catch

```java
package exceptions;

import java.util.Scanner;

public class Exemplo04{

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int idade;
		boolean continua = true;
		
		do {
		
			try {
			
				System.out.println("\nDigite uma idade: ");
				idade = leia.nextInt();
					
				validarIdade(idade);
				
				continua = false;
				
			}catch(ArithmeticException e){
				System.err.println("\nDigite um n√∫mero inteiro maior ou igual a 18!");
			}
			
		}while (continua);
		
		leia.close();
		
	}

	public static void validarIdade(int idade){
		
		if(idade < 18) {
			throw new ArithmeticException("A Pessoa n√£o pode dirigir!!");
		}else {
			System.out.println("A Pessoa pode dirigir!!");
		}
	
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/Jv8aPGN.png" title="source: imgur.com" /></div>

Observe que a exce√ß√£o **`ArithmeticException`** foi lan√ßada dentro do m√©todo **`validarIdade()`**, mas, desta vez, foi exibida uma **mensagem personalizada**: *"Digite um n√∫mero inteiro maior ou igual a 18!"*.

Al√©m disso, o **controle do tratamento do erro foi transferido para o bloco `try...catch`**, que orienta o usu√°rio a digitar uma nova idade v√°lida (maior ou igual a 18).

Como foi implementado um la√ßo de repeti√ß√£o **`do...while`**, esse processo ser√° repetido at√© que o usu√°rio informe corretamente uma idade igual ou superior a 18.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html" target="_blank"><b>Documenta√ß√£o: Classe Throwable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank"><b>Documenta√ß√£o: Classe Exception</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html" target="_blank"><b>Documenta√ß√£o: Throw</b></a></div>

<br />

<h2>4. Throws</h2>



A cl√°usula **`throws`** √© utilizada para **informar que um m√©todo pode lan√ßar uma ou mais exce√ß√µes** durante a sua execu√ß√£o. Ela aparece **na assinatura do m√©todo**, logo **ap√≥s os par√™nteses de par√¢metros** e **antes da abertura do corpo** do m√©todo.

Pense na cl√°usula `throws` como um **aviso ou promessa feita pelo m√©todo**: ele est√° dizendo que, ao ser executado, pode ocorrer um erro (exce√ß√£o), e que quem chamou esse m√©todo deve estar preparado para tratar esse erro.

A sintaxe permite listar **uma ou mais exce√ß√µes**, separadas por v√≠rgulas, que podem ser lan√ßadas tanto por instru√ß√µes escritas dentro do corpo do m√©todo quanto por m√©todos chamados dentro dele.

**Sintaxe**

```java
public class TestaExcecao {

    public static void main(String[] args) throws Exception1, Exception2 {
        // c√≥digo que pode gerar Exception1 ou Exception2
    }

}
```

No exemplo acima, a cl√°usula **`throws`** est√° dizendo que o m√©todo `main` **pode lan√ßar duas exce√ß√µes**: `Exception1` e `Exception2`. Isso significa que qualquer classe que chamar esse m√©todo dever√°:

- **Tratar essas exce√ß√µes com um bloco `try-catch`**, ou
- **Propagar essas exce√ß√µes adiante**, utilizando tamb√©m `throws` na assinatura do m√©todo chamador.

Essa √© a principal diferen√ßa entre **`throw`** e **`throws`**:

- **`throw`**: √© usado **dentro do corpo do m√©todo**, para **lan√ßar uma exce√ß√£o naquele ponto espec√≠fico**.
- **`throws`**: √© usado **na assinatura do m√©todo**, para **declarar que aquele m√©todo pode lan√ßar exce√ß√µes** durante sua execu√ß√£o.

Outro ponto importante √© que, ao usar `throws`, estamos falando principalmente de **exce√ß√µes verificadas (checked exceptions)** ‚Äî ou seja, aquelas que o compilador exige que sejam tratadas ou propagadas. Para **exce√ß√µes n√£o verificadas (unchecked exceptions)**, o uso de `throws` n√£o √© obrigat√≥rio, embora ainda possa ser utilizado para fins de documenta√ß√£o.

<br />

## üÜö Tabela Comparativa: `throw` vs `throws`

| throw                                  | throws                                    |
| -------------------------------------- | ----------------------------------------- |
| Lan√ßa uma exce√ß√£o em tempo de execu√ß√£o | Declara que o m√©todo pode lan√ßar exce√ß√µes |
| Usado dentro do corpo do m√©todo        | Usado na assinatura do m√©todo             |
| Exige uma inst√¢ncia de Exception       | Lista as exce√ß√µes separadas por v√≠rgula   |
| Pode lan√ßar checked ou unchecked       | Obrigat√≥rio para checked exceptions       |

<br />

<h3>4.1. Exce√ß√µes Personalizadas</h3>



Em Java, **exce√ß√µes personalizadas** s√£o utilizadas quando os tipos de erro fornecidos pela linguagem n√£o representam bem uma situa√ß√£o espec√≠fica da sua aplica√ß√£o. Elas permitem criar mensagens mais claras, controlar melhor o fluxo de execu√ß√£o e tornar o c√≥digo mais expressivo. 

Para criar uma exce√ß√£o personalizada, basta criar uma nova classe que **estenda `Exception`** (para exce√ß√µes verificadas) ou `RuntimeException` (para n√£o verificadas), podendo incluir construtores e mensagens espec√≠ficas.

O uso de exce√ß√µes personalizadas melhora a legibilidade e o tratamento de erros, permitindo que diferentes situa√ß√µes de falha sejam tratadas de forma distinta. Por exemplo, em um sistema de e-commerce, pode-se criar exce√ß√µes como `PagamentoException`, `EstoqueInsuficienteException` ou `CarrinhoVazioException` para representar erros espec√≠ficos do dom√≠nio da aplica√ß√£o, oferecendo ao usu√°rio e ao desenvolvedor mensagens mais informativas e precisas.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Throws e Exce√ß√µes Personalizadas



Em um sistema de e-commerce, √© comum validar se o cliente possui saldo suficiente antes de concluir uma compra. Caso o valor da compra seja superior ao saldo dispon√≠vel, o sistema deve impedir o pagamento e informar o motivo ao cliente, de forma clara e controlada.

Neste exemplo, vamos implementar essa regra utilizando uma **exce√ß√£o personalizada**, chamada `PagamentoException`. Essa exce√ß√£o ser√° **lan√ßada com o comando `throw`** dentro do m√©todo respons√°vel pelo pagamento, e **declarada na assinatura com a cl√°usula `throws`**, indicando que o m√©todo pode gerar esse tipo de erro.

Al√©m disso, o erro ser√° **tratado com um bloco `try...catch`**, permitindo exibir uma mensagem amig√°vel ao cliente, sem encerrar o programa abruptamente.

A seguir, veremos a implementa√ß√£o passo a passo:

<br />

**Classe PagamentoException**

```java
package exceptions;

public class PagamentoException extends Exception {

	private static final long serialVersionUID = 1L;
	
	public PagamentoException() { }

	public PagamentoException(String mensagem) {
		super(mensagem);
	}
}
```

A classe **`PagamentoException`** √© uma **exce√ß√£o personalizada** criada para representar erros espec√≠ficos relacionados a falhas no processo de pagamento, como saldo insuficiente. Ela foi definida como uma **subclasse da classe `Exception`**, ou seja, herda todas as caracter√≠sticas de uma exce√ß√£o verificada (checked exception) em Java.

Note que dentro da classe, foi declarado o campo: `private static final long serialVersionUID = 1L;`. Esse atributo √© um **identificador √∫nico da vers√£o da classe** e est√° relacionado ao processo de **serializa√ß√£o e desserializa√ß√£o** de objetos em Java.

> ### üîÑ O que √© Serializa√ß√£o?
>
> **Serializa√ß√£o** √© o processo de transformar um objeto em uma **sequ√™ncia de bytes**, permitindo que ele seja salvo em disco, transmitido pela rede ou armazenado para uso posterior. Para que uma classe possa ser serializada, ela deve implementar a interface `java.io.Serializable`.
>
> Quando um objeto √© serializado, o valor do `serialVersionUID` √© inclu√≠do junto com os dados. Durante a **desserializa√ß√£o** (o processo inverso), a JVM compara o `serialVersionUID` do objeto com o da classe carregada. Se os valores n√£o coincidirem, ser√° lan√ßada uma exce√ß√£o do tipo **`InvalidClassException`**, indicando incompatibilidade entre as vers√µes.
>
> #### üí° Compara√ß√£o simples:
>
> Imagine que a serializa√ß√£o √© como **tirar uma foto digital de um objeto** para guard√°-la ou envi√°-la a algu√©m. Essa "foto" captura todas as informa√ß√µes do estado atual do objeto. O `serialVersionUID` funciona como uma **etiqueta com a data e vers√£o** da foto. Se, ao tentar usar essa foto para recriar o objeto, a etiqueta indicar uma vers√£o diferente da atual, a reconstru√ß√£o falha ‚Äî √© como tentar montar um quebra-cabe√ßa com pe√ßas que j√° foram alteradas.
>
> ### Em resumo:
>
> - **Serializa√ß√£o** = Tira uma foto do objeto e transforma isso em dados (bytes).
>- **Desserializa√ß√£o** = Usa a foto (dados) para recriar o objeto.
> - **serialVersionUID** = O n√∫mero de s√©rie da foto, garantindo que a foto √© compat√≠vel com a vers√£o do objeto.

<br />

A classe `PagamentoException` possui dois **m√©todos construtores**, herdados e adaptados da classe `Exception`:

- Um **construtor padr√£o (sem par√¢metros)**: permite lan√ßar a exce√ß√£o sem definir uma mensagem espec√≠fica.
- Um **construtor com o par√¢metro `String mensagem`**: permite lan√ßar a exce√ß√£o com uma **mensagem personalizada**, tornando o erro mais descritivo para o usu√°rio ou para logs de sistema.

A classe `Exception` ainda possui outros construtores com par√¢metros adicionais, que podem ser utilizados conforme a necessidade da aplica√ß√£o.

<br />

**Classe Cliente**

```java
package exceptions;

public class Cliente {

    private String nome;
    private float saldo;

    public Cliente(String nome, float saldo) {
        this.nome = nome;
        this.saldo = saldo;
    }

    public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public float getSaldo() {
		return saldo;
	}

	public void setSaldo(float saldo) {
		this.saldo = saldo;
	}

    public void realizarPagamento(float valorCompra) throws PagamentoException {
        if (valorCompra > saldo) {
            throw new PagamentoException("Saldo insuficiente para concluir a compra.");
        }
        saldo -= valorCompra;
        System.out.println("Pagamento aprovado! Obrigado pela compra, " + nome + ".");
        System.out.println("Saldo restante: R$ " + saldo);
    }
    
    public void visualizar() {
    	System.out.println("\n=========================================");
    	System.out.println("Dados do Cliente");
    	System.out.println("=========================================");
    	System.out.printf("Nome do cliente: %s%n", this.nome);
    	System.out.printf("Saldo do cliente: R$ %.2f%n", this.saldo);
    }
}
```

A classe **`Cliente`** representa um cliente de e-commerce, contendo os atributos `nome` e `saldo`, al√©m de m√©todos para acessar e modificar esses dados.

Observe o m√©todo **`realizarPagamento(float valorCompra)`**, respons√°vel por processar uma compra. Ele verifica se o saldo do cliente √© suficiente para cobrir o valor informado. Caso n√£o seja, **lan√ßa uma exce√ß√£o personalizada do tipo `PagamentoException`** com uma mensagem clara. Se o pagamento for aprovado, o valor √© descontado do saldo, e uma mensagem de confirma√ß√£o √© exibida.

Nesse m√©todo, √© utilizada a combina√ß√£o das palavras-chave **`throws`** e **`throw`**. A cl√°usula **`throws`**, presente na assinatura do m√©todo, informa que ele pode lan√ßar uma exce√ß√£o do tipo `PagamentoException`. J√° o comando **`throw`** √© utilizado dentro do m√©todo para **lan√ßar efetivamente** a exce√ß√£o, caso o valor da compra ultrapasse o saldo dispon√≠vel.

Esse m√©todo ilustra bem o uso de **exce√ß√µes personalizadas no controle de regras de neg√≥cio**, promovendo clareza, seguran√ßa e maior controle sobre o fluxo de execu√ß√£o no processo de pagamento.

<br />

**Classe Exemplo05 (classe pincipal)**

```java
package exceptions;

public class Exemplo05 {

    public static void main(String[] args) {
    	
    	Cliente cliente = new Cliente("Maria da Silva", 200.00f);
    	
    	cliente.visualizar();

        float valorCompra = 350.00f;
        
        System.out.printf("\nValor da compra: R$ %.2f%n", valorCompra);

        try {
            cliente.realizarPagamento(valorCompra);
        } catch (PagamentoException e) {
            System.err.println("\nErro no pagamento: " + e.getMessage());
            System.err.println("\nPor favor, revise o valor da compra.");
        }
        
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

<div align="center"><img src="https://i.imgur.com/V7EiHjy.png" title="source: imgur.com" /></div>

No **Exemplo05**, foi criado um objeto da classe `Cliente` com saldo inicial de **R$ 200,00**. Em seguida, foi simulada uma compra no valor de **R$ 350,00**.

O trecho dentro do bloco **`try`** tenta realizar o pagamento. Como o valor da compra excede o saldo dispon√≠vel, o m√©todo **`realizarPagamento`** lan√ßa uma exce√ß√£o do tipo **`PagamentoException`**, como vemos na imagem acima. Essa exce√ß√£o √© ent√£o capturada pelo bloco **`catch`**, que trata o erro exibindo uma mensagem personalizada ao usu√°rio, sem interromper a execu√ß√£o do programa.

Esse uso do `try-catch` demonstra como **exce√ß√µes personalizadas ajudam a controlar regras de neg√≥cio** e melhorar a experi√™ncia do usu√°rio em casos de erro.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html" target="_blank"><b>Documenta√ß√£o: Classe Throwable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank"><b>Documenta√ß√£o: Classe Exception</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" target="_blank"><b>Documenta√ß√£o: Classe RuntimeException</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html" target="_blank"><b>Documenta√ß√£o: Throw</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html" target="_blank"><b>Documenta√ß√£o: Throws</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="_blank"><b>Documenta√ß√£o: Interface Serializable</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="4%"/> <a href="https://www.oracle.com/br/technical-resources/articles/java/serialversionuid.html" target="_blank"><b>Documenta√ß√£o: <i>SerialVersionUID</i></b></a></div>

<br />

<h2>5. Por que devemos tratar as Exce√ß√µes?</h2>



O tratamento de exce√ß√µes √© fundamental para garantir que a aplica√ß√£o **reaja de forma controlada a erros inesperados**, evitando falhas cr√≠ticas que possam interromper sua execu√ß√£o. Sem esse cuidado, qualquer erro ‚Äî por menor que seja ‚Äî pode causar o encerramento abrupto do sistema, resultando em perda de dados, frustra√ß√£o do usu√°rio e preju√≠zos √† confiabilidade do software.

**Exemplo do dia a dia:**

Imagine que voc√™ est√° utilizando um aplicativo banc√°rio e, ao tentar consultar o saldo, a conex√£o com a internet falha. Sem o tratamento adequado, o aplicativo poderia simplesmente **fechar sem explica√ß√µes**. Com o uso de exce√ß√µes, √© poss√≠vel exibir uma **mensagem amig√°vel**, como: ‚Äú*N√£o foi poss√≠vel carregar os dados. Verifique sua conex√£o com a internet.*‚Äù

<br />

<h3>5.1. Benef√≠cios do tratamento de exce√ß√µes</h3>



- **Evita que o programa seja interrompido** ao encontrar erros durante a execu√ß√£o.
- **Proporciona mensagens de erro compreens√≠veis e orientativas** para o usu√°rio final.
- **Organiza melhor o c√≥digo**, separando a l√≥gica principal do tratamento de erros.
- **Facilita o diagn√≥stico de falhas**, permitindo o registro detalhado dos erros por meio de logs.
- **Torna o software mais robusto e profissional**, especialmente em sistemas cr√≠ticos como bancos, hospitais e com√©rcios eletr√¥nicos.

**Tratar exce√ß√µes √© como implementar um plano de conting√™ncia dentro do seu c√≥digo:** Ele garante que, mesmo diante de problemas, o sistema mantenha sua estabilidade e ofere√ßa uma resposta clara e segura ao usu√°rio.

<br />

------

## üîë**Pontos chave:**

1. **Exce√ß√µes em Java** s√£o objetos que representam erros ou condi√ß√µes excepcionais que podem ocorrer durante a execu√ß√£o do programa. Elas permitem capturar e tratar falhas de forma controlada.

2. O bloco **try/catch/finally** √© a estrutura utilizada para capturar e tratar exce√ß√µes em Java:

   - **try**: bloco monitorado.

   - **catch**: trata a exce√ß√£o lan√ßada.

   - **finally**: executa sempre, independentemente da ocorr√™ncia de erro.

3. A **cl√°usula throws** declara que um m√©todo pode lan√ßar uma ou mais exce√ß√µes. √â obrigat√≥ria para **checked exceptions** e opcional para **unchecked exceptions**.
4. A **cl√°usula throw** √© utilizada dentro do m√©todo para lan√ßar uma exce√ß√£o em tempo de execu√ß√£o, transferindo o fluxo de controle para o tratamento apropriado (catch ou propaga√ß√£o).
5. √â poss√≠vel criar **exce√ß√µes personalizadas** (custom exceptions) que herdam de Exception ou RuntimeException, para representar erros espec√≠ficos do dom√≠nio da aplica√ß√£o.
6. O tratamento de exce√ß√µes torna o c√≥digo **mais robusto, seguro e amig√°vel ao usu√°rio**, prevenindo encerramentos inesperados e permitindo uma recupera√ß√£o controlada dos erros.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
