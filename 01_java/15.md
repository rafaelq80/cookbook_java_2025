<h1>Programa√ß√£o Orientada a Objetos - Parte 02</h1>
<br />
<h2>Heran√ßa e Polimorfismo</h2>



Nos t√≥picos anteriores, estudamos os principais fundamentos da Programa√ß√£o Orientada a Objetos (POO), incluindo **Classes**, **Objetos**, **M√©todos**, **Atributos** e **Encapsulamento**.

Agora, avan√ßaremos no conte√∫do abordando mais dois pilares essenciais da POO: **Heran√ßa** e **Polimorfismo**.

Antes de explorarmos esses conceitos em detalhes, √© importante compreender o que s√£o os **relacionamentos entre classes**, pois eles servem como base para entender como a heran√ßa e o polimorfismo se aplicam na pr√°tica.

<br />

<h2>1. Relacionamento entre Classes</h2>



Na Programa√ß√£o Orientada a Objetos, os **relacionamentos entre classes** definem como diferentes classes se conectam, interagem e colaboram dentro de um sistema. Esses relacionamentos s√£o fundamentais para construir aplica√ß√µes bem estruturadas, reutiliz√°veis e de f√°cil manuten√ß√£o.

No exemplo abaixo, temos uma rela√ß√£o entre as classes `Veiculo` e `Carro`, onde **Carro √© um tipo de Ve√≠culo**, como ilustrado no diagrama:

```mermaid
classDiagram
Veiculo <|-- Carro: √© um tipo de
```

No pr√≥ximo exemplo, temos as classes `Carro`, `Motor` e `Roda`. Um **Carro √© composto por um Motor e por Rodas**, ou seja, **essas partes n√£o existem independentemente do Carro**, como ilustrado no diagrama:

```mermaid
classDiagram
Carro *-- Motor : √© composto por
Carro *-- Roda : √© composto por
```

<br />

<h3>1.1. Por que os Relacionamentos s√£o Importantes?</h3>



Ao projetarmos um sistema orientado a objetos, **compreender os tipos de relacionamentos entre classes √© essencial** para garantir um c√≥digo mais organizado, reutiliz√°vel e de f√°cil manuten√ß√£o. Veja algumas raz√µes:

- **Reutiliza√ß√£o de c√≥digo:** Se v√°rias classes compartilham comportamentos ou atributos em comum, podemos centraliz√°-los em uma **superclasse** e utilizar o mecanismo de **heran√ßa** para evitar duplica√ß√£o de c√≥digo.
- **Divis√£o do trabalho em equipe:** Em casos onde as classes **n√£o possuem depend√™ncias diretas**, √© poss√≠vel distribu√≠-las entre diferentes desenvolvedores, favorecendo o desenvolvimento simult√¢neo sem bloqueios.
- **Melhor modelagem do dom√≠nio:** Os relacionamentos nos ajudam a representar de forma mais fiel o mundo real dentro do c√≥digo, facilitando a comunica√ß√£o entre os objetos e a manuten√ß√£o do sistema.

<br />

<h3>1.2. Tipos de relacionamento entre classes</h3>



Existem tr√™s tipos de relacionamentos mais comuns entre classes em Java:

- **Heran√ßa ("Is-A")** ‚Äì representa o relacionamento ‚Äú√© um‚Äù, onde uma classe herda propriedades e comportamentos de outra;
- **Depend√™ncia ("Use-A")** ‚Äì indica que uma classe utiliza ou depende de outra para realizar alguma fun√ß√£o;
- **Associa√ß√£o ("Has-A")** ‚Äì representa o relacionamento ‚Äútem um‚Äù, onde uma classe possui uma refer√™ncia para outra.

Existem ainda dois tipos espec√≠ficos de relacionamentos por associa√ß√£o:

- **Agrega√ß√£o** ‚Äì uma rela√ß√£o mais fraca, onde os objetos envolvidos podem existir independentemente;
- **Composi√ß√£o** ‚Äì uma rela√ß√£o forte, em que a exist√™ncia dos objetos depende uns dos outros.

Confira o resumo visual dos tipos de relacionamento no organograma abaixo:

<div align="center"><img src="https://i.imgur.com/UvL4z36.png" title="source: imgur.com" /></div>

<br />

<h4>1.2.1. Rela√ß√£o de Heran√ßa</h4>



A **heran√ßa** estabelece um relacionamento entre uma classe mais gen√©rica e abstrata, chamada **superclasse**, e uma classe mais especializada, conhecida como **subclasse**.

Em outras palavras, a heran√ßa define uma rela√ß√£o onde uma classe **"estende"** outra, caracterizando um v√≠nculo do tipo **√â-Um** (*Is-A*).

No contexto de e-commerce, por exemplo, podemos ter a superclasse `Produto` e subclasses como `Eletronico` e `Vestuario`, onde cada subclasse herda atributos e comportamentos comuns da superclasse `Produto` e adiciona suas especificidades.

```mermaid
classDiagram
Produto <|-- Eletronico : √â um
Produto <|-- Vestuario : √â um
```

<br />

<h4>1.2.2. Rela√ß√£o de Depend√™ncia</h4>



A **depend√™ncia direta** (ou simplesmente *depend√™ncia*) em programa√ß√£o orientada a objetos ocorre quando uma classe utiliza outra temporariamente, geralmente por meio de par√¢metros de m√©todos, cria√ß√£o de objetos locais ou chamadas diretas, **sem manter uma refer√™ncia permanente (atributo)**.

### Caracter√≠sticas da depend√™ncia direta:

- A depend√™ncia ocorre quando **um m√©todo de uma classe utiliza temporariamente um objeto de outra classe para realizar uma tarefa espec√≠fica**.
- Esse uso √© **transit√≥rio**, ou seja, o objeto n√£o √© armazenado como atributo da classe, sendo usado apenas no escopo do m√©todo.
- Indica que uma classe **depende da exist√™ncia da outra para executar uma a√ß√£o**, mas n√£o mant√©m um relacionamento fixo ou duradouro.
- Esse √© o relacionamento **mais fraco e tempor√°rio** entre classes, diferente da associa√ß√£o, agrega√ß√£o ou composi√ß√£o.

```mermaid
classDiagram
    Pedido ..> Pagamento : usa

    class Pedido {
        +processarPagamento(pagamento: Pagamento) void
    }

    class Pagamento {
        -metodo: String
        -valor: double
        +pagar() void
    }

```

No diagrama acima, a classe `Pedido` **usa** a classe `Pagamento` apenas dentro do m√©todo `processarPagamento`, sem manter uma refer√™ncia permanente (n√£o h√° atributo `Pagamento` na classe `Pedido`).

<br />

<h4>1.2.3. Relacionamento por Associa√ß√£o</h4>



A **associa√ß√£o** √© um dos principais tipos de relacionamento entre classes em programa√ß√£o orientada a objetos. Representa o v√≠nculo onde uma classe utiliza ou conhece outra, sendo popularmente chamada de rela√ß√£o "**Tem-um**" (*Has-A*).

Quando uma classe possui um atributo que √© uma inst√¢ncia de outra classe, dizemos que existe uma **associa√ß√£o** entre elas. Esse v√≠nculo pode ser unidirecional (uma classe conhece a outra) ou bidirecional (ambas conhecem uma √† outra).

```mermaid
classDiagram
Cliente --> Pedido : tem
```

No diagrama acima, temos a classe `Cliente` associada √† classe `Pedido`. Isso significa que:

- Um **Cliente** pode estar relacionado a **v√°rios Pedidos**.
- Cada **Pedido** est√° associado a um **√∫nico Cliente**.

Essa rela√ß√£o √© t√≠pica em sistemas de e-commerce ou gest√£o de vendas, onde **um cliente pode realizar m√∫ltiplas compras ao longo do tempo**, e cada pedido precisa estar vinculado a quem o realizou.

<br />

### Cardinalidade na Associa√ß√£o

A **cardinalidade** define quantos objetos de uma classe podem estar relacionados com objetos de outra classe. Essa informa√ß√£o √© essencial para entender a natureza do v√≠nculo entre os objetos.

As principais cardinalidades s√£o:

- **Um para Um (1:1):** Um objeto de uma classe est√° associado a no m√°ximo um objeto da outra.
- **Um para Muitos (1:N) / Muitos para Um (N:1):** Um objeto est√° relacionado a v√°rios objetos da outra classe, ou vice-versa.
- **Muitos para Muitos (N:N):** V√°rios objetos de uma classe se relacionam com v√°rios objetos da outra.

**Exemplo pr√°tico:**

```mermaid
classDiagram
Cliente "1" --> "*" Pedido : tem
```

- Um **Cliente** pode **realizar v√°rios Pedidos** (1:N).
- Cada **Pedido** pertence a **um √∫nico Cliente** (N:1).

Os conceitos de **relacionamento por associa√ß√£o** e **cardinalidade** s√£o fundamentais tamb√©m no **mapeamento de classes para tabelas em bancos de dados relacionais**, que estudaremos no Bloco 02 - Desenvolvimento Backend. 

Ao projetar um sistema orientado a objetos que se conecta a um banco de dados relacional (como MySQL, SQL Server, PostgreSQL ou Oracle), esses relacionamentos ajudam a definir **chaves prim√°rias e estrangeiras** (*primary keys e foreign keys*) e **restri√ß√µes de integridade** entre as tabelas.

<br />

<h4>1.2.4 - Relacionamento de Associa√ß√£o - Agrega√ß√£o</h4>



A **agrega√ß√£o** √© um tipo especial de associa√ß√£o que representa uma rela√ß√£o do tipo "todo-parte", onde as partes podem existir de forma independente do todo. √â conhecida como uma **associa√ß√£o fraca**, pois o ciclo de vida dos objetos n√£o est√° vinculado.

No diagrama UML, a agrega√ß√£o √© representada por um **losango branco** na extremidade do objeto "todo".

```mermaid
classDiagram
Carrinho o-- Produto : cont√©m
```

No exemplo acima:

- Um objeto `Carrinho` **cont√©m** v√°rios objetos `Produto`.
- Mesmo que o `Carrinho` seja exclu√≠do, os `Produtos` continuam existindo (por exemplo, ainda podem estar dispon√≠veis no estoque).

**Caracter√≠sticas da agrega√ß√£o:**

- O objeto **parte** (`Produto`) **n√£o depende** do objeto **todo** (`Carrinho`) para existir.
- O objeto **todo** **mant√©m a refer√™ncia** √†s partes.
- A destrui√ß√£o do todo **n√£o impacta** as partes.

<br />

<h4>1.2.5 - Relacionamento de Associa√ß√£o - Composi√ß√£o</h4>



A **composi√ß√£o** √© uma forma mais forte de associa√ß√£o, em que os objetos "parte" **dependem totalmente** do objeto "todo". √â usada quando o ciclo de vida das partes est√° diretamente ligado ao ciclo de vida do todo.

Na nota√ß√£o UML, √© representada por um **losango preto** na extremidade do objeto agregador.

```mermaid
classDiagram
Pedido *-- ItemPedido : cont√©m
```

No exemplo acima:

- Um objeto `Pedido` **√© composto** por v√°rios `Itens do Pedido`.
- Os `ItemPedido` **n√£o fazem sentido existir** sem estarem ligados a um `Pedido` espec√≠fico.
- Se o `Pedido` for exclu√≠do, todos os `Itens do Pedido` tamb√©m devem ser destru√≠dos.

Embora o Java n√£o tenha uma palavra-chave espec√≠fica para indicar composi√ß√£o, essa rela√ß√£o pode ser representada pela forma como as classes s√£o estruturadas e instanciadas.

**Caracter√≠sticas da Composi√ß√£o:**

- O objeto parte (`ItemPedido`) **n√£o existe sem** o objeto todo (`Pedido`).
- O ciclo de vida das partes √© **controlado** pelo todo.
- Ao destruir o objeto todo, **todas as partes tamb√©m s√£o destru√≠das**.

<br />

> [!IMPORTANT]
>
> Dentro do contexto de um e-commerce, embora `Carrinho` e `Pedido` manipulem produtos, √© fundamental entender que **representam conceitos distintos**.
>
> - O **Carrinho** √© utilizado durante o processo de compra, enquanto o cliente ainda est√° escolhendo os produtos. Ele pode ser modificado a qualquer momento antes da finaliza√ß√£o.
> - O **Pedido**, por outro lado, **representa a compra finalizada**, com todos os dados confirmados e prontos para o processamento (como pagamento e entrega).
>
> Essa distin√ß√£o tamb√©m influencia no tipo de relacionamento: enquanto o carrinho possui produtos de forma independente (agrega√ß√£o), o pedido **comp√µe** os itens de forma definitiva e dependente (composi√ß√£o).

<br />

Compreender os diferentes tipos de associa√ß√£o (simples, agrega√ß√£o e composi√ß√£o) √© essencial para modelar bem os relacionamentos entre objetos na programa√ß√£o orientada a objetos. Saber identificar se os objetos devem ou n√£o depender uns dos outros ajuda a construir sistemas mais **flex√≠veis**, **coerentes** e **f√°ceis de manter**.

Esses conceitos est√£o diretamente alinhados √†s diretrizes de modelagem orientada a objetos utilizadas na UML (Unified Modeling Language) e amplamente aplicados em linguagens como Java, C#, Python, entre outras.

<br />

<h3>1.3. Como decidir que tipo de relacionamento precisamos?</h3>



Na modelagem orientada a objetos, √© essencial saber **qual tipo de relacionamento** utilizar entre as classes. Os dois mais comuns e importantes no dia a dia do desenvolvimento s√£o:

- O relacionamento **‚Äú√â-um‚Äù** (Heran√ßa ou Generaliza√ß√£o);
- O relacionamento **‚ÄúTem-um‚Äù** (Associa√ß√£o).

A melhor forma de decidir qual aplicar √© **observar a forma como descrevemos o problema no mundo real**, com foco na sem√¢ntica da frase.

<br />

### 1. Heran√ßa: Quando usar o relacionamento ‚Äú√â-um‚Äù



Se o seu problema puder ser descrito com a frase:

> **‚ÄúO objeto A √© um tipo do objeto B‚Äù**,

ent√£o estamos diante de um caso de **heran√ßa**, tamb√©m conhecido como **rela√ß√£o de generaliza√ß√£o/especializa√ß√£o**.

**Exemplo:**

> ‚ÄúUm **Cachorro** √© um **Pet**.‚Äù

Essa frase faz sentido l√≥gico e estrutural, indicando que **Cachorro √© uma especializa√ß√£o de Pet**, ou seja, **herda atributos e comportamentos** da classe gen√©rica `Pet`.

Neste caso, usamos heran√ßa para criar uma **superclasse** chamada `Pet` e uma **subclasse** chamada `Cachorro`, que estende as caracter√≠sticas da superclasse.

```mermaid
classDiagram
Pet <|-- Cachorro : √â um
```

<br />

### 2. Associa√ß√£o: Quando usar o relacionamento ‚ÄúTem-um‚Äù



Agora, se o seu problema puder ser descrito com a frase:

> **‚ÄúO objeto A tem um objeto B‚Äù**,

ent√£o devemos utilizar o relacionamento de **associa√ß√£o**.

**Exemplo:**

> ‚ÄúUm **Pet** tem uma **Ra√ßa**.‚Äù

Essa frase indica que existe uma **depend√™ncia ou v√≠nculo entre os objetos**, mas sem heran√ßa. Ou seja, `Pet` mant√©m uma refer√™ncia para um objeto do tipo `Raca`, mas eles s√£o classes distintas e complementares.

N√£o faria sentido dizer:

> ‚ÄúUm Pet √© uma Ra√ßa‚Äù ‚Äî isso seria semanticamente incorreto.

```mermaid
classDiagram
Raca <-- Pet : Tem uma
```

<br />

## üÜö Tabela Comparativa: Heran√ßa vs Depend√™ncia vs Associa√ß√£o

| Tipo            | Representa√ß√£o | Significado | Exemplo pr√°tico                    |
| --------------- | ------------- | ----------- | ---------------------------------- |
| **Heran√ßa**     | "Is-A"        | √â um        | Um `Carro` **√© um** `Ve√≠culo`      |
| **Depend√™ncia** | "Use-A"       | Usa um      | Um `Pedido` **usa** um `Pagamento` |
| **Associa√ß√£o**  | "Has-A"       | Tem um      | Um `Carro` **tem um** `Motor`      |

<br />

> [!IMPORTANT]
>
> Neste primeiro momento, nosso foco ser√° na <strong>rela√ß√£o de Heran√ßa</strong>, pois ela √© fundamental para compreender a especializa√ß√£o de classes e o conceito de reutiliza√ß√£o de c√≥digo

<br />

<h2>2. Heran√ßa</h2>



Um dos pilares mais importantes da **programa√ß√£o orientada a objetos** √© o conceito de **heran√ßa**.

A **heran√ßa** √© um mecanismo que permite que uma classe reutilize atributos e comportamentos (m√©todos) de outra classe. Em outras palavras, uma classe pode **herdar** as caracter√≠sticas de uma **superclasse** (ou classe base), evitando duplica√ß√£o de c√≥digo e promovendo **reuso e organiza√ß√£o**.

> üìò Em Java, a heran√ßa √© implementada com a palavra-chave `extends`.

<div align="center"><img src="https://i.imgur.com/2T7wxZN.png" title="source: imgur.com" /></div>

- Analisando a imagem:
  
  - A **classe Transporte** define o atributo `capacidade`, comum a todos os tipos de transporte.
  - A **classe Terrestre** adiciona os atributos `n√∫mero de rodas` e `velocidade` (em km/h).
  - A **classe Automovel**, herdeira de `Terrestre`, define `cor`, `n√∫mero de portas`, `placa` e `marcha`.
  - Da mesma forma, temos as hierarquias:
    - `Aqu√°tico` ‚Üí `Barco`
    - `A√©reo` ‚Üí `Avi√£o`
  
  Essas rela√ß√µes mostram que:
  
  - **Barco**, por herdar de `Aqu√°tico`, tamb√©m herda tudo o que vem de `Transporte`.
  - **Automovel** herda de `Terrestre`, que por sua vez herda de `Transporte`.
  
  Portanto, heran√ßa √© uma forma de **reutiliza√ß√£o de c√≥digo**: uma classe herdeira (**subclasse**) absorve os membros (atributos e m√©todos) da classe de origem (**superclasse**) e pode ainda adicionar novos comportamentos ou especializar os existentes.

Abaixo, vemos o Diagrama de Classes do exemplo acima:

<img src="https://i.imgur.com/vGDOChv.png" title="source: imgur.com" width="5%"/>**Exemplo 01 - Diagrama de Classes** 

```mermaid
classDiagram
class Transporte {
- capacidade: int  
}
class Aereo {
  
}
class Terrestre {
- numero de rodas: int  
- velocidade: float 
}
class Aquatico {
  
}
class Aviao {
  
}
class Automovel {
- cor: String
- numero de portas: int
- placa: String
- marcha: int
}
class Barco {
  
}
Transporte <-- Aquatico
Transporte <-- Terrestre
Transporte <-- Aereo
Aquatico <-- Barco
Terrestre <-- Automovel
Aereo <-- Aviao
```

<br />

<h3>2.1. Tipos de Heran√ßa</h3>



Existem basicamente 2 tipos de heran√ßa:

- **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem Java usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.

- **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos de todas as superclasses. 

**Java n√£o suporta heran√ßa m√∫ltipla de classes**, mas permite que uma classe implemente m√∫ltiplas interfaces, oferecendo uma forma de simular heran√ßa m√∫ltipla de comportamento (n√£o de estado).

> ### Heran√ßa de Estado vs Heran√ßa de Comportamento
>
> **Heran√ßa de Estado** refere-se √† reutiliza√ß√£o dos **atributos** (vari√°veis de inst√¢ncia) de uma superclasse pela subclasse. Ou seja, a subclasse herda os dados que representam o estado do objeto, como propriedades, caracter√≠sticas ou informa√ß√µes.
>
> **Heran√ßa de Comportamento** refere-se √† reutiliza√ß√£o dos **m√©todos** (fun√ß√µes, a√ß√µes) definidos na superclasse pela subclasse. A subclasse pode usar esses m√©todos diretamente ou sobrescrev√™-los (polimorfismo) para alterar seu comportamento.

<br />

<h3>2.2. Heran√ßa em Java</h3>



**Sintaxe:**

```java
[modificadores] class NomeDaSubclasse extends NomeDaSuperClasse{
    // Corpo da Subclasse
}
```

Onde:

- **Modificadores**: Modificadores de Acesso e Non-Access

<br />

<h4>2.2.1. Modificadores de Acesso</h4>



As Classes possuem apenas 2 modificadores de acesso:

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **padr√£o**      | Tamb√©m chamado de *package-private*; uma classe com acesso padr√£o (sem modificador expl√≠cito) pode ser acessada por outras classes que estejam **no mesmo pacote**. |
| **public**      | Uma classe `public` pode ser acessada por qualquer outra classe, independentemente do pacote onde estiver. |

<br />

<h4>2.2.2. Modificadores Non-Access</h4>



As Classes possuem dois modificadores de Classes:

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **abstract**    | Uma classe abstrata **n√£o pode ser instanciada diretamente**. Ela serve como modelo para outras classes que a herdam e devem implementar seus m√©todos abstratos (se houver). |
| **final**       | Uma classe final **n√£o pode ser herdada por outras classes**. √â usada para impedir especializa√ß√µes e garantir comportamento final. |

***Observa√ß√µes importantes:***

- Uma classe **n√£o pode ser** `abstract` **e** `final` **ao mesmo tempo**, pois s√£o conceitos contradit√≥rios.
- Classes abstratas servem como base para heran√ßa, mas **n√£o podem ser instanciadas diretamente**.

<br />

<h4>2.2.3. A palavra reservada extends</h4>



A palavra reservada `extends` indica que uma nova classe est√° sendo criada como uma **subclasse** (classe derivada) de uma **superclasse** (classe base).

- A **superclasse** √© a classe existente que ser√° estendida.
- A **subclasse** √© a nova classe que herda atributos e m√©todos da superclasse, podendo adicionar ou modificar comportamentos.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/java_modifiers.asp" target="_blank"><b>Documenta√ß√£o: Modificadores de Classes</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_extends.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada extends</b></a></div>

<br />

<h3>2.3 O M√©todo Construtor da Subclasse</h3>



O **m√©todo construtor** de uma subclasse geralmente utiliza o comando `super()` para chamar o **construtor da superclasse**. Essa chamada √© fundamental para garantir que os atributos herdados da superclasse sejam inicializados corretamente.

- O uso de `super()` **deve ser a primeira instru√ß√£o dentro do construtor da subclasse**.
- No `super()` devem ser passados os par√¢metros necess√°rios para inicializar os atributos da superclasse.
- Os atributos espec√≠ficos da subclasse devem ser inicializados no pr√≥prio construtor da subclasse, ap√≥s a chamada ao `super()`.

<br />

<h3>2.4 A palavra reservada super</h3>



Al√©m do uso em construtores, a palavra reservada `super` tamb√©m pode ser usada para **referenciar explicitamente membros (m√©todos ou atributos) da superclasse**.

- √â comum utilizar `super` para **chamar m√©todos da superclasse que foram sobrescritos na subclasse**, evitando ambiguidades.
- A palavra reservada `this` refere-se ao objeto atual da classe, enquanto `super` refere-se ao objeto da superclasse correspondente.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank"><b>Documenta√ß√£o: M√©todo super()</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_super.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada super</b></a></div>

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Heran√ßa

**Classe Transporte**

```java
package exemplos_heranca;

public class Transporte {

	private int capacidade;

	public Transporte(int capacidade) {
		this.capacidade = capacidade;
	}

	public int getCapacidade() {
		return capacidade;
	}

	public void setCapacidade(int capacidade) {
		this.capacidade = capacidade;
	}
	
	public void visualizar() {
		
		System.out.println("\n\n************************************************************");
		System.out.println("Dados do Meio de Transporte:");
		System.out.println("****************************************************************");
		System.out.println("Capacidade (n√∫mero de passageiros): " + this.capacidade);
		
	}
}
```

A **classe `Transporte`** (superclasse) foi implementada com apenas um atributo: `capacidade`, conforme representado no diagrama de classes apresentado anteriormente.

Al√©m do atributo, a classe cont√©m:

- Um **m√©todo construtor**, respons√°vel por inicializar o valor do atributo `capacidade` no momento da cria√ß√£o do objeto;
- Os m√©todos **get** e **set**, utilizados para acessar e modificar o valor de `capacidade`;
- Um m√©todo chamado **`visualizar()`**, que exibe os dados do objeto na tela, facilitando a visualiza√ß√£o e valida√ß√£o das informa√ß√µes armazenadas.

Essa estrutura b√°sica permite que a classe `Transporte` sirva como base para outras subclasses, garantindo a reutiliza√ß√£o do atributo comum e dos comportamentos compartilhados.

<br />

**Classe Terrestre**


```java
package exemplos_heranca;

public class Terrestre extends Transporte {

	private int numeroRodas;
	private float velocidade;

	public Terrestre(int capacidade, int numeroRodas, float velocidade) {
		super(capacidade);
		this.numeroRodas = numeroRodas;
		this.velocidade = velocidade;
	}

	public int getNumeroRodas() {
		return numeroRodas;
	}

	public void setNumeroRodas(int numeroRodas) {
		this.numeroRodas = numeroRodas;
	}

	public float getVelocidade() {
		return velocidade;
	}

	public void setVelocidade(float velocidade) {
		this.velocidade = velocidade;
	}

    @Override
	public void visualizar() {

		super.visualizar();
		System.out.println("N√∫mero de rodas: " + this.numeroRodas);
		System.out.println("Velocidade: " + this.velocidade);

	}
}
```

A **classe `Terrestre`** (subclasse) foi criada como uma especializa√ß√£o da classe `Transporte`, utilizando o recurso de **heran√ßa** por meio da palavra-chave `extends Transporte`, conforme representado no diagrama de classes acima.

Ela possui dois novos atributos:

- `numeroRodas`
- `velocidade`

Al√©m dos atributos, foram implementados:

- O **m√©todo construtor**, que inicializa os atributos da classe, incluindo o atributo herdado `capacidade`;
- Os m√©todos **get** e **set** para `numeroRodas` e `velocidade`;
- O m√©todo **`visualizar()`**, respons√°vel por exibir os dados do objeto na tela.

**Observa√ß√µes importantes:**

- O m√©todo construtor da classe `Terrestre` inclui o par√¢metro `capacidade`, herdado da superclasse. Esse valor √© repassado ao construtor da superclasse utilizando o comando **`super(capacidade)`**, que deve ser a primeira instru√ß√£o do construtor;
- No m√©todo `visualizar()`, o comando **`super.visualizar()`** √© utilizado para chamar o m√©todo da superclasse, garantindo que as informa√ß√µes da classe `Transporte` tamb√©m sejam exibidas corretamente junto aos dados espec√≠ficos da subclasse `Terrestre`.

<br />

**Classe Automovel**

```java
package exemplos_heranca;

public class Automovel extends Terrestre{

	private String cor;
	private int numeroPortas;
	private String placa;
	private int marcha;
	
	public Automovel(int capacidade, int numeroRodas, float velocidade, String cor, int numeroPortas, String placa, int marcha) {
		super(capacidade, numeroRodas, velocidade);
		this.cor = cor;
		this.numeroPortas = numeroPortas;
		this.placa = placa;
		this.marcha = marcha;
	}

	public String getCor() {
		return cor;
	}

	public void setCor(String cor) {
		this.cor = cor;
	}

	public int getNumeroPortas() {
		return numeroPortas;
	}

	public void setNumeroPortas(int numeroPortas) {
		this.numeroPortas = numeroPortas;
	}

	public String getPlaca() {
		return placa;
	}

	public void setPlaca(String placa) {
		this.placa = placa;
	}
	
	public int getMarcha() {
		return marcha;
	}

	public void setMarcha(int marcha) {
		this.marcha = marcha;
	}

    @Override
	public void visualizar() {

		super.visualizar();
		System.out.println("cor: " + this.cor);
		System.out.println("N√∫mero de portas: " + this.numeroPortas);
		System.out.println("Placa: " + this.placa);
		System.out.println("Marcha: " + this.marcha);
		
	}
}
```

A **Classe Automovel** (Subclasse) foi criada como heran√ßa da **Classe Terrestre** (`extends Terrestre`), contendo os atributos **cor**, **n√∫mero de portas**, **placa** e **marcha**, conforme ilustrado no Diagrama de Classes acima. Al√©m disso, foram implementados o **m√©todo construtor**, os **m√©todos de acesso (get e set)** para cada atributo e o **m√©todo `visualizar()`** para exibi√ß√£o dos dados do objeto.

Observe que:

- No **m√©todo construtor**, foram inclu√≠dos como par√¢metros os atributos **capacidade** (herdado da Classe Transporte), **numeroRodas** e **velocidade** (herdados da Classe Terrestre), al√©m dos atributos espec√≠ficos da pr√≥pria Classe Automovel.
- Dentro do corpo do construtor, foi utilizada a **chamada ao m√©todo `super(capacidade, numeroRodas, velocidade)`**, com o objetivo de inicializar corretamente os atributos herdados da Classe Terrestre e, indiretamente, da Classe Transporte.
- No **m√©todo `visualizar()`**, tamb√©m foi utilizada a chamada `super.visualizar()` para reaproveitar a exibi√ß√£o dos atributos herdados, garantindo que os dados das Classes Transporte e Terrestre sejam listados antes dos dados espec√≠ficos da Classe Automovel.

<br />

**Classe Exemplo01 (classe principal)**

```java
package exemplos_heranca;

public class Exemplo01 {

	public static void main(String[] args) {

		Automovel a1 = new Automovel(5, 4, 0.0f, "Verde", 4, "EBN-0301", 0);
		
		a1.visualizar();

	}
}
```

Na **classe `Exemplo01`**, foi instanciado um objeto da **classe `Automovel`**.

Devido √† hierarquia de heran√ßa entre as classes, o construtor da classe `Automovel` exige **sete par√¢metros**, correspondentes aos atributos herdados e aos pr√≥prios da subclasse:

- **capacidade** ‚Äì herdado da **classe `Transporte`**
- **numeroRodas** e **velocidade** ‚Äì herdados da **classe `Terrestre`**
- **cor**, **numeroPortas**, **placa** e **marcha** ‚Äì definidos na **classe `Automovel`**

Essa estrutura demonstra a reutiliza√ß√£o e o encadeamento de atributos promovidos pela heran√ßa, otimizando o reaproveitamento de c√≥digo.

Abaixo, segue a sa√≠da gerada no console com a execu√ß√£o do m√©todo `visualizar()`:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```
*********************************************************************
Dados do Meio de Transporte:
*********************************************************************
Capacidade (n√∫mero de passageiros: 5
N√∫mero de rodas: 4
Velocidade: 0.0
cor: Verde
N√∫mero de portas: 4
Placa: EBN-0301
Marcha: 0
```

<br />

> [!TIP]
>
> **Dicas sobre Heran√ßa:**
>
> A heran√ßa √© um dos pilares da Programa√ß√£o Orientada a Objetos (POO) e deve ser utilizada com aten√ß√£o e planejamento. Aqui est√£o algumas boas pr√°ticas e orienta√ß√µes para aplicar corretamente esse recurso:
>
> 1. **Centralize o que √© comum**: Sempre defina os **atributos e m√©todos comuns** a todas as subclasses na **superclasse**. Isso evita duplicidade de c√≥digo e promove maior reaproveitamento e organiza√ß√£o.
> 2. **Use heran√ßa quando houver uma rela√ß√£o "√© um"**: A heran√ßa deve representar uma rela√ß√£o **"√© um tipo de"**. Ou seja, um objeto da **subclasse** **√© tamb√©m um objeto da superclasse**.
>     <br>
>     *Exemplo:* Um `Automovel` **√© um tipo de ve√≠culo** `Terrestre`, que por sua vez **√© um tipo de** `Transporte`.
> 3. **Evite heran√ßa quando n√£o for necess√°ria**: N√£o utilize heran√ßa se **apenas alguns poucos m√©todos ou atributos** da superclasse forem √∫teis para a subclasse. Isso pode gerar acoplamento desnecess√°rio. Nestes casos, **prefira a composi√ß√£o**.
> 4. **Utilize `super` de forma consciente**: Use a palavra-chave `super` para acessar o construtor ou m√©todos da superclasse. Isso √© √∫til para **inicializar atributos herdados** ou **executar comportamentos comuns**, sem precisar reescrever c√≥digo.
> 5. **Mantenha a hierarquia simples**: Evite cadeias longas de heran√ßa (4 ou mais n√≠veis). Isso torna o c√≥digo mais dif√≠cil de entender, manter e testar. Prefira **modelos mais planos e coesos**.
> 6. **Documente a hierarquia**: Ao criar uma estrutura de heran√ßa, √© importante **manter um diagrama de classes** ou uma documenta√ß√£o clara para facilitar a leitura, manuten√ß√£o e expans√£o do sistema.

<br />

<h2>3. Polimorfismo</h2>



O termo **polimorfismo** deriva do grego *polymorphos*, que significa ‚Äúmuitas formas‚Äù. Em programa√ß√£o orientada a objetos (POO), **polimorfismo √© a capacidade que objetos de classes diferentes t√™m de responder √† mesma mensagem (m√©todo) de maneiras distintas**.

Em outras palavras, o polimorfismo permite que **m√∫ltiplas classes tenham m√©todos com o mesmo nome**, mas com **comportamentos diferentes**, adequados ao contexto de cada classe. Isso possibilita maior flexibilidade, reutiliza√ß√£o de c√≥digo e extensibilidade no desenvolvimento de sistemas orientados a objetos.

**Exemplo ilustrativo**

Imagine que o dono de uma f√°brica de brinquedos solicitou aos engenheiros que criassem **um √∫nico controle remoto para todos os brinquedos**. A √∫nica exig√™ncia √© que **cada brinquedo responda ao comando de forma adequada √† sua natureza**.

<div align="center"><img src="https://i.imgur.com/NM8RVg5.png" title="source: imgur.com" /></div>

Quando o controle envia o comando `mover`, cada brinquedo interpreta esse comando de maneira diferente:

- Para o **avi√£o**, mover significa **voar**;
- Para o **barco**, significa **navegar**;
- Para o **autom√≥vel**, significa **correr**.

<div align="center"><img src="https://i.imgur.com/KnwNIwl.png" title="source: imgur.com" /></div>

Observe que, embora a mensagem seja a mesma (`mover`), **cada objeto responde de maneira espec√≠fica**, conforme sua implementa√ß√£o. Isso √© o que caracteriza o polimorfismo.

<br />

<h3>3.1. Como funciona na pr√°tica?</h3>



Na pr√°tica, o polimorfismo ocorre da seguinte forma:

1. Ao enviar uma mensagem (chamada de m√©todo) para um **objeto de uma subclasse**, o interpretador verifica se a subclasse possui esse m√©todo com os **mesmos par√¢metros** informados:
   - ‚úÖ **Se sim**, o m√©todo da subclasse √© executado.
   - ‚ùå **Se n√£o**, o sistema procura o m√©todo na **superclasse**.
2. A **superclasse** entra em a√ß√£o e executa o m√©todo correspondente, se dispon√≠vel.
3. Esse comportamento permite que a mesma chamada de m√©todo produza **resultados diferentes**, dependendo do objeto que a recebe.

<br />

<h3>3.2. Tipos de Polimorfismo</h3>



O polimorfismo pode ser classificado em dois tipos principais:

<br />

<h4>3.2.1. Polimorfismo de Sobrecarga (Sobrecarga de M√©todo)</h4>



**Sobrecarga de m√©todos** consiste em definir **v√°rios m√©todos com o mesmo nome** dentro de uma mesma classe, mas com **assinaturas diferentes** (quantidade, tipo ou ordem dos par√¢metros). Veja o exemplo a seguir:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02: Polimorfismo de Sobrecarga

```java
public class Transporte {

	private int capacidade;

    /*M√©todo Construtor com par√¢metros*/
	public Transporte(int capacidade) {
		this.capacidade = capacidade;
	}
    
    /*M√©todo Construtor sem par√¢metros*/
    public Transporte() {	}
    
}
```

Neste exemplo, temos dois **m√©todos construtores** com o mesmo nome (`Transporte`), mas com **assinaturas diferentes**. Isso permite instanciar objetos da classe `Transporte` de maneiras distintas.

A **sobrecarga** √© √∫til especialmente em **m√©todos construtores**, pois oferece flexibilidade na cria√ß√£o de objetos, permitindo a inicializa√ß√£o com ou sem par√¢metros.

> [!IMPORTANT]
>
> O construtor adequado ser√° escolhido com base na **quantidade**, **tipo** e **ordem** dos argumentos fornecidos na chamada.

<br />

<h4>3.2.2. Polimorfismo de Sobreposi√ß√£o (Sobrescrita de M√©todo)</h4>



**Sobreposi√ß√£o de m√©todos**, tamb√©m chamada de **sobrescrita**, ocorre quando uma **subclasse reimplementa um m√©todo herdado da superclasse**, mantendo a mesma **assinatura** (nome e par√¢metros) e o mesmo **tipo de retorno**.

Diferente da sobrecarga (m√©todos coexistindo), a sobrescrita **substitui** o comportamento do m√©todo herdado.

> ‚úÖ **Quando usar sobrescrita?**
>  Quando a subclasse precisa especializar ou adaptar o comportamento de um m√©todo herdado, fornecendo uma implementa√ß√£o pr√≥pria.

Para indicar que um m√©todo est√° sendo sobrescrito, utiliza-se a anota√ß√£o **@Override**, que, embora opcional, **√© altamente recomendada**, pois permite ao compilador validar se a sobrescrita est√° correta.

> As **anota√ß√µes** (ou *annotations*) s√£o **metadados inseridos diretamente no c√≥digo-fonte** com o objetivo de configurar comportamentos espec√≠ficos em tempo de compila√ß√£o ou execu√ß√£o. Elas permitem eliminar a necessidade de arquivos externos de configura√ß√£o (como XML), tornando o c√≥digo mais leg√≠vel, organizado e de f√°cil manuten√ß√£o. S√£o muito utilizadas em frameworks como Spring, JPA e Jakarta EE.
>
> **Metadados** (ou *meta-informa√ß√µes*) s√£o **dados que descrevem outros dados**. Eles fornecem informa√ß√µes adicionais, como tipo, estrutura, finalidade ou contexto de um dado, geralmente de forma leg√≠vel por sistemas computacionais.
>
> Por exemplo, em uma imagem digital, os metadados podem incluir a data de cria√ß√£o, modelo da c√¢mera, localiza√ß√£o GPS e at√© permiss√µes de uso. Em sistemas de software, os metadados ajudam a definir **relacionamentos, regras de valida√ß√£o e comportamento** dos elementos representados no c√≥digo, como entidades, campos ou m√©todos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03: Polimorfismo de Sobrescrita

<br />

O M√©todo **visualizar()** da Classe Transporte, est√° implementado da seguinte forma:

```Java
	public void visualizar() {
		
		System.out.println("\n\n************************************************************");
		System.out.println("Dados do Meio de Transporte:");
		System.out.println("****************************************************************");
		System.out.println("Capacidade (n√∫mero de passageiros: " + this.capacidade);
		
	}
```

Na classe `Terrestre`, o mesmo m√©todo foi sobrescrito da seguinte maneira:

```java
	@Override
	public void visualizar() {

		super.visualizar();
		System.out.println("N√∫mero de rodas: " + this.numeroRodas);
		System.out.println("Velocidade: " + this.velocidade);

	}
```

E, na classe `Automovel`, o m√©todo `visualizar()` foi novamente sobrescrito:

```java
	@Override
	public void visualizar() {

		super.visualizar();
		System.out.println("cor: " + this.cor);
		System.out.println("N√∫mero de portas: " + this.numeroPortas);
		System.out.println("Placa: " + this.placa);
		System.out.println("Marcha: " + this.marcha);
		
	}
```

Perceba que as **assinaturas dos tr√™s m√©todos s√£o id√™nticas** ‚Äî mesmo nome e mesma lista de par√¢metros ‚Äî, por√©m cada classe fornece sua **pr√≥pria implementa√ß√£o** do m√©todo `visualizar()`. Isso ocorre porque cada classe deseja exibir seus pr√≥prios atributos, al√©m dos atributos herdados de suas superclasses.

Para que o m√©todo `visualizar()` funcione corretamente nas classes `Terrestre` e `Automovel`, ele precisou ser sobrescrito, pois essas subclasses **n√£o t√™m acesso direto aos atributos privados da superclasse**. Dessa forma, utilizam o comando `super.visualizar()` para invocar o comportamento da superclasse e exibir os dados herdados.

> [!IMPORTANT]
>
> Quando um **m√©todo √© redefinido** (sobrescrito) em uma subclasse com o **mesmo nome e par√¢metros** da superclasse, ele **oculta** o m√©todo original a partir da subclasse. Ou seja, a subclasse passa a utilizar **a sua pr√≥pria vers√£o do m√©todo**, caracterizando o **polimorfismo por sobrescrita**.

<br />

## üÜö Tabela Comparativa: Sobrecarga vs Sobrescrita

| Sobrecarga (Overloading)               | Sobrescrita (Overriding)                 |
| -------------------------------------- | ---------------------------------------- |
| Ocorre na **mesma classe**             | Ocorre entre **superclasse e subclasse** |
| Mesma nome do m√©todo                   | Mesmo nome e assinatura do m√©todo        |
| Diferente n√∫mero ou tipo de par√¢metros | Assinatura id√™ntica                      |
| Definido em tempo de compila√ß√£o        | Resolvido em tempo de execu√ß√£o           |

<br />

> [!TIP]
>
> ### Dicas pr√°ticas sobre Polimorfismo
>
> - O polimorfismo geralmente est√° associado ao **conceito de heran√ßa** e √† **sobrescrita de m√©todos** (`@Override` em Java).
> - Uma das principais vantagens do polimorfismo √© permitir a constru√ß√£o de **c√≥digos gen√©ricos**, que podem manipular objetos de diferentes classes sem se preocupar com sua implementa√ß√£o espec√≠fica.
> - Polimorfismo favorece a **manuten√ß√£o e evolu√ß√£o de sistemas**, pois permite adicionar novas subclasses com comportamentos distintos, sem precisar alterar o c√≥digo que consome essas classes.
> - Em Java, **interfaces** e **classes abstratas** tamb√©m s√£o amplamente utilizadas para implementar polimorfismo.

<br />

------

## üîë**Pontos chave:**

1. **Relacionamentos entre classes** definem como as classes interagem e colaboram dentro de um sistema orientado a objetos. Incluem heran√ßa, depend√™ncia e associa√ß√£o.
2. **Depend√™ncia**: √â um relacionamento onde uma classe **utiliza temporariamente outra classe** para realizar uma a√ß√£o espec√≠fica. Essa intera√ß√£o ocorre geralmente atrav√©s de par√¢metros de m√©todos ou cria√ß√£o de objetos locais, **sem manter uma refer√™ncia permanente**. Representa uma rela√ß√£o do tipo **"usa-um"**.
3. **Associa√ß√£o**: √â um relacionamento onde uma classe **tem uma refer√™ncia a outra**, representando uma rela√ß√£o do tipo **"tem-um"**. Ambas as classes podem existir de forma independente.
4. **Agrega√ß√£o**: √â uma forma especializada de associa√ß√£o que representa uma rela√ß√£o **"todo-parte" fraca**, onde as partes podem existir independentemente do todo.
5. **Composi√ß√£o**: √â uma rela√ß√£o **"todo-parte" forte**, onde as partes **dependem totalmente do todo para existir**. Se o objeto todo for destru√≠do, suas partes tamb√©m ser√£o.
6. **Heran√ßa** permite que uma classe (subclasse) herde atributos e m√©todos de outra classe (superclasse), promovendo reuso de c√≥digo e especializa√ß√£o.
7. Em **Java, √© poss√≠vel realizar heran√ßa simples** (uma √∫nica superclasse por classe). A heran√ßa m√∫ltipla de classes n√£o √© suportada, mas pode ser simulada por meio de **interfaces**.
8. **Polimorfismo** permite que objetos de diferentes classes respondam ao mesmo m√©todo de formas distintas. Ele se apresenta em dois formatos:
   - **Sobrecarga (Overloading):** m√©todos com mesmo nome, por√©m diferentes assinaturas, na mesma classe.
   - **Sobrescrita (Overriding):** redefini√ß√£o de m√©todos herdados por uma subclasse, com mesma assinatura.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>