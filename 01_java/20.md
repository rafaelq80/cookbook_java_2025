<h1>Express√µes Lambda</h1>



Antes de abordarmos as **Express√µes Lambda**, √© importante compreender o conceito de **Programa√ß√£o Funcional**.

<br />

<h2>1. Programa√ß√£o Funcional</h2>



O **paradigma da Programa√ß√£o Funcional** √© um estilo de desenvolvimento que se baseia na defini√ß√£o e na composi√ß√£o de fun√ß√µes, com forte √™nfase na **imutabilidade** dos dados e na **aus√™ncia de efeitos colaterais**. Nesse modelo, a computa√ß√£o √© tratada como a avalia√ß√£o de fun√ß√µes matem√°ticas, evitando-se o uso de estados mut√°veis e o compartilhamento de dados entre diferentes partes do sistema.

> **Paradigma de programa√ß√£o** refere-se a um estilo ou modelo de escrita de programas de computador, fundamentado em princ√≠pios, conceitos e t√©cnicas que orientam como o c√≥digo √© estruturado, organizado e executado.

Entre as principais caracter√≠sticas da Programa√ß√£o Funcional, destacam-se:

- **Composi√ß√£o de fun√ß√µes**: consiste em construir fun√ß√µes mais complexas a partir da combina√ß√£o de outras fun√ß√µes menores e reutiliz√°veis.
- **Fun√ß√µes puras**: fun√ß√µes que, ao receber os mesmos argumentos, sempre retornam o mesmo resultado, sem causar efeitos colaterais ‚Äî ou seja, sem modificar vari√°veis externas nem acessar estados compartilhados.
- **Imutabilidade**: os dados, uma vez definidos, n√£o podem ser alterados. Em vez de modificar um valor ou objeto existente, cria-se uma nova vers√£o com os dados atualizados.

A Programa√ß√£o Funcional tem suas ra√≠zes na matem√°tica e busca promover solu√ß√µes elegantes, concisas e robustas, especialmente √∫teis em sistemas complexos e altamente abstratos.

Esse paradigma fundamenta-se em um modelo te√≥rico conhecido como **C√°lculo Lambda**, desenvolvido por *Alonzo Church* na d√©cada de 1930, com o objetivo de formalizar conceitos como **fun√ß√£o**, **aplica√ß√£o** e **recurs√£o**.

O **C√°lculo Lambda** define um sistema computacional baseado exclusivamente em fun√ß√µes an√¥nimas e na aplica√ß√£o de argumentos, sem o uso de vari√°veis mut√°veis ou estruturas imperativas de controle, como la√ßos e condicionais tradicionais.

Essa base te√≥rica influenciou diversas linguagens de programa√ß√£o modernas e serviu de alicerce para a cria√ß√£o das **Express√µes Lambda** ‚Äî uma forma pr√°tica e moderna de aplicar os princ√≠pios da programa√ß√£o funcional.

Em linguagens de alto n√≠vel como **Java**, as Express√µes Lambda permitem representar fun√ß√µes como objetos, de forma concisa e direta, sem a necessidade de declarar classes ou m√©todos nomeados. Com isso, o Java aproxima-se do paradigma funcional e amplia significativamente seu poder expressivo.

<br />

<h2>2. Paradigmas de Programa√ß√£o - Linguagens de Alto N√≠vel</h2>



Para compreender melhor o **paradigma da Programa√ß√£o Funcional**, √© importante conhecer os principais paradigmas utilizados pelas linguagens de alto n√≠vel mais populares: **Programa√ß√£o Imperativa** e **Programa√ß√£o Orientada a Objetos (POO)**.

<div align="center"><img src="https://i.imgur.com/EtLQsSx.jpg" title="source: imgur.com" width="90%"/></div>

<br />

<h3>2.1. Programa√ß√£o Imperativa</h3>



A **Programa√ß√£o Imperativa** √© um dos paradigmas mais antigos e amplamente adotados na hist√≥ria da computa√ß√£o. Ela se baseia na execu√ß√£o sequencial de instru√ß√µes que alteram o estado interno do programa ao longo do tempo.

Nesse modelo, a pessoa desenvolvedora descreve **como** o problema deve ser resolvido, utilizando comandos expl√≠citos, manipula√ß√£o de vari√°veis, atribui√ß√µes de valores, estruturas de repeti√ß√£o e condicionais. O foco est√° no controle do fluxo de execu√ß√£o e na altera√ß√£o progressiva dos estados.

Linguagens como **C**, **Pascal** e **COBOL** s√£o exemplos cl√°ssicos desse paradigma, frequentemente utilizadas em cen√°rios que exigem desempenho e controle preciso sobre os recursos de hardware, como mem√≥ria e processador.

<div align="center"><img src="https://i.imgur.com/7iY404h.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.2. Programa√ß√£o Orientada a Objetos</h3>



A **Programa√ß√£o Orientada a Objetos (POO)** √©, atualmente, o paradigma mais amplamente utilizado no desenvolvimento de software. Baseia-se na abstra√ß√£o de entidades do mundo real por meio de **objetos**, que encapsulam **atributos** (estado) e **m√©todos** (comportamento).

Nesse modelo, a pessoa desenvolvedora descreve **o que** o programa deve fazer, organizando o c√≥digo em **classes**, que servem como modelos para a cria√ß√£o de objetos. A POO promove princ√≠pios fundamentais como:

- **Encapsulamento**
- **Heran√ßa**
- **Polimorfismo**
- **Abstra√ß√£o**

Esses princ√≠pios favorecem a reutiliza√ß√£o de c√≥digo, a modularidade e a manuten√ß√£o de sistemas de m√©dio e grande porte.

Linguagens como **Java**, **C#** e **C++** s√£o exemplos consolidados desse paradigma, aplicadas em projetos corporativos, aplica√ß√µes desktop, web e sistemas embarcados.

<div align="center"><img src="https://i.imgur.com/FJVYTaz.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.3. E a Programa√ß√£o Funcional?</h3>



Diferentemente dos paradigmas Imperativo e Orientado a Objetos, a **Programa√ß√£o Funcional** adota a premissa de que **tudo √© fun√ß√£o**. Ao inv√©s de estruturas sequenciais que alteram estados ou de modelagem baseada em objetos, esse paradigma constr√≥i solu√ß√µes por meio da **composi√ß√£o de fun√ß√µes matem√°ticas puras**, que recebem dados de entrada e retornam resultados sem provocar efeitos colaterais.

Nesse modelo, as fun√ß√µes n√£o modificam os dados originais. A transforma√ß√£o ocorre exclusivamente por opera√ß√µes encadeadas. Isso garante que, dado o mesmo conjunto de entradas, a sa√≠da ser√° sempre a mesma ‚Äî promovendo previsibilidade, consist√™ncia e seguran√ßa.

Outro princ√≠pio essencial da programa√ß√£o funcional √© a **imutabilidade**: os dados s√£o tratados como constantes, e n√£o como vari√°veis que sofrem altera√ß√£o. Isso reduz erros causados por mudan√ßas de estado inesperadas, facilitando o racioc√≠nio sobre o comportamento do programa.

#### Vantagens da Programa√ß√£o Funcional:

- ‚úÖ **Facilidade de testes e depura√ß√£o**: fun√ß√µes puras s√£o previs√≠veis e isol√°veis, o que simplifica a escrita de testes unit√°rios.
- ‚úÖ **Concorr√™ncia e paralelismo mais seguros**: como n√£o h√° compartilhamento de estado, diferentes partes do c√≥digo podem ser executadas simultaneamente sem riscos de conflito.
- ‚úÖ **Expressividade e legibilidade**: o estilo declarativo aproxima o c√≥digo da descri√ß√£o do problema, tornando-o mais direto e f√°cil de entender.

#### Desvantagens da Programa√ß√£o Funcional:

- ‚ö†Ô∏è **Curva de aprendizado**: conceitos como fun√ß√µes puras, imutabilidade e recursividade podem ser desafiadores para quem est√° habituado a paradigmas imperativos ou orientados a objetos.
- ‚ö†Ô∏è **Uso intensivo de mem√≥ria**: devido √† cria√ß√£o constante de novos objetos ao inv√©s de modifica√ß√µes em estruturas existentes.
- ‚ö†Ô∏è **Menor suporte e integra√ß√£o em algumas plataformas**: por ser menos difundido, pode haver menos bibliotecas e ferramentas espec√≠ficas em compara√ß√£o com outros paradigmas.

Linguagens que seguem ou oferecem forte suporte ao paradigma funcional incluem: **Haskell**, **Clojure**, **Elixir**, entre outras. Linguagens multiparadigma como **Java**, **JavaScript**, **Python** e **Scala** tamb√©m incorporam recursos funcionais, como express√µes lambda, fun√ß√µes de ordem superior e imutabilidade.

<div align="center"><img src="https://i.imgur.com/fcUE3rV.png" title="source: imgur.com" width="80%"/></div>

<br />

<h2>3. Express√µes Lambda</h2>



Uma **Express√£o Lambda** √© uma forma concisa de representar uma **fun√ß√£o an√¥nima** ‚Äî ou seja, uma fun√ß√£o **sem nome**, definida diretamente no corpo de um m√©todo. Ela pode receber par√¢metros, executar uma l√≥gica e retornar um resultado, funcionando de maneira similar a um m√©todo tradicional, por√©m **sem a necessidade de ser declarada dentro de uma classe**.

As Express√µes Lambda foram introduzidas no **Java 8**, como parte da incorpora√ß√£o dos princ√≠pios da **Programa√ß√£o Funcional** √† linguagem. Com esse recurso, foi poss√≠vel escrever c√≥digos mais **enxutos, leg√≠veis e expressivos**, especialmente em situa√ß√µes que exigem o uso de **fun√ß√µes como par√¢metros**, como em chamadas ao m√©todo `forEach()` e no uso da **Streams API**.

Essa adi√ß√£o aumentou significativamente a flexibilidade da linguagem, trazendo ganhos em produtividade e clareza, sobretudo em opera√ß√µes funcionais sobre cole√ß√µes e em modelos de programa√ß√£o reativa.

**Sintaxe:**

```java
lista de par√¢metros -> corpo da fun√ß√£o
```

Uma **Express√£o Lambda** √© composta por tr√™s partes principais:

1. **Lista de Par√¢metros**: Os argumentos da fun√ß√£o, entre par√™nteses. Podem estar vazios ou conter um ou mais par√¢metros, com ou sem o tipo expl√≠cito.
2. **Operador Lambda (`->`)**: Tamb√©m conhecido como ‚Äúseta‚Äù, separa os par√¢metros do corpo da fun√ß√£o.
3. **Corpo da Fun√ß√£o**: A l√≥gica a ser executada. Pode ser uma √∫nica express√£o ou um bloco de instru√ß√µes delimitado por chaves `{}`.

### ‚úÖ Vantagens das Express√µes Lambda em Java:

- Redu√ß√£o de **boilerplate** (c√≥digo repetitivo e extenso);
- Aumento da **legibilidade**, principalmente ao trabalhar com cole√ß√µes;
- Maior **ader√™ncia √† Programa√ß√£o Funcional**, com foco em fun√ß√µes puras e imutabilidade.

Em resumo, as Express√µes Lambda representam um avan√ßo significativo na forma de escrever c√≥digo em Java, promovendo uma abordagem mais **declarativa**, menos verbosa e alinhada aos **paradigmas funcionais modernos**.

<br />

<h3>3.1. Principais Caracter√≠sticas das Express√µes Lambda</h3>



As **Express√µes Lambda** em Java possuem uma sintaxe flex√≠vel e direta. Abaixo, destacamos suas principais caracter√≠sticas, com exemplos ilustrativos.

<br />

#### 1. **Declara√ß√£o de tipo (opcional)**

O tipo dos par√¢metros pode ser omitido, pois o compilador do Java consegue inferi-lo com base no contexto, especialmente quando usado com interfaces funcionais.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Express√µes Lambda - Sem Tipo

```java
(a, b) -> a + b
```

Neste exemplo, os tipos de `a` e `b` s√£o inferidos automaticamente.

<br />

#### 2. **Par√™nteses ao redor dos par√¢metros**

- Os **par√™nteses s√£o opcionais** quando h√° **apenas um par√¢metro** e seu tipo n√£o √© declarado.
- Se houver **mais de um par√¢metro**, os par√™nteses s√£o **obrigat√≥rios**.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - Express√µes Lambda - Um Par√¢metro

```java
a -> a * a
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Express√µes Lambda - Dois Par√¢metros

```java
(a, b) -> a + b
```

<br />

#### 3. **Uso de chaves no corpo da fun√ß√£o**

- Quando o corpo da fun√ß√£o cont√©m apenas **uma √∫nica express√£o**, as **chaves `{}` s√£o opcionais**.
- Se houver **mais de uma instru√ß√£o**, as chaves s√£o **obrigat√≥rias** para delimitar o bloco.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Express√µes Lambda - M√∫ltiplas Instru√ß√µes

```java
n -> {
    int resultado = n * n;
    System.out.println("Resultado: " + resultado);
    return resultado;
}
```

<br />

#### 4. **Uso da palavra-chave `return`**

- Quando h√° apenas uma express√£o no corpo da fun√ß√£o, **o `return` √© impl√≠cito** e pode ser omitido.
- Caso o corpo seja um **bloco com v√°rias instru√ß√µes**, o uso do `return` torna-se **necess√°rio** para devolver o valor.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 05 - Express√µes Lambda - Retorno Expl√≠cito

```java
n -> {
    int resultado = n * n;
    return resultado;
}
```

Essas caracter√≠sticas tornam as Express√µes Lambda uma ferramenta poderosa para tornar o c√≥digo **mais limpo, expressivo e funcional**, especialmente ao trabalhar com APIs como `Stream`, `Comparator`, `Runnable`, entre outras.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 06 - Express√µes Lambda - Collections

Nesta primeira vers√£o do c√≥digo, n√£o foram utilizadas as Express√µes Lambda:

```java
package exemplos_lambda;

import java.util.Arrays;
import java.util.List;

public class Exemplo06 {
	
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n);
		}

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n + n);
		}

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			if(n%2 == 0)
			System.out.println(n);
		}
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 07 - Express√µes Lambda - Collections

Na segunda vers√£o do c√≥digo, foram utilizadas as Express√µes Lambda:

```java
package exemplos_lambda;

import java.util.Arrays;
import java.util.List;

public class Exemplo07 {
	
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n));

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n + n));

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista com Express√£o Lambda
		numeros.forEach(n -> {
			if (n % 2 == 0)
				System.out.println(n);
		});
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

Observe que o **resultado foi o mesmo**, entretanto, no **Exemplo 07** utilizamos **Express√µes Lambda**.

Ao comparar a primeira vers√£o do c√≥digo ‚Äî escrita de forma tradicional ‚Äî com a segunda vers√£o, que utiliza Express√µes Lambda, nota-se uma **redu√ß√£o significativa na verbosidade**. O c√≥digo torna-se **mais direto, leg√≠vel e enxuto**, o que favorece tanto a **clareza** quanto a **manuten√ß√£o**.

Neste caso, as Express√µes Lambda foram aplicadas no m√©todo **`forEach()`**, dispon√≠vel na interface **`Iterable`** ‚Äî a qual √© implementada por estruturas de cole√ß√£o como `List`, `Set`, entre outras. Esse m√©todo recebe como argumento uma **interface funcional**, especificamente a **`Consumer<T>`**, pertencente ao pacote `java.util.function`.

Por se tratar de uma interface funcional (ou seja, contendo **apenas um m√©todo abstrato**), `Consumer<T>` permite passar diretamente o comportamento desejado como uma **Express√£o Lambda**. Com isso, elimina-se a necessidade de declarar classes an√¥nimas ou m√©todos auxiliares, tornando o c√≥digo mais **conciso**, **expressivo** e alinhado aos princ√≠pios da **Programa√ß√£o Funcional** incorporados ao Java a partir da vers√£o 8.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank"><b>Documenta√ß√£o: Express√µes Lambda</b></a></div>

<br />

<h2>4. Interfaces Funcionais</h2>



As **interfaces funcionais** s√£o fundamentais na programa√ß√£o funcional em Java. Elas representam abstra√ß√µes que possuem **apenas um √∫nico m√©todo abstrato**, sendo ideais para uso com **Express√µes Lambda** ou **refer√™ncias de m√©todo**. Por terem somente um m√©todo a ser implementado, o compilador pode associar diretamente uma fun√ß√£o an√¥nima a esse m√©todo, tornando o c√≥digo mais simples e flex√≠vel.

Desde o Java 8, o pacote `java.util.function` fornece um conjunto robusto de interfaces funcionais pr√©-definidas, que atendem aos casos mais comuns ‚Äî como transforma√ß√£o de dados, consumo de valores e valida√ß√µes.

Embora n√£o seja obrigat√≥rio, √© **altamente recomend√°vel utilizar a anota√ß√£o `@FunctionalInterface` ao definir interfaces funcionais personalizadas**. Essa anota√ß√£o tem a fun√ß√£o de instruir o compilador a validar se a interface segue corretamente o contrato de uma interface funcional, ou seja, se possui **exatamente um m√©todo abstrato**. Caso sejam adicionados dois ou mais m√©todos abstratos, o compilador emitir√° um erro em tempo de compila√ß√£o.

Essa pr√°tica √© especialmente √∫til quando o desenvolvedor est√° criando suas **pr√≥prias interfaces funcionais**, que ser√£o utilizadas com **Express√µes Lambda** ou **refer√™ncias de m√©todo**. O uso da anota√ß√£o evita erros acidentais e torna a inten√ß√£o do c√≥digo mais clara, facilitando a leitura e a manuten√ß√£o por outras pessoas da equipe.

Al√©m disso, mesmo que as interfaces funcionais da API Java, como `Consumer`, `Predicate` e `Function`, j√° estejam corretamente configuradas para esse uso, ao criar **interfaces funcionais customizadas**, o uso da anota√ß√£o `@FunctionalInterface` √© uma **boa pr√°tica de programa√ß√£o** que contribui para a robustez e legibilidade do c√≥digo.

<br />

<h3>4.1. Interfaces Funcionais Nativas</h3>



A biblioteca padr√£o do Java disponibiliza diversas interfaces funcionais no pacote `java.util.function`. A seguir, apresentamos as **seis principais interfaces funcionais**, amplamente utilizadas em aplica√ß√µes modernas que fazem uso de **Streams**, **Collections**, **APIs reativas**, entre outras. Essas interfaces facilitam a programa√ß√£o funcional, permitindo maior expressividade e flexibilidade no tratamento de dados e comportamentos. Conhe√ßa as principais, na tabela abaixo:

| Interface            | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| **`Consumer<T>`**    | Representa uma opera√ß√£o que **recebe um par√¢metro** e **n√£o retorna resultado**. Muito usada com `forEach`, `peek` ou para executar a√ß√µes em cada elemento. |
| **`Function<T, R>`** | Representa uma fun√ß√£o que **recebe um argumento do tipo `T`** e **retorna um resultado do tipo `R`**.Usada frequentemente com m√©todos como `map()`. |
| **`Predicate<T>`**   | Representa uma express√£o booleana que **testa uma condi√ß√£o sobre um valor do tipo `T`**.Comum em m√©todos como `filter()`. |
| **`Supplier<T>`**    | Fornece um valor do tipo `T` sem receber nenhum argumento. Utilizado quando √© necess√°rio gerar ou fornecer dados sob demanda. |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 07 - Express√µes Lambda - Interfaces Funcionais



Neste exemplo, vamos desenvolver uma calculadora simples utilizando **Express√µes Lambda**. Para isso, criaremos uma **Interface Funcional personalizada**, que servir√° como base para representar opera√ß√µes matem√°ticas de maneira **flex√≠vel, reutiliz√°vel e coesa com o paradigma funcional**.

A interface ser√° chamada **`OperacaoMatematica`** e definir√° **um √∫nico m√©todo abstrato**, respons√°vel por executar uma opera√ß√£o entre dois n√∫meros inteiros. Por conter apenas um m√©todo abstrato, ela se enquadra como uma **interface funcional**, podendo ser usada diretamente com express√µes lambda ou refer√™ncias de m√©todo.

Com essa estrutura, ser√° poss√≠vel **passar as opera√ß√µes como par√¢metros**, utilizando lambdas para definir comportamentos como soma, subtra√ß√£o, multiplica√ß√£o e divis√£o, tornando o c√≥digo mais **modular, leg√≠vel e de f√°cil manuten√ß√£o**.

**Interface OperacaoMatematica**

```java
package lambda;

@FunctionalInterface
public interface OperacaoMatematica {

	public int executar(int a, int b);

}
```

<br />

**Classe Calculadora**

```java
package exemplos_lambda;

import java.util.Scanner;

public class Exemplo08 {

    public static int calcular(OperacaoMatematica operacao, int numero1, int numero2) {
        return operacao.executar(numero1, numero2);
    }

    public static void main(String[] args) {
        Scanner leia = new Scanner(System.in);

        System.out.println("****************************************************");
        System.out.println("              Calculadora com Lambda                ");
        System.out.println("****************************************************");

        System.out.print("Digite o primeiro n√∫mero: ");
        int n1 = leia.nextInt();
        System.out.print("Digite o segundo n√∫mero: ");
        int n2 = leia.nextInt();

        System.out.println("Soma = " + calcular((a, b) -> a + b, n1, n2));
        System.out.println("Subtra√ß√£o = " + calcular((a, b) -> a - b, n1, n2));
        System.out.println("Multiplica√ß√£o = " + calcular((a, b) -> a * b, n1, n2));
        System.out.println("Divis√£o = " + calcular((a, b) -> a / b, n1, n2));

        leia.close();
    }
}
```

Observe no exemplo acima que foi criado o m√©todo **`calcular`**, o qual recebe **tr√™s par√¢metros**:

- Um **objeto da interface `OperacaoMatematica`**, que ser√° representado por uma **Express√£o Lambda**. Essa express√£o define dinamicamente qual opera√ß√£o matem√°tica ser√° executada (como soma, subtra√ß√£o, multiplica√ß√£o ou divis√£o) e ser√° internamente aplicada por meio do m√©todo **`executar()`**, definido na interface funcional.
- Dois **valores inteiros** (`numero1` e `numero2`), que correspondem aos operandos sobre os quais a opera√ß√£o ser√° aplicada.

Com essa estrutura, a Express√£o Lambda pode ser passada diretamente como argumento para o m√©todo `calcular`, permitindo que diferentes opera√ß√µes sejam executadas de forma **flex√≠vel e reutiliz√°vel**, **sem a necessidade de criar m√∫ltiplos m√©todos espec√≠ficos** para cada tipo de c√°lculo.

Ap√≥s a entrada dos dados pelo teclado, observe a linha que executa a opera√ß√£o de soma:

```java
System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
```

Note que, na chamada do m√©todo **`calcular`**, o primeiro par√¢metro √© uma **Express√£o Lambda** que representa a opera√ß√£o de soma. Essa express√£o √© enviada como argumento e ser√° associada ao m√©todo **`executar()`** da interface funcional `OperacaoMatematica`.

```java
//Express√£o Lambda
(a,b) -> a + b
```

Na sequ√™ncia foram inseridos os 2 n√∫meros inteiros recebidos via teclado, que substituir√£o os par√¢metros a e b na Express√£o Lambda, efetuando a soma dos dois n√∫meros.

As demais Opera√ß√µes seguem a mesma linha de racioc√≠nio.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
****************************************************
              Calculadora com Lambda                
****************************************************
Digite o primeiro numero: 
10
Digite o segundo numero: 
5
Soma = 15
Subtra√ß√£o = 5
Multiplica√ß√£o = 50
Divis√£o = 2
```

<br />

Por fim, √© fundamental destacar que, ao contr√°rio das fun√ß√µes tradicionais ‚Äî que s√£o definidas com nome e corpo dentro de classes ‚Äî as **Express√µes Lambda em Java dependem diretamente de interfaces funcionais para sua utiliza√ß√£o**. Elas n√£o existem isoladamente e s√≥ podem ser aplicadas quando associadas a uma interface funcional, isto √©, uma interface que define exatamente um m√©todo abstrato.

Essa associa√ß√£o √© essencial para que o compilador consiga identificar qual m√©todo ser√° implementado pela Express√£o Lambda, garantindo que o comportamento desejado seja corretamente executado.

Sem a exist√™ncia de uma interface funcional como contexto, a Express√£o Lambda perde seu significado e n√£o pode ser utilizada. Essa caracter√≠stica confere ao uso de lambdas um equil√≠brio entre **flexibilidade** e **seguran√ßa**, permitindo definir comportamentos de forma concisa e clara, sem ambiguidade na implementa√ß√£o.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 08 - Express√µes Lambda + Optional



Para finalizar, vamos converter o **Exemplo 03** do conte√∫do sobre <a href="19.md">Optional</a>, que trata da consulta de cliente por e-mail, para utilizar **Express√µes Lambda**.

Essa adapta√ß√£o tornar√° o c√≥digo mais conciso, expressivo e alinhado ao paradigma funcional introduzido no Java 8, aproveitando os recursos do `Optional` em conjunto com as lambdas para manipula√ß√£o segura e elegante dos dados.

**Classe Cliente**

```java
package exemplos_lambda;

public class Cliente {

    private String nome;
    private String email;

    public Cliente(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    public String getNome() {
        return nome;
    }

    public String getEmail() {
        return email;
    }

	public void setNome(String nome) {
		this.nome = nome;
	}

	public void setEmail(String email) {
		this.email = email;
	}
    
	public void visualizar() {
    	System.out.println("\n=========================================");
    	System.out.println("Dados do Cliente");
    	System.out.println("=========================================");
    	System.out.printf("Nome do cliente: %s%n", this.nome);
    	System.out.printf("E-mail do cliente: %s%n", this.email);
    }
	
}
```

**Classe Exemplo09 (classe principal)**

```java
package exemplos_lambda;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class Exemplo09 {

    private static List<Cliente> listaClientes = new ArrayList<>();

    public static void main(String[] args) {

        // Simula cadastro de clientes
        listaClientes.add(new Cliente("Bruna Silva", "bruna@email.com"));
        listaClientes.add(new Cliente("Maria Oliveira", "maria@email.com"));

        // Teste com e-mail existente
        buscarCliente("bruna@email.com");

        // Teste com e-mail inexistente
        buscarCliente("cliente@naoexiste.com");
    }

    public static void buscarCliente(String email) {
        String mensagem = buscarClientePorEmail(email)
            .map(cliente -> "‚úÖ Cliente encontrado: " + cliente.getNome())
            .orElse("‚ùå Cliente com e-mail '" + email + "' n√£o foi encontrado.");

        System.out.println(mensagem);
    }

    public static Optional<Cliente> buscarClientePorEmail(String email) {
        for (Cliente cliente : listaClientes) {
            if (cliente.getEmail().equalsIgnoreCase(email)) {
                return Optional.of(cliente);
            }
        }
        return Optional.empty();
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```java
‚úÖ Cliente encontrado: Bruna Silva
‚ùå Cliente com e-mail 'cliente@naoexiste.com' n√£o foi encontrado.
```

O c√≥digo apresentado demonstra de forma pr√°tica o uso da classe `Optional` em conjunto com Express√µes Lambda, com o objetivo de tornar o tratamento de valores nulos mais seguro e elegante. 

A classe `Exemplo09` simula um cadastro de clientes e permite a busca por e-mail. O m√©todo `buscarClientePorEmail` percorre a lista de clientes e retorna um `Optional<Cliente>`: 

- Caso o e-mail seja encontrado, retorna o cliente encapsulado em um `Optional.of(...)`; 
- Caso contr√°rio, retorna um `Optional.empty()`.

O destaque est√° no m√©todo `buscarCliente`, onde ocorre o uso de **Express√µes Lambda com Optional**. 

O m√©todo `map` √© utilizado para transformar o `Cliente` encontrado em uma mensagem personalizada com o nome do cliente. Caso o cliente n√£o seja encontrado, o m√©todo `orElse` fornece uma mensagem padr√£o informando que o e-mail n√£o foi localizado. Essa abordagem reduz a necessidade de condicionais expl√≠citas (if/else), tornando o c√≥digo mais fluido, expressivo e menos propenso a erros de `NullPointerException`. O uso conjunto de `Optional`, `map` e `orElse` exemplifica uma pr√°tica moderna e recomendada para lidar com valores opcionais em Java.

A classe Cliente n√£o sofreu nenhuma modifica√ß√£o.

> [!TIP]
>
> Sempre prefira **Express√µes Lambda** quando **precisar passar comportamentos simples como argumentos**, mas opte por **m√©todos nomeados** em **situa√ß√µes complexas ou com m√∫ltiplas responsabilidades**.

<br />

------

## üîë**Pontos chave:**

1. **Paradigma Imperativo:** baseado em instru√ß√µes sequenciais que alteram o estado do programa. Foco em *como* resolver o problema.
2. **Paradigma Orientado a Objetos:** organiza o c√≥digo em objetos com atributos e m√©todos. Usa conceitos como heran√ßa, polimorfismo e encapsulamento.
3. **Paradigma Funcional:** inspirado na matem√°tica, usa fun√ß√µes puras, dados imut√°veis e evita efeitos colaterais. O foco est√° em *o que* deve ser feito.
4. **Express√£o Lambda:** √© uma fun√ß√£o an√¥nima que pode ser usada como argumento de m√©todos, permitindo escrever c√≥digo mais conciso e funcional.
5. **Interface Funcional:** possui apenas um m√©todo abstrato e √© obrigat√≥ria para o uso de lambdas em Java. A lambda s√≥ pode ser usada quando o tipo esperado √© uma Interface Funcional.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
