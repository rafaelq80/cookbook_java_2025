<h1>Expressões Lambda</h1>



Antes de abordarmos as **Expressões Lambda**, é importante compreender o conceito de **Programação Funcional**.

<br />

<h2>1. Programação Funcional</h2>



O **paradigma da Programação Funcional** é um estilo de desenvolvimento que se baseia na definição e na composição de funções, com forte ênfase na **imutabilidade** dos dados e na **ausência de efeitos colaterais**. Nesse modelo, a computação é tratada como a avaliação de funções matemáticas, evitando-se o uso de estados mutáveis e o compartilhamento de dados entre diferentes partes do sistema.

> **Paradigma de programação** refere-se a um estilo ou modelo de escrita de programas de computador, fundamentado em princípios, conceitos e técnicas que orientam como o código é estruturado, organizado e executado.

Entre as principais características da Programação Funcional, destacam-se:

- **Composição de funções**: consiste em construir funções mais complexas a partir da combinação de outras funções menores e reutilizáveis.
- **Funções puras**: funções que, ao receber os mesmos argumentos, sempre retornam o mesmo resultado, sem causar efeitos colaterais — ou seja, sem modificar variáveis externas nem acessar estados compartilhados.
- **Imutabilidade**: os dados, uma vez definidos, não podem ser alterados. Em vez de modificar um valor ou objeto existente, cria-se uma nova versão com os dados atualizados.

A Programação Funcional tem suas raízes na matemática e busca promover soluções elegantes, concisas e robustas, especialmente úteis em sistemas complexos e altamente abstratos.

Esse paradigma fundamenta-se em um modelo teórico conhecido como **Cálculo Lambda**, desenvolvido por *Alonzo Church* na década de 1930, com o objetivo de formalizar conceitos como **função**, **aplicação** e **recursão**.

O **Cálculo Lambda** define um sistema computacional baseado exclusivamente em funções anônimas e na aplicação de argumentos, sem o uso de variáveis mutáveis ou estruturas imperativas de controle, como laços e condicionais tradicionais.

Essa base teórica influenciou diversas linguagens de programação modernas e serviu de alicerce para a criação das **Expressões Lambda** — uma forma prática e moderna de aplicar os princípios da programação funcional.

Em linguagens de alto nível como **Java**, as Expressões Lambda permitem representar funções como objetos, de forma concisa e direta, sem a necessidade de declarar classes ou métodos nomeados. Com isso, o Java aproxima-se do paradigma funcional e amplia significativamente seu poder expressivo.

<br />

<h2>2. Paradigmas de Programação - Linguagens de Alto Nível</h2>



Para compreender melhor o **paradigma da Programação Funcional**, é importante conhecer os principais paradigmas utilizados pelas linguagens de alto nível mais populares: **Programação Imperativa** e **Programação Orientada a Objetos (POO)**.

<div align="center"><img src="https://i.imgur.com/EtLQsSx.jpg" title="source: imgur.com" width="90%"/></div>

<br />

<h3>2.1. Programação Imperativa</h3>



A **Programação Imperativa** é um dos paradigmas mais antigos e amplamente adotados na história da computação. Ela se baseia na execução sequencial de instruções que alteram o estado interno do programa ao longo do tempo.

Nesse modelo, a pessoa desenvolvedora descreve **como** o problema deve ser resolvido, utilizando comandos explícitos, manipulação de variáveis, atribuições de valores, estruturas de repetição e condicionais. O foco está no controle do fluxo de execução e na alteração progressiva dos estados.

Linguagens como **C**, **Pascal** e **COBOL** são exemplos clássicos desse paradigma, frequentemente utilizadas em cenários que exigem desempenho e controle preciso sobre os recursos de hardware, como memória e processador.

<div align="center"><img src="https://i.imgur.com/7iY404h.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.2. Programação Orientada a Objetos</h3>



A **Programação Orientada a Objetos (POO)** é, atualmente, o paradigma mais amplamente utilizado no desenvolvimento de software. Baseia-se na abstração de entidades do mundo real por meio de **objetos**, que encapsulam **atributos** (estado) e **métodos** (comportamento).

Nesse modelo, a pessoa desenvolvedora descreve **o que** o programa deve fazer, organizando o código em **classes**, que servem como modelos para a criação de objetos. A POO promove princípios fundamentais como:

- **Encapsulamento**
- **Herança**
- **Polimorfismo**
- **Abstração**

Esses princípios favorecem a reutilização de código, a modularidade e a manutenção de sistemas de médio e grande porte.

Linguagens como **Java**, **C#** e **C++** são exemplos consolidados desse paradigma, aplicadas em projetos corporativos, aplicações desktop, web e sistemas embarcados.

<div align="center"><img src="https://i.imgur.com/FJVYTaz.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.3. E a Programação Funcional?</h3>



Diferentemente dos paradigmas Imperativo e Orientado a Objetos, a **Programação Funcional** adota a premissa de que **tudo é função**. Ao invés de estruturas sequenciais que alteram estados ou de modelagem baseada em objetos, esse paradigma constrói soluções por meio da **composição de funções matemáticas puras**, que recebem dados de entrada e retornam resultados sem provocar efeitos colaterais.

Nesse modelo, as funções não modificam os dados originais. A transformação ocorre exclusivamente por operações encadeadas. Isso garante que, dado o mesmo conjunto de entradas, a saída será sempre a mesma — promovendo previsibilidade, consistência e segurança.

Outro princípio essencial da programação funcional é a **imutabilidade**: os dados são tratados como constantes, e não como variáveis que sofrem alteração. Isso reduz erros causados por mudanças de estado inesperadas, facilitando o raciocínio sobre o comportamento do programa.

#### Vantagens da Programação Funcional:

- ✅ **Facilidade de testes e depuração**: funções puras são previsíveis e isoláveis, o que simplifica a escrita de testes unitários.
- ✅ **Concorrência e paralelismo mais seguros**: como não há compartilhamento de estado, diferentes partes do código podem ser executadas simultaneamente sem riscos de conflito.
- ✅ **Expressividade e legibilidade**: o estilo declarativo aproxima o código da descrição do problema, tornando-o mais direto e fácil de entender.

#### Desvantagens da Programação Funcional:

- ⚠️ **Curva de aprendizado**: conceitos como funções puras, imutabilidade e recursividade podem ser desafiadores para quem está habituado a paradigmas imperativos ou orientados a objetos.
- ⚠️ **Uso intensivo de memória**: devido à criação constante de novos objetos ao invés de modificações em estruturas existentes.
- ⚠️ **Menor suporte e integração em algumas plataformas**: por ser menos difundido, pode haver menos bibliotecas e ferramentas específicas em comparação com outros paradigmas.

Linguagens que seguem ou oferecem forte suporte ao paradigma funcional incluem: **Haskell**, **Clojure**, **Elixir**, entre outras. Linguagens multiparadigma como **Java**, **JavaScript**, **Python** e **Scala** também incorporam recursos funcionais, como expressões lambda, funções de ordem superior e imutabilidade.

<div align="center"><img src="https://i.imgur.com/fcUE3rV.png" title="source: imgur.com" width="80%"/></div>

<br />

<h2>3. Expressões Lambda</h2>



Uma **Expressão Lambda** é uma forma concisa de representar uma **função anônima** — ou seja, uma função **sem nome**, definida diretamente no corpo de um método. Ela pode receber parâmetros, executar uma lógica e retornar um resultado, funcionando de maneira similar a um método tradicional, porém **sem a necessidade de ser declarada dentro de uma classe**.

As Expressões Lambda foram introduzidas no **Java 8**, como parte da incorporação dos princípios da **Programação Funcional** à linguagem. Com esse recurso, foi possível escrever códigos mais **enxutos, legíveis e expressivos**, especialmente em situações que exigem o uso de **funções como parâmetros**, como em chamadas ao método `forEach()` e no uso da **Streams API**.

Essa adição aumentou significativamente a flexibilidade da linguagem, trazendo ganhos em produtividade e clareza, sobretudo em operações funcionais sobre coleções e em modelos de programação reativa.

**Sintaxe:**

```java
lista de parâmetros -> corpo da função
```

Uma **Expressão Lambda** é composta por três partes principais:

1. **Lista de Parâmetros**: Os argumentos da função, entre parênteses. Podem estar vazios ou conter um ou mais parâmetros, com ou sem o tipo explícito.
2. **Operador Lambda (`->`)**: Também conhecido como “seta”, separa os parâmetros do corpo da função.
3. **Corpo da Função**: A lógica a ser executada. Pode ser uma única expressão ou um bloco de instruções delimitado por chaves `{}`.

### ✅ Vantagens das Expressões Lambda em Java:

- Redução de **boilerplate** (código repetitivo e extenso);
- Aumento da **legibilidade**, principalmente ao trabalhar com coleções;
- Maior **aderência à Programação Funcional**, com foco em funções puras e imutabilidade.

Em resumo, as Expressões Lambda representam um avanço significativo na forma de escrever código em Java, promovendo uma abordagem mais **declarativa**, menos verbosa e alinhada aos **paradigmas funcionais modernos**.

<br />

<h3>3.1. Principais Características das Expressões Lambda</h3>



As **Expressões Lambda** em Java possuem uma sintaxe flexível e direta. Abaixo, destacamos suas principais características, com exemplos ilustrativos.

<br />

#### 1. **Declaração de tipo (opcional)**

O tipo dos parâmetros pode ser omitido, pois o compilador do Java consegue inferi-lo com base no contexto, especialmente quando usado com interfaces funcionais.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Expressões Lambda - Sem Tipo

```java
(a, b) -> a + b
```

Neste exemplo, os tipos de `a` e `b` são inferidos automaticamente.

<br />

#### 2. **Parênteses ao redor dos parâmetros**

- Os **parênteses são opcionais** quando há **apenas um parâmetro** e seu tipo não é declarado.
- Se houver **mais de um parâmetro**, os parênteses são **obrigatórios**.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - Expressões Lambda - Um Parâmetro

```java
a -> a * a
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Expressões Lambda - Dois Parâmetros

```java
(a, b) -> a + b
```

<br />

#### 3. **Uso de chaves no corpo da função**

- Quando o corpo da função contém apenas **uma única expressão**, as **chaves `{}` são opcionais**.
- Se houver **mais de uma instrução**, as chaves são **obrigatórias** para delimitar o bloco.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 04 - Expressões Lambda - Múltiplas Instruções

```java
n -> {
    int resultado = n * n;
    System.out.println("Resultado: " + resultado);
    return resultado;
}
```

<br />

#### 4. **Uso da palavra-chave `return`**

- Quando há apenas uma expressão no corpo da função, **o `return` é implícito** e pode ser omitido.
- Caso o corpo seja um **bloco com várias instruções**, o uso do `return` torna-se **necessário** para devolver o valor.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 05 - Expressões Lambda - Retorno Explícito

```java
n -> {
    int resultado = n * n;
    return resultado;
}
```

Essas características tornam as Expressões Lambda uma ferramenta poderosa para tornar o código **mais limpo, expressivo e funcional**, especialmente ao trabalhar com APIs como `Stream`, `Comparator`, `Runnable`, entre outras.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 06 - Expressões Lambda - Collections

Nesta primeira versão do código, não foram utilizadas as Expressões Lambda:

```java
package exemplos_lambda;

import java.util.Arrays;
import java.util.List;

public class Exemplo06 {
	
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista sem Expressão Lambda
		for(Integer n : numeros) {
			System.out.println(n);
		}

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados sem Expressão Lambda
		for(Integer n : numeros) {
			System.out.println(n + n);
		}

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista sem Expressão Lambda
		for(Integer n : numeros) {
			if(n%2 == 0)
			System.out.println(n);
		}
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 07 - Expressões Lambda - Collections

Na segunda versão do código, foram utilizadas as Expressões Lambda:

```java
package exemplos_lambda;

import java.util.Arrays;
import java.util.List;

public class Exemplo07 {
	
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista com Expressão Lambda
		numeros.forEach(n -> System.out.println(n));

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados com Expressão Lambda
		numeros.forEach(n -> System.out.println(n + n));

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista com Expressão Lambda
		numeros.forEach(n -> {
			if (n % 2 == 0)
				System.out.println(n);
		});
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

Observe que o **resultado foi o mesmo**, entretanto, no **Exemplo 07** utilizamos **Expressões Lambda**.

Ao comparar a primeira versão do código — escrita de forma tradicional — com a segunda versão, que utiliza Expressões Lambda, nota-se uma **redução significativa na verbosidade**. O código torna-se **mais direto, legível e enxuto**, o que favorece tanto a **clareza** quanto a **manutenção**.

Neste caso, as Expressões Lambda foram aplicadas no método **`forEach()`**, disponível na interface **`Iterable`** — a qual é implementada por estruturas de coleção como `List`, `Set`, entre outras. Esse método recebe como argumento uma **interface funcional**, especificamente a **`Consumer<T>`**, pertencente ao pacote `java.util.function`.

Por se tratar de uma interface funcional (ou seja, contendo **apenas um método abstrato**), `Consumer<T>` permite passar diretamente o comportamento desejado como uma **Expressão Lambda**. Com isso, elimina-se a necessidade de declarar classes anônimas ou métodos auxiliares, tornando o código mais **conciso**, **expressivo** e alinhado aos princípios da **Programação Funcional** incorporados ao Java a partir da versão 8.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank"><b>Documentação: Expressões Lambda</b></a></div>

<br />

<h2>4. Interfaces Funcionais</h2>



As **interfaces funcionais** são fundamentais na programação funcional em Java. Elas representam abstrações que possuem **apenas um único método abstrato**, sendo ideais para uso com **Expressões Lambda** ou **referências de método**. Por terem somente um método a ser implementado, o compilador pode associar diretamente uma função anônima a esse método, tornando o código mais simples e flexível.

Desde o Java 8, o pacote `java.util.function` fornece um conjunto robusto de interfaces funcionais pré-definidas, que atendem aos casos mais comuns — como transformação de dados, consumo de valores e validações.

Embora não seja obrigatório, é **altamente recomendável utilizar a anotação `@FunctionalInterface` ao definir interfaces funcionais personalizadas**. Essa anotação tem a função de instruir o compilador a validar se a interface segue corretamente o contrato de uma interface funcional, ou seja, se possui **exatamente um método abstrato**. Caso sejam adicionados dois ou mais métodos abstratos, o compilador emitirá um erro em tempo de compilação.

Essa prática é especialmente útil quando o desenvolvedor está criando suas **próprias interfaces funcionais**, que serão utilizadas com **Expressões Lambda** ou **referências de método**. O uso da anotação evita erros acidentais e torna a intenção do código mais clara, facilitando a leitura e a manutenção por outras pessoas da equipe.

Além disso, mesmo que as interfaces funcionais da API Java, como `Consumer`, `Predicate` e `Function`, já estejam corretamente configuradas para esse uso, ao criar **interfaces funcionais customizadas**, o uso da anotação `@FunctionalInterface` é uma **boa prática de programação** que contribui para a robustez e legibilidade do código.

<br />

<h3>4.1. Interfaces Funcionais Nativas</h3>



A biblioteca padrão do Java disponibiliza diversas interfaces funcionais no pacote `java.util.function`. A seguir, apresentamos as **seis principais interfaces funcionais**, amplamente utilizadas em aplicações modernas que fazem uso de **Streams**, **Collections**, **APIs reativas**, entre outras. Essas interfaces facilitam a programação funcional, permitindo maior expressividade e flexibilidade no tratamento de dados e comportamentos. Conheça as principais, na tabela abaixo:

| Interface            | Descrição                                                    |
| -------------------- | ------------------------------------------------------------ |
| **`Consumer<T>`**    | Representa uma operação que **recebe um parâmetro** e **não retorna resultado**. Muito usada com `forEach`, `peek` ou para executar ações em cada elemento. |
| **`Function<T, R>`** | Representa uma função que **recebe um argumento do tipo `T`** e **retorna um resultado do tipo `R`**.Usada frequentemente com métodos como `map()`. |
| **`Predicate<T>`**   | Representa uma expressão booleana que **testa uma condição sobre um valor do tipo `T`**.Comum em métodos como `filter()`. |
| **`Supplier<T>`**    | Fornece um valor do tipo `T` sem receber nenhum argumento. Utilizado quando é necessário gerar ou fornecer dados sob demanda. |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 07 - Expressões Lambda - Interfaces Funcionais



Neste exemplo, vamos desenvolver uma calculadora simples utilizando **Expressões Lambda**. Para isso, criaremos uma **Interface Funcional personalizada**, que servirá como base para representar operações matemáticas de maneira **flexível, reutilizável e coesa com o paradigma funcional**.

A interface será chamada **`OperacaoMatematica`** e definirá **um único método abstrato**, responsável por executar uma operação entre dois números inteiros. Por conter apenas um método abstrato, ela se enquadra como uma **interface funcional**, podendo ser usada diretamente com expressões lambda ou referências de método.

Com essa estrutura, será possível **passar as operações como parâmetros**, utilizando lambdas para definir comportamentos como soma, subtração, multiplicação e divisão, tornando o código mais **modular, legível e de fácil manutenção**.

**Interface OperacaoMatematica**

```java
package lambda;

@FunctionalInterface
public interface OperacaoMatematica {

	public int executar(int a, int b);

}
```

<br />

**Classe Calculadora**

```java
package exemplos_lambda;

import java.util.Scanner;

public class Exemplo08 {

    public static int calcular(OperacaoMatematica operacao, int numero1, int numero2) {
        return operacao.executar(numero1, numero2);
    }

    public static void main(String[] args) {
        Scanner leia = new Scanner(System.in);

        System.out.println("****************************************************");
        System.out.println("              Calculadora com Lambda                ");
        System.out.println("****************************************************");

        System.out.print("Digite o primeiro número: ");
        int n1 = leia.nextInt();
        System.out.print("Digite o segundo número: ");
        int n2 = leia.nextInt();

        System.out.println("Soma = " + calcular((a, b) -> a + b, n1, n2));
        System.out.println("Subtração = " + calcular((a, b) -> a - b, n1, n2));
        System.out.println("Multiplicação = " + calcular((a, b) -> a * b, n1, n2));
        System.out.println("Divisão = " + calcular((a, b) -> a / b, n1, n2));

        leia.close();
    }
}
```

Observe no exemplo acima que foi criado o método **`calcular`**, o qual recebe **três parâmetros**:

- Um **objeto da interface `OperacaoMatematica`**, que será representado por uma **Expressão Lambda**. Essa expressão define dinamicamente qual operação matemática será executada (como soma, subtração, multiplicação ou divisão) e será internamente aplicada por meio do método **`executar()`**, definido na interface funcional.
- Dois **valores inteiros** (`numero1` e `numero2`), que correspondem aos operandos sobre os quais a operação será aplicada.

Com essa estrutura, a Expressão Lambda pode ser passada diretamente como argumento para o método `calcular`, permitindo que diferentes operações sejam executadas de forma **flexível e reutilizável**, **sem a necessidade de criar múltiplos métodos específicos** para cada tipo de cálculo.

Após a entrada dos dados pelo teclado, observe a linha que executa a operação de soma:

```java
System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
```

Note que, na chamada do método **`calcular`**, o primeiro parâmetro é uma **Expressão Lambda** que representa a operação de soma. Essa expressão é enviada como argumento e será associada ao método **`executar()`** da interface funcional `OperacaoMatematica`.

```java
//Expressão Lambda
(a,b) -> a + b
```

Na sequência foram inseridos os 2 números inteiros recebidos via teclado, que substituirão os parâmetros a e b na Expressão Lambda, efetuando a soma dos dois números.

As demais Operações seguem a mesma linha de raciocínio.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
****************************************************
              Calculadora com Lambda                
****************************************************
Digite o primeiro numero: 
10
Digite o segundo numero: 
5
Soma = 15
Subtração = 5
Multiplicação = 50
Divisão = 2
```

<br />

Por fim, é fundamental destacar que, ao contrário das funções tradicionais — que são definidas com nome e corpo dentro de classes — as **Expressões Lambda em Java dependem diretamente de interfaces funcionais para sua utilização**. Elas não existem isoladamente e só podem ser aplicadas quando associadas a uma interface funcional, isto é, uma interface que define exatamente um método abstrato.

Essa associação é essencial para que o compilador consiga identificar qual método será implementado pela Expressão Lambda, garantindo que o comportamento desejado seja corretamente executado.

Sem a existência de uma interface funcional como contexto, a Expressão Lambda perde seu significado e não pode ser utilizada. Essa característica confere ao uso de lambdas um equilíbrio entre **flexibilidade** e **segurança**, permitindo definir comportamentos de forma concisa e clara, sem ambiguidade na implementação.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 08 - Expressões Lambda + Optional



Para finalizar, vamos converter o **Exemplo 03** do conteúdo sobre <a href="19.md">Optional</a>, que trata da consulta de cliente por e-mail, para utilizar **Expressões Lambda**.

Essa adaptação tornará o código mais conciso, expressivo e alinhado ao paradigma funcional introduzido no Java 8, aproveitando os recursos do `Optional` em conjunto com as lambdas para manipulação segura e elegante dos dados.

**Classe Cliente**

```java
package exemplos_lambda;

public class Cliente {

    private String nome;
    private String email;

    public Cliente(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    public String getNome() {
        return nome;
    }

    public String getEmail() {
        return email;
    }

	public void setNome(String nome) {
		this.nome = nome;
	}

	public void setEmail(String email) {
		this.email = email;
	}
    
	public void visualizar() {
    	System.out.println("\n=========================================");
    	System.out.println("Dados do Cliente");
    	System.out.println("=========================================");
    	System.out.printf("Nome do cliente: %s%n", this.nome);
    	System.out.printf("E-mail do cliente: %s%n", this.email);
    }
	
}
```

**Classe Exemplo09 (classe principal)**

```java
package exemplos_lambda;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class Exemplo09 {

    private static List<Cliente> listaClientes = new ArrayList<>();

    public static void main(String[] args) {

        // Simula cadastro de clientes
        listaClientes.add(new Cliente("Bruna Silva", "bruna@email.com"));
        listaClientes.add(new Cliente("Maria Oliveira", "maria@email.com"));

        // Teste com e-mail existente
        buscarCliente("bruna@email.com");

        // Teste com e-mail inexistente
        buscarCliente("cliente@naoexiste.com");
    }

    public static void buscarCliente(String email) {
        String mensagem = buscarClientePorEmail(email)
            .map(cliente -> "✅ Cliente encontrado: " + cliente.getNome())
            .orElse("❌ Cliente com e-mail '" + email + "' não foi encontrado.");

        System.out.println(mensagem);
    }

    public static Optional<Cliente> buscarClientePorEmail(String email) {
        for (Cliente cliente : listaClientes) {
            if (cliente.getEmail().equalsIgnoreCase(email)) {
                return Optional.of(cliente);
            }
        }
        return Optional.empty();
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```java
✅ Cliente encontrado: Bruna Silva
❌ Cliente com e-mail 'cliente@naoexiste.com' não foi encontrado.
```

O código apresentado demonstra de forma prática o uso da classe `Optional` em conjunto com Expressões Lambda, com o objetivo de tornar o tratamento de valores nulos mais seguro e elegante. 

A classe `Exemplo09` simula um cadastro de clientes e permite a busca por e-mail. O método `buscarClientePorEmail` percorre a lista de clientes e retorna um `Optional<Cliente>`: 

- Caso o e-mail seja encontrado, retorna o cliente encapsulado em um `Optional.of(...)`; 
- Caso contrário, retorna um `Optional.empty()`.

O destaque está no método `buscarCliente`, onde ocorre o uso de **Expressões Lambda com Optional**. 

O método `map` é utilizado para transformar o `Cliente` encontrado em uma mensagem personalizada com o nome do cliente. Caso o cliente não seja encontrado, o método `orElse` fornece uma mensagem padrão informando que o e-mail não foi localizado. Essa abordagem reduz a necessidade de condicionais explícitas (if/else), tornando o código mais fluido, expressivo e menos propenso a erros de `NullPointerException`. O uso conjunto de `Optional`, `map` e `orElse` exemplifica uma prática moderna e recomendada para lidar com valores opcionais em Java.

A classe Cliente não sofreu nenhuma modificação.

> [!TIP]
>
> Sempre prefira **Expressões Lambda** quando **precisar passar comportamentos simples como argumentos**, mas opte por **métodos nomeados** em **situações complexas ou com múltiplas responsabilidades**.

<br />

------

## 🔑**Pontos chave:**

1. **Paradigma Imperativo:** baseado em instruções sequenciais que alteram o estado do programa. Foco em *como* resolver o problema.
2. **Paradigma Orientado a Objetos:** organiza o código em objetos com atributos e métodos. Usa conceitos como herança, polimorfismo e encapsulamento.
3. **Paradigma Funcional:** inspirado na matemática, usa funções puras, dados imutáveis e evita efeitos colaterais. O foco está em *o que* deve ser feito.
4. **Expressão Lambda:** é uma função anônima que pode ser usada como argumento de métodos, permitindo escrever código mais conciso e funcional.
5. **Interface Funcional:** possui apenas um método abstrato e é obrigatória para o uso de lambdas em Java. A lambda só pode ser usada quando o tipo esperado é uma Interface Funcional.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
