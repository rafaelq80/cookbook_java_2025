<h1>Stream</h1>



A **API Stream** foi introduzida no Java 8 e √© amplamente utilizada para o **processamento de cole√ß√µes de dados** (como listas e conjuntos). Essa API permite operar sobre dados de forma mais **concisa, leg√≠vel e declarativa**, facilitando a manuten√ß√£o do c√≥digo e reduzindo a ocorr√™ncia de erros comuns de itera√ß√£o.

Uma **Stream** representa uma **sequ√™ncia de elementos** que podem ser processados em cadeia por meio de **opera√ß√µes intermedi√°rias e terminais**, como filtragem, ordena√ß√£o ou transforma√ß√£o. Diferentemente das cole√ß√µes, **Streams n√£o armazenam dados**, apenas **processam dados provenientes de uma estrutura de origem**, como uma `Collection` ou um array.

Esse modelo de processamento foi viabilizado pelo uso do **paradigma funcional** em conjunto com **express√µes lambda**, permitindo que se percorra cada elemento da cole√ß√£o e se aplique transforma√ß√µes com mais fluidez.

> **Paradigma Funcional:** Diferentemente da programa√ß√£o imperativa, que se baseia em sequ√™ncias de comandos, a programa√ß√£o funcional se apoia em **fun√ß√µes puras**, que recebem dados, executam opera√ß√µes e retornam resultados sem alterar os dados originais.
>
> **Express√£o Lambda:** √â uma forma concisa de representar uma fun√ß√£o an√¥nima. Recebe par√¢metros, executa uma opera√ß√£o e retorna um valor, sem a necessidade de nomear ou estruturar a fun√ß√£o como um m√©todo tradicional.

<br />

<h3>1.1. Funcionamento do Pipeline</h3>



O pipeline de uma Stream consiste em uma cadeia de opera√ß√µes encadeadas, divididas em dois tipos:

- **Opera√ß√µes Intermedi√°rias:** Retornam uma nova Stream e s√£o **pregui√ßosas**, ou seja, s√≥ s√£o executadas quando uma opera√ß√£o terminal for invocada. 
- **Opera√ß√µes Terminais:** Executam o processamento da Stream e **encerram** seu uso. Ap√≥s sua execu√ß√£o, a Stream √© considerada **consumida** e n√£o pode ser reutilizada. 

Veja o fluxo na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yHxtqpT.png" title="source: imgur.com" /></div>

Onde:

### üîÅ **1. Collection de entrada**

- √â a **estrutura de dados de origem** (`List`, `Set`, `Queue`, entre outras).
- Cont√©m os elementos a serem processados.

### üîÑ **2. Stream**

- A **Stream √© gerada** a partir da Collection com `stream()`.
- N√£o armazena dados; apenas **transmite e processa os elementos** da Collection.
- Composta pelas Opera√ß√µes Intermedi√°rias e Opera√ß√£o Terminal.

### üß© **3. Opera√ß√µes Intermedi√°rias**

- M√©todos que **transformam ou filtram** os dados.
- S√£o **pregui√ßosas**: n√£o executam at√© que a opera√ß√£o terminal seja chamada.
- **Retornam uma nova Stream**.

### ‚úÖ **4. Opera√ß√£o Terminal**

- **Finaliza o pipeline** e **executa o processamento**.
- Ap√≥s essa etapa, a Stream √© **consumida** e n√£o pode ser reutilizada.

### üéØ **5. Resultado**

- Pode ser:
  - Um **novo valor** (soma, m√©dia, entre outras),
  - Uma **nova Collection** (`List`, `Set`, entre outras),
  - Ou apenas uma **a√ß√£o executada** (impress√£o no console).

<br />

<h3>1.1. Streams vs Collections</h3>



Embora **Streams** e **Collections** lidem com conjuntos de elementos, o foco e o comportamento de cada uma s√£o distintos:

<div align="center"><h2>"Collections representam dados, Streams representam os resultados de opera√ß√µes realizadas sobre esses dados."</h2></div>

A principal diferen√ßa est√° no momento e na forma como os dados s√£o manipulados:

- **Collections** armazenam elementos em mem√≥ria e os disponibilizam imediatamente. Exigem **itera√ß√£o externa**, normalmente com estruturas como `for-each`.
- **Streams** n√£o armazenam os dados. Elas processam os elementos **sob demanda** por meio de **itera√ß√£o interna**, onde a API se encarrega de aplicar as transforma√ß√µes, geralmente com uso de express√µes lambda.

> **Itera√ß√£o Externa** √© o modelo tradicional de itera√ß√£o, onde a **pessoa desenvolvedora controla explicitamente o fluxo de repeti√ß√£o**. Isso √© feito por meio de estruturas como `for`, `while` ou `for-each`. Nesse caso, √© necess√°rio gerenciar manualmente o acesso aos elementos da cole√ß√£o e a l√≥gica de processamento.
>
> **Itera√ß√£o Interna**, por outro lado, √© aquela **gerenciada automaticamente pela API Stream**, que se encarrega de percorrer os elementos e aplicar as opera√ß√µes definidas, como `filter`, `map` ou `forEach`. A pessoa desenvolvedora apenas informa o **que deve ser feito**, e n√£o **como percorrer** os dados.

‚úÖ **Pontos importantes sobre Streams:**

- N√£o s√£o estruturas de dados.
- N√£o modificam a cole√ß√£o de origem.
- S√£o consum√≠veis (n√£o reutiliz√°veis).
- Suportam processamento sequencial e paralelo.
- S√£o ideais para processamento funcional e pipelines de dados.

<br />

## üÜö Tabela Comparativa: Streams vs Collections

| **Streams**                                                  | **Collections**                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| N√£o armazenam dados; apenas operam sobre dados existentes.   | Armazenam os dados em estruturas como `List`, `Set`, entre outras. |
| Utilizam **express√µes lambda** e **interfaces funcionais**, promovendo um estilo funcional. | Usam abordagem imperativa, sem depend√™ncia de lambdas.       |
| **Consum√≠veis** ‚Äì ap√≥s uma opera√ß√£o terminal, a Stream n√£o pode ser reutilizada. | **Reutiliz√°veis** ‚Äì podem ser percorridas m√∫ltiplas vezes.   |
| Suportam processamento **sequencial e paralelo** com facilidade. | Suportam paralelismo, mas com menos flexibilidade.           |
| N√£o permitem modifica√ß√£o direta dos elementos.               | Permitem adicionar, remover ou alterar elementos.            |
| Utilizam **itera√ß√£o interna** (a API gerencia o processamento). | Requerem **itera√ß√£o externa** (controle manual pelo desenvolvedor). |

<br />

> **Processamento Sequencial:** As opera√ß√µes s√£o executadas uma ap√≥s a outra, seguindo a ordem do pipeline.
>
> **Processamento Paralelo:** As opera√ß√µes s√£o divididas em tarefas que rodam simultaneamente, aproveitando m√∫ltiplos n√∫cleos do processador. Ideal para grandes volumes de dados e quando a ordem n√£o √© essencial.

<br />

**Sintaxe:**

```java
// Criar uma Collection com valores inteiros
List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Gerar uma Stream a partir da Collection
Stream<Integer> stream1 = numeros.stream();

// Gerar uma Stream diretamente com valores
Stream<Integer> stream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
```

Em ambos os casos, √© criado um objeto do tipo `Stream<Integer>`. No primeiro exemplo, usamos o m√©todo `stream()` da interface `Collection`; no segundo, usamos o m√©todo est√°tico `Stream.of()` da pr√≥pria classe `Stream`.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.oracle.com/br/technical-resources/articles/java-stream-api.html" target="_blank"><b>Artigo: Java 8: Iniciando o desenvolvimento com a Streams API</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank"><b>Documenta√ß√£o: Stream API</b></a></div>

<br />


<h2>2. M√©todos Intermedi√°rios</h2>



Os **m√©todos intermedi√°rios** (ou **opera√ß√µes intermedi√°rias**) da API Stream s√£o respons√°veis por **transformar ou filtrar os elementos** de uma Stream. Cada opera√ß√£o intermedi√°ria **retorna uma nova Stream**, permitindo o **encadeamento fluente** de m√∫ltiplas opera√ß√µes em sequ√™ncia.

Esses m√©todos **n√£o modificam a estrutura original de dados** nem executam processamento imediatamente. Na verdade, eles s√£o **pregui√ßosos (lazy)**: sua execu√ß√£o s√≥ ocorre quando uma **opera√ß√£o terminal** for invocada. Isso permite otimiza√ß√µes internas e maior efici√™ncia no processamento.

> ‚úÖ **Resumo:** m√©todos intermedi√°rios permitem montar um pipeline de opera√ß√µes, sem alterar os dados de origem, e s√≥ s√£o executados quando a Stream for consumida por uma opera√ß√£o terminal.

<br />

<h3>2.1. Map</h3>



O m√©todo **`map()`** √© utilizado para aplicar uma transforma√ß√£o a cada elemento de uma Stream, gerando uma **nova Stream** com os elementos modificados. Essa opera√ß√£o √© fundamental para converter ou modificar os dados sem alterar a cole√ß√£o original.

A seguir, um exemplo de uso do `map()` para criar uma nova lista com os n√∫meros da cole√ß√£o original **elevados ao cubo**:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01 - M√©todo Map

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo01 {

	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		System.out.println("\nExemplo - M√©todo Map");

		List<Integer> numerosAoCubo = numeros.stream()
					.map(n -> (int) Math.pow(n, 3))
					.collect(Collectors.toList());

		System.out.println("\nNumeros elevados ao Cubo: " + numerosAoCubo);

	}

}
```

No c√≥digo acima, foi passada como par√¢metro do m√©todo **`map()`** a **express√£o lambda**:

```java
n -> (int) Math.pow(n, 3)
```

Essa express√£o calcula a **pot√™ncia c√∫bica** de cada elemento (ou seja, eleva ao cubo) e converte o resultado para um n√∫mero inteiro. O par√¢metro `n` √© o n√∫mero atual que est√° sendo processado.

Em seguida, utilizamos o **m√©todo terminal `collect()`** para **converter a Stream em uma nova cole√ß√£o**, neste caso, uma lista (`List`). No exemplo, a Stream dos n√∫meros elevados ao cubo √© coletada em uma lista chamada **`numerosAoCubo`**.

Note que o par√¢metro do m√©todo `collect()` √© o **`Collectors.toList()`**, que transforma a Stream em uma cole√ß√£o do tipo `List`.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Map

N√∫meros elevados ao Cubo: [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
```

<br />

<h3>2.2. Filter</h3>



O m√©todo **`filter()`** √© utilizado para **filtrar elementos** de uma Stream com base em uma **condi√ß√£o espec√≠fica**. Ele retorna uma nova **Stream** contendo apenas os elementos que satisfazem essa condi√ß√£o.

A seguir, um exemplo de uso do `filter()` para **selecionar apenas os n√∫meros pares** de uma lista que vai de 1 a 10:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 02 - M√©todo Filter

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo02 {

	public static void main(String[] args) {
		
		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
System.out.println("\nExemplo - M√©todo Filter");
		
		List<Integer> numerosPares = numeros.stream()
		        .filter(n -> n%2==0)
		        .collect(Collectors.toList());

		 System.out.println("\nExibir apenas os N√∫meros Pares: " + numerosPares);

	}

}
```

No c√≥digo acima, foi passada como par√¢metro do m√©todo **`filter()`** a **express√£o lambda**:

```java
n -> n % 2 == 0
```

Essa express√£o calcula o **resto da divis√£o por 2** de cada elemento da cole√ß√£o `numeros` e verifica se o resultado √© igual a zero. Isso indica que o n√∫mero √© par, pois n√∫meros pares t√™m resto zero na divis√£o por 2. O par√¢metro `n` √© o n√∫mero atual que est√° sendo processado.

Em seguida, utilizamos o m√©todo terminal **`collect()`** para converter a Stream em uma nova cole√ß√£o chamada **`numerosPares`**. Note que o par√¢metro passado para `collect()` foi o m√©todo **`Collectors.toList()`**, que converte a Stream em uma cole√ß√£o do tipo `List`.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Filter

Exibir apenas os N√∫meros Pares: [2, 4, 6, 8, 10]
```

<br />

<h3>2.3. Sorted</h3>



O m√©todo **`sorted()`** √© utilizado para **ordenar os elementos** de uma Stream. Por padr√£o, ele ordena em **ordem crescente**, mas tamb√©m pode receber um **comparador personalizado** para definir uma ordena√ß√£o diferente, como a ordem decrescente.

A seguir, um exemplo de como ordenar uma cole√ß√£o de n√∫meros inteiros desordenados em **ordem crescente** e **ordem decrescente** usando o m√©todo **`sorted()`**:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 03 -  M√©todo Sorted

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo03 {

	public static void main(String[] args) {

		List<Integer> numerosNaoOrdenados = Arrays.asList(6,7,8,1,4,5,9,10,2,3);

		System.out.println("\nExemplo - M√©todo Sorted");
		 
		 List<Integer> numerosOrdenadosAsc = numerosNaoOrdenados.stream()
				 .sorted()
				 .collect(Collectors.toList());

		 System.out.println("\nExibir os N√∫meros em Ordem Crescente: " + numerosOrdenadosAsc);
		 
		 List<Integer> numerosOrdenadosDesc = numerosNaoOrdenados.stream()
				 .sorted(Comparator.reverseOrder())
				 .collect(Collectors.toList());

		 System.out.println("\nExibir os N√∫meros em Ordem Decrescente: " + numerosOrdenadosDesc);
		 
	}

}
```

No c√≥digo acima, utilizamos o m√©todo **`sorted()`**, que, por padr√£o, **ordena os elementos em ordem crescente**. Para realizar a ordena√ß√£o em **ordem decrescente**, passamos como par√¢metro o m√©todo **`Comparator.reverseOrder()`**, que **inverte a ordem natural dos elementos**.

<br />

> **Comparator** √© uma **interface funcional** da API Java utilizada para comparar objetos e definir crit√©rios de ordena√ß√£o (crescente ou decrescente).
>
> √â amplamente utilizada para **personalizar a ordena√ß√£o de elementos em cole√ß√µes**, comparando dois objetos da mesma classe e determinando sua ordem com base em regras espec√≠ficas.
>
> #### Exemplos de M√©todos do **Comparator**:
>
> - **`Comparator.reverseOrder()`** ‚Äì Ordena os elementos em **ordem decrescente**, invertendo a ordem natural.
> - **`Comparator.naturalOrder()`** ‚Äì Ordena os elementos em **ordem crescente**, seguindo sua ordem natural (por exemplo, crescente para n√∫meros e ordem alfab√©tica para strings).
>
> Quando usado sem argumentos, o m√©todo `sorted()` aplica a ordena√ß√£o natural dos elementos, equivalente a `Comparator.naturalOrder()`.
>
> <br />
>
> <div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank"><b>Documenta√ß√£o: Interface Comparator</b></a>
>
> <br />

Ap√≥s aplicar a ordena√ß√£o, utilizamos o m√©todo terminal **`collect()`** para **converter as duas Streams** em novas cole√ß√µes do tipo `List`, chamadas **`numerosOrdenadosAsc`** (ordem crescente) e **`numerosOrdenadosDesc`** (ordem decrescente), respectivamente.

O resultado do algoritmo ser√°:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Sorted

Exibir os N√∫meros em Ordem Crescente: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Exibir os N√∫meros em Ordem Decrescente: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

<br />

<h3>2.4. Distinct</h3>



O m√©todo **`distinct()`** √© utilizado para **eliminar elementos duplicados** de uma **Stream**, garantindo que a cole√ß√£o resultante contenha apenas **valores √∫nicos**. Esse recurso √© especialmente √∫til quando se deseja **evitar repeti√ß√µes** em listas ou cole√ß√µes de dados.

No exemplo a seguir, vamos utilizar o m√©todo **`distinct()`** para **remover nomes de estados repetidos**, mantendo apenas uma ocorr√™ncia de cada elemento na lista:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 04 - M√©todo Distinct

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo04 {

	public static void main(String[] args) {

		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais",
			    "Espirito Santo", 
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "S√£o Paulo", 
			    "Rio de Janeiro"
			);
		
		System.out.println("\nExemplo - M√©todo Distinct");
		 
		 List<String> estadosSemRepeticao = estados.stream()
				 .distinct()
				 .collect(Collectors.toList());
				     
		 System.out.println("\nExibir os Estados sem repeti√ß√£o: " + estadosSemRepeticao);

	}

}
```

No c√≥digo acima, utilizamos o m√©todo **`distinct()`**, que √© respons√°vel por **remover elementos duplicados** da Stream, resultando em uma sequ√™ncia com **valores √∫nicos**.

Em seguida, aplicamos o M√©todo Terminal **`collect()`** para **converter a Stream em uma nova Collection**, chamada **`estadosSemRepeticao`**, que armazena os dados sem repeti√ß√µes. O resultado final do algoritmo pode ser visualizado abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Distinct

Exibir os Estados sem repeti√ß√£o: [S√£o Paulo, Rio de Janeiro, Minas Gerais, Espirito Santo]
```

<br />

<h3>2.5. Limit</h3>



O m√©todo **`limit(n)`** √© utilizado para **retornar apenas os primeiros `n` elementos** de uma Stream. Ele √© especialmente √∫til quando se deseja **reduzir o volume de dados processados** ou **extrair uma amostra dos elementos** de uma cole√ß√£o original.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 05 - M√©todo Limit

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo05 {

	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		System.out.println("\nExemplo - M√©todo Limit");

		List<Integer> primeirosCinco = numeros.stream()
		    .limit(5)
		    .collect(Collectors.toList());

		System.out.println("\nOs 5 primeiros n√∫meros: " + primeirosCinco);

	}

}
```

No c√≥digo acima, a opera√ß√£o **`limit(5)`** restringe a Stream para conter apenas os **cinco primeiros elementos** da lista `numeros`. Em seguida, essa Stream √© **coletada** e transformada em uma nova lista chamada **`primeirosCinco`**, contendo apenas os elementos selecionados.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Exemplo - M√©todo Limit

Os 5 primeiros n√∫meros: [1, 2, 3, 4, 5]
```

<br />

<h3>2.6. Skip</h3>



O m√©todo **`skip(n)`** √© utilizado para **ignorar os `n` primeiros elementos** de uma Stream, retornando apenas os elementos **restantes**. Essa opera√ß√£o √© √∫til quando se deseja **descartar uma parte inicial da cole√ß√£o** e continuar o processamento a partir de um ponto espec√≠fico.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 06 - M√©todo Skip

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo06 {

	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		System.out.println("\nExemplo - M√©todo Skip");

		List<Integer> ignorarCinco = numeros.stream()
		    .skip(5)
		    .collect(Collectors.toList());

		System.out.println("\nIgnorar os 5 primeiros n√∫meros: " + ignorarCinco);

	}

}
```

Neste exemplo, o m√©todo **`skip(5)`** √© utilizado para **descartar os cinco primeiros elementos** da lista `numeros`. A opera√ß√£o resulta em uma nova Stream contendo apenas os elementos **a partir do sexto item**, que s√£o ent√£o coletados na lista `ignorarCinco`.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Exemplo - M√©todo Skip

Ignorar os 5 primeiros n√∫meros: [6, 7, 8, 9, 10]
```

<br />

<h2>3. M√©todos Terminais</h2>



Os **m√©todos terminais** (ou **opera√ß√µes terminais**) s√£o respons√°veis por **encerrar o fluxo de opera√ß√µes** de uma Stream. Eles **produzem um resultado final**, que pode ser um valor, uma cole√ß√£o ou outra estrutura, e, a partir desse ponto, a Stream √© considerada **consumida** ‚Äî ou seja, **n√£o pode mais ser reutilizada** para outras opera√ß√µes. 

Esses m√©todos marcam o fim do pipeline e s√£o essenciais para que as transforma√ß√µes definidas na Stream sejam realmente executadas.

<br />

<h3>3.1. Collect</h3>



Como demonstrado nos exemplos anteriores, a opera√ß√£o **`collect()`** √© um dos m√©todos terminais **mais comuns e poderosos**. Ela serve para **agrupar** ou **acumular os elementos processados por uma Stream** em uma nova estrutura de dados, como uma **`List`**, **`Set`** ou **`Map`**.

No exemplo a seguir, combinamos diversas opera√ß√µes intermedi√°rias e, ao final, utilizamos o m√©todo **`collect()`** para armazenar o resultado em uma nova **lista**:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 07 - M√©todo Collect

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Exemplo07 {

	public static void main(String[] args) {

		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "Espirito Santo", 
			    "Rio Grande do Sul", 
			    "Santa Catarina", 
			    "Paran√°"
			);
		
		System.out.println("\nExemplo - M√©todo Terminal Collect");
		
		List <String> estadosIniciadosEmR = estados.stream()
		        .filter(e-> e.startsWith("R"))
		        .sorted()
		        .collect(Collectors.toList());

		System.out.println("\nEstados cujo nome come√ßam com a letra R: " + estadosIniciadosEmR);

	}

}
```

No c√≥digo acima, foi passada como par√¢metro do m√©todo **`filter()`** a express√£o lambda:

```java
e -> e.toString().startsWith("R")
```

Essa express√£o verifica, para cada elemento da cole√ß√£o **`estados`**, se o nome do estado **inicia com a letra "R"**, utilizando o m√©todo **`startsWith()`** da classe `String`. O par√¢metro `e` √© o estado atual que est√° sendo processado.

**Exemplos:**

- **"Rio de Janeiro"** inicia com a letra **R**.
- **"S√£o Paulo"** n√£o inicia com a letra **R**.

> [!TIP]
>
> üëâ Caso tenha ficado alguma d√∫vida sobre o m√©todo `equalsIgnoreCase()` da classe **String**, acesse o conte√∫do: [M√©todos da Classe String](https://github.com/rafaelq80/cookbook_java_2025/blob/main/01_java/b02.md).

Em seguida, a Stream resultante, contendo apenas os estados que come√ßam com "R", √© ordenada em ordem crescente pelo m√©todo **`sorted()`**.

Note que, neste exemplo, s√£o utilizadas **duas opera√ß√µes intermedi√°rias** (`filter()` e `sorted()`) e **uma opera√ß√£o terminal** (por exemplo, `collect()`), conforme ilustrado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/BokLPP4.png" title="source: imgur.com" /></div>

Para concluir o pipeline, utilizamos o m√©todo terminal **`collect()`** para converter a Stream em uma nova Collection chamada **`estadosR`**. Assim, o resultado do processamento ‚Äî estados que come√ßam com a letra ‚ÄúR‚Äù e ordenados ‚Äî √© armazenado nessa nova cole√ß√£o.

O resultado do algoritmo pode ser conferido abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Terminal Collect

Estados cujo nome come√ßam com a letra R: [Rio Grande do Sul, Rio de Janeiro]
```

<br />

<h3>3.2. Count</h3>



A opera√ß√£o terminal **`count()`** retorna a quantidade de elementos resultantes do processamento da Stream.

No exemplo a seguir, aplicamos um filtro para selecionar apenas os estados que terminam com a letra **"o"**, utilizando o m√©todo **`endsWith("o")`** da classe `String`. Em seguida, usamos **`count()`** para contar quantos estados atendem a esse crit√©rio.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 08 - M√©todo Count

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;

public class Exemplo08 {

	public static void main(String[] args) {

		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "Espirito Santo", 
			    "Rio Grande do Sul", 
			    "Santa Catarina", 
			    "Paran√°"
			);
		
		System.out.println("\nExemplo - M√©todo Count");
		
		long numeroEstadosTerminaComO = estados.stream()
		        .filter(e -> e.endsWith("o"))
		        .count();

		System.out.println("\nN√∫mero de Estados cujo nome terminam com a letra O: " + numeroEstadosTerminaComO);
	}

}
```

No c√≥digo acima, foi passada como par√¢metro do m√©todo **`filter()`** a **express√£o lambda**: 

```java
e -> e.endsWith("o")
```

Essa express√£o verifica, para cada elemento da cole√ß√£o `estados`, se o nome do estado termina com a letra **"o"**, utilizando o m√©todo **`endsWith()`** da classe **`String`**. O par√¢metro `e` √© o estado atual que est√° sendo processado.

O resultado da contagem √© armazenado em uma vari√°vel do tipo **`long`**, chamada **`numeroEstadosTerminaComO`**, j√° que o m√©todo **`count()`** retorna um valor do tipo `long`.

Esse valor representa quantos estados, dentro da lista, atendem √† condi√ß√£o definida no filtro. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Count

N√∫mero de Estados cujo nome terminam com a letra O: 3
```

<br />

<h3>3.3. AllMatch</h3>



A opera√ß√£o terminal **`allMatch()`** verifica se **todos os elementos** da Stream atendem a uma determinada condi√ß√£o.

No exemplo abaixo, vamos verificar se todos os estados da lista cont√™m a palavra **"Rio"**:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 09 -  M√©todo AllMatch

```java
		package exemplos_stream;

import java.util.Arrays;
import java.util.List;

public class Exemplo09 {

	public static void main(String[] args) {

		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "Espirito Santo", 
			    "Rio Grande do Sul", 
			    "Santa Catarina", 
			    "Paran√°"
			);
		
		System.out.println("\nExemplo - M√©todo AllMatch");
		
		boolean todosEstadosContemRio = estados.stream()
				.allMatch(e -> e.contains("Rio"));

		System.out.println("\nTodos os Estados cont√©m a palavra Rio? " + todosEstadosContemRio);

	}

}
		
```

No c√≥digo acima, usamos a **express√£o lambda**: `e -> e.contains("Rio")` como condi√ß√£o dentro do m√©todo **`allMatch()`**.

Essa express√£o verifica se, em cada elemento da Collection `estados`, o nome do estado cont√©m a palavra **"Rio"**, utilizando o m√©todo **`contains()`** da classe **`String`**. O par√¢metro `e` √© o estado atual que est√° sendo processado.

O resultado da verifica√ß√£o √© armazenado em uma vari√°vel do tipo **`boolean`**, chamada **`todosEstadosContemRio`**. Esse valor ser√°:

- `true` se **todos** os estados contiverem "Rio";
- `false` se **algum** estado **n√£o** contiver "Rio".

O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo AllMatch

Todos os Estados cont√©m a palavra Rio? false

```

<br />

<h3>3.4. AnyMatch</h3>



Em compara√ß√£o com a opera√ß√£o **`allMatch()`**, a opera√ß√£o **`anyMatch()`** verifica se **pelo menos um** dos elementos da Stream atende a uma determinada condi√ß√£o.

No exemplo abaixo, vamos verificar se **algum estado** da lista cont√©m a palavra **"Rio"**:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 10 - M√©todo AnyMatch

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;

public class Exemplo10 {

	public static void main(String[] args) {
		
		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "Espirito Santo", 
			    "Rio Grande do Sul", 
			    "Santa Catarina", 
			    "Paran√°"
			);
		
		System.out.println("\nExemplo - M√©todo AnyMatch");
		
		boolean algumEstadoContemRio = estados.stream()
				.anyMatch(e -> e.contains("Rio"));

		System.out.println("\nPelo menos um Estado cont√©m a palavra Rio? " + algumEstadoContemRio);
		

	}

}
```

No c√≥digo acima, utilizamos a **express√£o lambda** `e -> e.contains("Rio")` como condi√ß√£o do m√©todo **`anyMatch()`**.

Essa express√£o verifica, para cada elemento da cole√ß√£o `estados`, se o nome do estado **cont√©m a palavra "Rio"**, utilizando o m√©todo **`contains()`** da classe **`String`**. O par√¢metro `e` √© o estado atual que est√° sendo processado.

O resultado da verifica√ß√£o √© armazenado em uma vari√°vel do tipo **`boolean`**, chamada **`algumEstadoContemRio`**. O valor ser√°:

- `true`, se **pelo menos um estado** contiver "Rio";
- `false`, se **nenhum estado** contiver "Rio".

O resultado da execu√ß√£o do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo AnyMatch

Pelo menos um Estado cont√©m a palavra Rio? true
```

<br />

<h3>3.5. ForEach</h3>



O m√©todo **`forEach()`** √© utilizado para **iterar sobre os elementos da Collection resultante da Stream**, de maneira semelhante ao la√ßo de repeti√ß√£o `for` tradicional.

No exemplo abaixo, em vez de armazenar os dados em uma nova Collection, exibiremos diretamente os elementos no console:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 11 - M√©todo ForEach

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;

public class Exemplo11 {

	public static void main(String[] args) {

		List<String> estados = Arrays.asList(
			    "S√£o Paulo", 
			    "Rio de Janeiro", 
			    "Minas Gerais", 
			    "Espirito Santo", 
			    "Rio Grande do Sul", 
			    "Santa Catarina", 
			    "Paran√°"
			);
		
		System.out.println("\nExemplo - M√©todo ForEach");
		
		System.out.println("\nEstados cujo nome iniciam com a letra S:");
		
		estados.stream()
		        .filter(e -> e.startsWith("S"))
		        .forEach(System.out::println);
		
	}

}
```

No c√≥digo acima, foi utilizada a **express√£o lambda**: `e -> e.startsWith("S")` como condi√ß√£o no m√©todo **`filter()`**.

Essa express√£o verifica se o nome de cada estado **inicia com a letra "S"**, por meio do m√©todo **`startsWith()`** da classe **`String`**. O par√¢metro `e` √© o estado atual que est√° sendo processado.

Em seguida, com o uso do m√©todo **`forEach()`**, a Stream resultante √© percorrida, e **cada elemento filtrado √© exibido na tela**. 

> **Refer√™ncia de M√©todo**
>
> A express√£o `System.out::println` √© uma **refer√™ncia de m√©todo** (method reference) em Java, introduzida a partir da vers√£o 8. Ela √© uma forma simplificada e mais leg√≠vel de escrever express√µes lambda que **apenas chamam um m√©todo existente**.
>
> ### Explica√ß√£o
>
> - `System.out` √© um objeto do tipo `PrintStream`, que representa a sa√≠da padr√£o do sistema (geralmente o console).
> - `println` √© um m√©todo da classe `PrintStream`, usado para imprimir valores no console com quebra de linha.
> - `::` √© o operador de **refer√™ncia de m√©todo**.
>
> ### Equival√™ncia com express√£o lambda
>
> A refer√™ncia `System.out::println` equivale a uma express√£o lambda como esta:
>
> ```java
> x -> System.out.println(x)
> ```
>
> Ou seja, ela recebe um par√¢metro x e chama System.out.println(x).
>

O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo ForEach

Estados cujo nome iniciam com a letra S:
S√£o Paulo
Santa Catarina

```

<br />

<h3>3.6. Reduce</h3>



O m√©todo **`reduce()`** √© utilizado para **combinar todos os elementos da Stream em um √∫nico resultado**, por meio de uma opera√ß√£o de agrega√ß√£o, como **soma**, **multiplica√ß√£o** ou **concatena√ß√£o**.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 12 - M√©todo Reduce

```java
package exemplos_stream;

import java.util.Arrays;
import java.util.List;

public class Exemplo12 {

	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		System.out.println("\nExemplo - M√©todo Reduce");

		int soma = numeros.stream()
		    .reduce(0, Integer::sum);

		System.out.println("\nSoma dos n√∫meros: " + soma);

	}

}
```

Neste exemplo, a opera√ß√£o **`reduce(0, Integer::sum)`** inicia com o valor inicial `0` e aplica a soma acumulativa de todos os n√∫meros da lista, resultando na soma total dos elementos.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Soma dos n√∫meros: 55
```

<br />

## Tabela 1 ‚Äî Stream - Opera√ß√µes Intermedi√°rias

| Opera√ß√£o            | Descri√ß√£o                                                    |
| ------------------- | ------------------------------------------------------------ |
| `filter(Predicate)` | Filtra os elementos da Stream com base em uma condi√ß√£o, retornando apenas os que atendem a ela. |
| `map(Function)`     | Transforma cada elemento da Stream aplicando uma fun√ß√£o, produzindo uma nova Stream com os resultados. |
| `flatMap(Function)` | Transforma cada elemento em uma Stream e achata (concatena) todas essas Streams em uma √∫nica. |
| `distinct()`        | Remove elementos duplicados da Stream, retornando apenas elementos √∫nicos. |
| `sorted()`          | Ordena os elementos da Stream em ordem natural ou personalizada. |
| `peek(Consumer)`    | Permite executar uma a√ß√£o em cada elemento da Stream, geralmente para debug, sem modificar a Stream. |
| `limit(long)`       | Limita o n√∫mero de elementos da Stream a no m√°ximo `n`.      |
| `skip(long)`        | Ignora os primeiros `n` elementos da Stream, retornando os restantes. |

<br />

## Tabela 2 ‚Äî  Stream - Opera√ß√µes Terminais 

| Opera√ß√£o                 | Descri√ß√£o                                                    |
| ------------------------ | ------------------------------------------------------------ |
| `collect(Collector)`     | Coleta os elementos da Stream em uma cole√ß√£o, lista, conjunto, mapa ou outra estrutura de dados. |
| `forEach(Consumer)`      | Executa uma a√ß√£o para cada elemento da Stream (ex: imprimir no console). |
| `reduce(BinaryOperator)` | Combina os elementos da Stream em um √∫nico valor, usando uma opera√ß√£o associativa (ex: soma, multiplica√ß√£o). |
| `count()`                | Retorna o n√∫mero de elementos presentes na Stream.           |
| `anyMatch(Predicate)`    | Retorna `true` se **pelo menos um** elemento satisfaz a condi√ß√£o dada. |
| `allMatch(Predicate)`    | Retorna `true` se **todos os** elementos satisfazem a condi√ß√£o dada. |
| `noneMatch(Predicate)`   | Retorna `true` se **nenhum** elemento satisfaz a condi√ß√£o dada. |
| `findFirst()`            | Retorna um `Optional` com o primeiro elemento da Stream, se existir. |
| `findAny()`              | Retorna um `Optional` com qualquer elemento da Stream (√∫til em Streams paralelas). |
| `min(Comparator)`        | Retorna o menor elemento da Stream, de acordo com um comparador. |
| `max(Comparator)`        | Retorna o maior elemento da Stream, de acordo com um comparador. |

<br />


------

### üîë**Pontos chave:**

- **Stream** √© um pipeline (conjunto) de opera√ß√µes que pode ser utilizado para processar os dados armazenados em uma **Collection** ou **Array**.
- Uma **Stream** possui dois tipos de opera√ß√µes: **intermedi√°rias** e **terminais**.
- As **opera√ß√µes intermedi√°rias** retornam uma nova Stream, permitindo o encadeamento de m√∫ltiplas opera√ß√µes.
- As **opera√ß√µes terminais** encerram o pipeline, retornando um valor ou objeto. Ap√≥s a execu√ß√£o de uma opera√ß√£o terminal, a mesma Stream n√£o poder√° ser reutilizada para novas opera√ß√µes.
- Uma **Stream n√£o √© uma estrutura de dados**; ela **consome** uma estrutura de dados existente (como uma Collection ou Array) para realizar opera√ß√µes sobre seus elementos.
- A **Stream n√£o altera a estrutura de dados original** ‚Äî ela apenas fornece um resultado conforme os m√©todos definidos na pipeline.
- A **Stream n√£o armazena dados**; ela apenas opera sobre os dados da estrutura de origem.
- Streams n√£o permitem a modifica√ß√£o direta da cole√ß√£o de origem (n√£o suportam adi√ß√£o ou remo√ß√£o de elementos).

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
