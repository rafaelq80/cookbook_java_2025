<h1>Arrays - Vetores</h1>



**Array** é uma estrutura de dados muito popular, simples e amplamente utilizada no dia a dia por pessoas desenvolvedoras. Trata-se de uma coleção **indexada**, ou seja, cada elemento é referenciado por um **índice numérico**, geralmente iniciando em zero. Arrays possuem **tamanho fixo** e armazenam **elementos do mesmo tipo de dado**, definidos no momento da criação.

Fazendo uma analogia com o mundo real, o **Array** é como uma **caixa com várias divisórias**, onde cada divisória guarda um valor e tem um número para identificá-la (o índice). Esses valores são todos do **mesmo tipo** (números, textos etc.), e o número de divisórias é fixo — ou seja, definido na criação da caixa.

Os arrays podem ser classificados em três categorias principais:

1. **Unidimensionais (Vetores):** São arrays com apenas uma dimensão. Podem ser visualizados como uma linha com *N* posições (ou colunas), onde *N* representa a quantidade máxima de elementos que o vetor pode armazenar.
2. **Bidimensionais (Matrizes):** São arrays com duas dimensões, organizados em **linhas (i)** e **colunas (j)**. Podem ser comparados a uma tabela, onde cada célula é acessada por um par de índices. 
3. **Multidimensionais:** São arrays com três ou mais dimensões. Um array tridimensional, por exemplo, pode ser visto como um conjunto de matrizes bidimensionais. Apesar de, na prática, ser possível declarar arrays com muitas dimensões, a representação espacial humana geralmente se limita a até 3 dimensões. 

Nos próximos tópicos, abordaremos a implementação e uso de **arrays unidimensionais (vetores)** e **bidimensionais (matrizes)**, com exemplos práticos para facilitar a compreensão.

<br />

<h2>1. Vetores</h2>



Os **vetores**, ou **arrays unidimensionais**, são estruturas de dados que permitem armazenar e acessar uma grande quantidade de informações na memória utilizando apenas **um único nome de variável**. Essa variável especial é declarada de forma que a pessoa desenvolvedora possa acessar múltiplas posições de memória de maneira **organizada e controlada**.

Um vetor é sempre composto por **elementos do mesmo tipo** (por exemplo, `int`, `float`, `String`, entre outros), que podem ser manipulados tanto individualmente quanto como um conjunto. Ao declarar um vetor, estamos **reservando na memória principal** (RAM) uma sequência contínua de posições para armazenar os dados desse tipo. O **nome do vetor** referencia a **posição inicial (base)** da estrutura na memória, enquanto cada elemento é acessado por meio de um **índice numérico**, geralmente iniciando em zero.

Essa abordagem torna o acesso aos dados **rápido e eficiente**, sendo ideal para situações em que se conhece previamente a quantidade de elementos a serem armazenados.

<div align="center"><img src="https://i.imgur.com/WML81no.png" title="source: imgur.com" /></div>

Na imagem acima, temos um **vetor com 5 posições alocadas na memória**. É importante observar que, por padrão, o **índice inicia em 0**, ou seja, o primeiro elemento está na posição 0, o segundo na posição 1, e assim sucessivamente até a última posição, que neste caso é a 4.

Cada posição do vetor representa uma **célula de memória** onde um dado do tipo definido é armazenado. O acesso a esses dados é feito por meio do **índice**, o que permite localizar e manipular rapidamente qualquer elemento do vetor.

>**Como funciona a alocação da memória de um array?**
>
>A alocação de memória de um array é feita de forma **contígua**, ou seja, todas as posições ocupam espaços sequenciais na memória RAM. Quando o array é declarado, o sistema operacional reserva um **bloco contínuo de memória**, suficiente para armazenar todos os elementos do tipo definido.
>
>O **nome do array** referencia o **endereço da primeira posição** (posição base). A partir desse endereço, os demais elementos são acessados por meio de **cálculos de deslocamento com base no índice**, considerando o tamanho de cada elemento. Por exemplo, se cada elemento ocupa 4 bytes, o elemento de índice 3 estará a 12 bytes da posição base.
>
>Essa organização permite um **acesso direto e eficiente** aos elementos, mas exige que o tamanho do array seja conhecido no momento da alocação, pois não é possível redimensionar arrays fixos sem realocar a memória.

<br />

**Sintaxe - Vetor com atribuição de valores**

```java
tipo_de_dado identificadorDoVetor[] = {v1, v2, v3,..., vn};
```

ou

```java
tipo_de_dado[] identificadorDoVetor = {v1, v2, v3,..., vn};
```

Nesta forma, os valores são atribuídos diretamente no momento da declaração. A quantidade de elementos é definida automaticamente com base nos dados informados. 

`v1, ... , vn` são os valores atribuídos, separados por vírgulas.

<br />

**Sintaxe - Vetor sem atribuição de valores:**

```java
tipo_de_dado identificadorDoVetor[] = new tipo_de_dado[tamanho];
```

ou

```java
tipo_de_dado[] identificadorDoVetor = new tipo_de_dado[tamanho];
```

Nesse formato, o vetor é declarado sem valores iniciais. O tamanho do vetor é  definido manualmente, e os elementos recebem valores padrão conforme o tipo de dado.

<br />

<h3>1.1. Tipo</h3>



Este parâmetro define o **tipo de dado** que será armazenado no vetor. Assim como nas variáveis comuns, o tipo deve ser declarado no momento da criação e determina os valores que o vetor poderá armazenar.

Abaixo, alguns tipos primitivos e de referência mais utilizados em vetores:

| Tipo     | Descrição                               | Exemplo de valor    |
| -------- | --------------------------------------- | ------------------- |
| `int`    | Números inteiros                        | `10`, `25`, `-3`    |
| `double` | Números decimais com dupla precisão     | `3.14`, `7.89`      |
| `float`  | Números decimais com menor precisão     | `2.5f`, `8.7f`      |
| `char`   | Caracteres únicos                       | `'A'`, `'Z'`, `'1'` |
| `String` | Cadeias de texto (objeto de referência) | `"Olá"`, `"Java"`   |

O tipo deve ser **compatível com os valores** que se deseja armazenar no vetor e não pode ser alterado após a declaração.

<br />

<h3>1.2. Identificador do Vetor</h3>



Na programação Java, **vetores** são **variáveis especiais** e, por isso, seguem as mesmas **regras e convenções de nomeação** usadas para variáveis comuns. Isso garante clareza, organização e legibilidade no código.

#### ✅ **Regras para nomear vetores (identificadores):**

- Utilize o padrão *Camel Case*, ou seja, **a primeira palavra com letra minúscula, próximas iniciam com maiúscula**, que é o mesmo padrão usado pelo Java para nomear variáveis.
- O nome **pode conter** letras, números, sublinhado (`_`) e cifrão (`$`).
- O nome **deve começar com** uma letra, um `_` ou um `$`.
- **Não pode começar com número.**
- **Não pode usar palavras reservadas** do Java (como `int`, `for`, `class`, `null`, etc.).
- O nome **deve ser único** dentro do escopo e representar claramente o que o vetor armazena.
- O nome **pode ter qualquer tamanho**, mas recomenda-se que seja **curto e descritivo**.
- Utilize **nomes no plural** para vetores: `notas`, `contas`, `produtos`, `listaDeCompras`, entre outros.

<br />

> [!IMPORTANT]
>
> Seguindo as Boas Práticas, o identificador do vetor deve expressar exatamente o seu conteúdo. Evite utilizar nomes genéricos como v1, vetor_01, entre outros.

<br />

<h3>1.3. Declarando Vetores</h3>



Vamos entender como declarar um vetor:

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Vetor com dados do tipo inteiro

```java
int numeros[] = {10, 15, 35, 70, 140};
```

<br />

<div align="center"><img src="https://i.imgur.com/YILRPx6.png" title="source: imgur.com" /></div>

Na imagem acima, é possível observar a alocação de memória para um vetor de números inteiros. Cada elemento do vetor ocupa uma posição específica, onde seu valor está armazenado de forma organizada e sequencial.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - Vetor com dados do tipo String

```java
String racasCaes[] = {"Boxer", "Pastor Alemão", "Pinscher", "Husky Siberiano", "Corgi"};
```

<br />

<div align="center"><img src="https://i.imgur.com/Tw9GfYr.png" title="source: imgur.com" /></div>

Na imagem acima, observa-se a alocação de memória para um vetor composto por caracteres, representado pelo tipo String. Cada palavra está armazenada em uma posição distinta do vetor.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Vetor vazio

```java
float descontos[] = new float[5];
```

<br />

<div align="center"><img src="https://i.imgur.com/WML81no.png" title="source: imgur.com" /></div>

Na imagem acima, é ilustrada a **alocação de memória** para um **vetor do tipo `float`**, ainda **sem valores atribuídos**.

Observe que todas as posições serão preenchidas com o **valor padrão `0.0f`**, pois, em Java, ao declarar uma matriz de tipos numéricos sem atribuição explícita, cada elemento recebe automaticamente o valor padrão correspondente ao seu tipo.

Para inserir dados nesse vetor, seria necessário **atribuir valores de forma direta** ou utilizar a **classe Scanner**, permitindo a entrada de dados via teclado durante a execução do programa.

<br />

<h3>1.4. Acessar uma posição do Vetor</h3>



Para acessar os dados armazenados em uma posição específica do vetor, utilizamos o **nome do vetor seguido de colchetes**. Dentro dos colchetes, indicamos o **índice**, que corresponde à posição cujos dados queremos obter.

**Sintaxe:**

```java
identificador_do_vetor[indice];
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 04 - Exibindo os dados do vetor

<br />

**Código Java - Versão 01**

```java
package exemplos_arrays;

public class Exemplo04 {

	public static void main(String[] args) {

		String racasCaes[] = {"Boxer","Pastor Alemão","Pinscher","Husky Siberiano","Corgi"};
	    
        System.out.println("1º elemento: " + racasCaes[0]);
        System.out.println("2º elemento: " + racasCaes[1]);
        System.out.println("3º elemento: " + racasCaes[2]);
        System.out.println("4º elemento: " + racasCaes[3]);
        System.out.println("5º elemento: " + racasCaes[4]);

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
1º elemento: Boxer
2º elemento: Pastor Alemão
3º elemento: Pinscher
4º elemento: Husky Siberiano
5º elemento: Corgi
```

Observe no exemplo, que o índice é uma sequência numérica, e o comando `System.out.println()` é repetido cinco vezes com o mesmo conteúdo, alterando apenas o índice do vetor. 

Como se trata de uma repetição, podemos simplificar esse código utilizando um laço de repetição. Vamos reescrever este exemplo adicionando um laço de repetição. 

<br />

**Código Java - Versão 02**

```java
package exemplos_arrays;

public class Exemplo04 {

	public static void main(String[] args) {

		String racasCaes[] = { "Boxer", "Pastor Alemão", "Pinscher", "Husky Siberiano", "Corgi" };

		for (int indice = 0; indice < 5; indice++) {
			System.out.println((indice + 1) + "º elemento: " + racasCaes[indice]);
		}

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
1º elemento: Boxer
2º elemento: Pastor Alemão
3º elemento: Pinscher
4º elemento: Husky Siberiano
5º elemento: Corgi
```

Observe que o resultado foi o mesmo; no entanto, ao utilizar o **laço de repetição**, o código ficou mais simples e mais fácil de manter.

<br />

<h3>1.5. Entrada de dados - Vetor vazio</h3>



Os dados em um vetor podem ser inseridos diretamente por atribuição ou por meio da entrada via teclado. Embora a atribuição direta seja simples, utilizar o teclado para inserir valores torna o programa mais dinâmico e interativo. Para isso, usamos uma instância da classe **Scanner**, que chamaremos de **leia**.

```java
Scanner leia = new Scanner(System.in);
```

Para armazenar um valor em cada posição do vetor, utilizamos o nome do vetor (identificador) seguido do índice correspondente, onde será atribuído o dado digitado pelo usuário através do comando **leia**.

**Sintaxe:**

```java
identificador_do_vetor[indice] = leia.metodo_entrada(); 
```

*O Método de entrada do Objeto leia dependerá do tipo de dado do vetor.*

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 05 - Inserindo dados no vetor vazio

```java
package exemplos_arrays;

import java.util.Scanner;

public class Exemplo05 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int numeros[] = new int[5];

		for (int indice = 0; indice < 5; indice++) {
			System.out.println("Digite o " + (indice + 1) + "º Número: ");
			numeros[indice] = leia.nextInt();
		}

		System.out.println("\nOs números digitados foram: \n");

		for (int indice = 0; indice < 5; indice++) {
			System.out.println((indice + 1) + "º número: " + numeros[indice]);
		}

		leia.close();
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Digite o 1º Número: 
10
Digite o 2º Número: 
20
Digite o 3º Número: 
30
Digite o 4º Número: 
40
Digite o 5º Número: 
50

Os números digitados foram: 

1º número: 10
2º número: 20
3º número: 30
4º número: 40
5º número: 50
```

Neste exemplo, o vetor foi preenchido com os dados obtidos via teclado e, ao concluir o preenchimento, os valores armazenados foram exibidos na tela.

<br>

<h3>1.6. Tamanho de um Vetor</h3>



Nos exemplos anteriores, definimos manualmente o tamanho do vetor dentro do laço de repetição. Porém, na prática, cada vetor pode ter um tamanho diferente, e seria interessante automatizar esse processo. 

Para automatizar este processo, vamos utiliza a propriedade **length**, que identifica automaticamente o tamanho do vetor, permitindo que o código se adapte a diferentes tamanhos de forma dinâmica.

**Sintaxe:**

```java
identificador_do_vetor.length;
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 06 - Tamanho do vetor - Propriedade length

```java
package exemplos_arrays;

public class Exemplo06 {

	public static void main(String[] args) {

		String racasCaes[] = { "Boxer", "Pastor Alemão", "Pinscher", "Husky Siberiano", "Corgi" };

		System.out.println("Itens aramazenados no vetor: \n");

		for (int indice = 0; indice < racasCaes.length; indice++) {
			System.out.println(racasCaes[indice]);
		}

		System.out.println("\nO tamanho do seu vetor é: " + racasCaes.length);
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Itens armazenados no vetor: 

Boxer
Pastor Alemão
Pinscher
Husky Siberiano
Corgi

O tamanho do seu vetor é: 5
```

Observe que, neste exemplo, utilizamos o método **length** não apenas para exibir o tamanho do vetor, mas também dentro do laço de repetição **for**, como segundo parâmetro, para definir a **condição de parada**. Dessa forma, não é necessário informar manualmente um número fixo, tornando o código mais flexível e adaptável ao tamanho real do vetor.

<br />

<h3>1.7. Métodos da Classe Arrays</h3>



A **classe `Arrays`** pertence ao pacote `java.util` e oferece diversos métodos utilitários para facilitar a manipulação de arrays. Esses métodos são compatíveis com arrays de qualquer tipo — sejam eles de tipos primitivos ou de objetos.

### ✅ **Principais métodos da classe Arrays:**

| Método                                           | Descrição                                                    |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `Arrays.sort(array)`                             | Ordena os elementos de um array de tipos primitivos em ordem crescente. |
| `Arrays.sort(array, Collections.reverseOrder())` | Ordena os elementos de um array de objetos em ordem decrescente.Para utilizar com tipos primitivos, é necessário convertê-los para **Wrappers** (veremos isso mais adiante). |
| `Arrays.equals(array1, array2)`                  | Compara dois arrays, retornando `true` se ambos tiverem o mesmo conteúdo, nas mesmas posições e forem do mesmo tipo. |
| `Arrays.binarySearch(array, chave)`              | Retorna o índice do elemento procurado em um array. O array deve estar previamente ordenado e sem valores duplicados. |
| `Arrays.fill(array, valor)`                      | Preenche todas as posições do array com o valor especificado. |
| `Arrays.compare(array1, array2)`                 | Compara dois arrays com base em seu conteúdo, retornando `0` se forem iguais, valor negativo se o primeiro for "menor" ou positivo se for "maior". |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 07 - Ordenando um vetor de Strings

```java
package exemplos_arrays;

import java.util.Arrays;
import java.util.Collections;

public class Exemplo07 {

	public static void main(String[] args) {
		
		String arrayNomes[] = { "Samantha", "Amanda", "Vinicius", "Cauê", "Leonardo" };

		Arrays.sort(arrayNomes);

		System.out.println("Array em Ordem Crescente \n");
		for (int indice = 0; indice < arrayNomes.length; indice++) {
			System.out.println(arrayNomes[indice]);
		}

		Arrays.sort(arrayNomes, Collections.reverseOrder());

		System.out.println("\nArray em Ordem Decrescente \n");
		for (int indice = 0; indice < arrayNomes.length; indice++) {
			System.out.println(arrayNomes[indice]);
		}

	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Array em Ordem Crescente 

Amanda
Cauê
Leonardo
Samantha
Vinicius

Array em Ordem Decrescente 

Vinicius
Samantha
Leonardo
Cauê
Amanda
```

Este exemplo demonstra como utilizar a classe **`Arrays`** para ordenar um vetor de nomes do tipo `String`. Inicialmente, o array `arrayNomes` é ordenado em **ordem crescente** com o método `Arrays.sort()`, exibindo os nomes em ordem alfabética. Em seguida, o mesmo array é reordenado em **ordem decrescente** utilizando `Arrays.sort()` em conjunto com `Collections.reverseOrder()`. 

Como se trata de um vetor de objetos (`String`), é possível aplicar essa ordenação reversa diretamente, sem necessidade de conversão para wrappers. O resultado é exibido no console com dois laços `for`, um para cada ordenação.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 08 - Ordenando um vetor de primitivos

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo08 {

    public static void main(String[] args) {
        
        int vetorInteiros[] = { 3, 2, 1, 6, 5, 10, 7, 4, 9, 8 };

		Arrays.sort(vetorInteiros);

		System.out.println("Array de primitivos em Ordem Crescente \n");
		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			System.out.println(vetorInteiros[indice]);
		}

		System.out.println("\nArray de primitivos em Ordem Decrescente \n");
		
		int[] reverseArray = new int[vetorInteiros.length];

		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			reverseArray[indice] = vetorInteiros[(vetorInteiros.length - 1) - indice];
		}

		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			System.out.println(reverseArray[indice]);
		}
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Array de primitivos em Ordem Crescente 

1
2
3
4
5
6
7
8
9
10

Array de primitivos em Ordem Decrescente 

10
9
8
7
6
5
4
3
2
1
```

Este exemplo mostra como ordenar um vetor de números inteiros (tipos primitivos) em **ordem crescente e decrescente** utilizando a classe **`Arrays`**. Primeiro, o vetor `vetorInteiros` é ordenado em ordem crescente com o método `Arrays.sort()`. 

Como não é possível usar `Collections.reverseOrder()` diretamente com tipos primitivos, para exibir os valores em **ordem decrescente**, foi criado um novo vetor (`reverseArray`), preenchido manualmente com os elementos do vetor original em ordem inversa. Por fim, ambos os resultados são exibidos no console por meio de laços de repetição `for`.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 09 - Comparando vetores

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo09 {

	public static void main(String[] args) {

		String grupoA[] = { "Amanda", "Elen", "Vinicius" };
		String grupoB[] = { "Samantha", "Letícia", "Alan" };

		System.out.println("Os Arrays são iguais? ");

		if (Arrays.equals(grupoA, grupoB)) {
			System.out.println("Sim, são iguais.");
		} else {
			System.out.println("Não, são diferentes.");
		}

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Os Arrays são iguais? 
Não, são diferentes.
```

Este exemplo ilustra o uso do método **`Arrays.equals()`** para comparar dois vetores do tipo `String`. Os arrays `grupoA` e `grupoB` contêm nomes diferentes, e a comparação verifica se ambos possuem os **mesmos elementos, na mesma ordem e do mesmo tipo**. Como os valores são distintos, o método retorna `false`, e a mensagem exibida é "Não, são diferentes." Esse método é útil para verificar a igualdade exata entre arrays em aplicações que exigem validação de conteúdo.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 10 - Localizando um dado no vetor - Método binarySearch()

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo10 {

	public static void main(String[] args) {

		float descontos[] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 10.0f, 7.0f, 6.0f, 9.0f, 8.0f };

		// Ordena o vetor
		Arrays.sort(descontos);

		System.out.println("\nVetor Ordenado");

		for (int indice = 0; indice < descontos.length; indice++) {
			System.out.println(descontos[indice]);
		}

		System.out.println("\nO elemento 10.0 existe? Qual é a posição?");

		int posicao = Arrays.binarySearch(descontos, 10.0f);

		// Se a posição for positiva = Encontrou
		if (posicao >= 0) {
			System.out.println("\nO elemento foi encontrado e está na posição: " + posicao);
		} else {
			System.out.println("\nElemento não encontrado!");
		}
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash

Vetor Ordenado
1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0

O elemento 10.0 existe? Qual é a posição?

O elemento foi encontrado e está na posição: 9
```

Este exemplo demonstra a utilização da classe **`Arrays`** com um vetor do tipo **`float`**. O vetor `descontos` é preenchido com valores reais e, em seguida, ordenado em ordem crescente utilizando o método **`Arrays.sort()`**. Após a ordenação, os valores são exibidos no console por meio de um laço `for`. 

Na sequência, o código realiza a busca do valor `10.0f` no vetor ordenado utilizando o método **`Arrays.binarySearch()`**, que retorna o índice da posição onde o valor foi encontrado. Caso o valor esteja presente, sua posição é exibida; caso contrário, uma mensagem informa que o elemento não foi encontrado. 

> [!WARNING]
>
> Ao atribuir um valor para uma variável do tipo `float`, **é obrigatório incluir casas decimais** (mesmo que seja `.0`) e **acrescentar a letra `f` ou `F` no final**, para indicar que o valor é do tipo `float` e não `double` (que é o padrão para números com ponto flutuante).

<br />

<h2>2. O Laço de Repetição for...each</h2>



A expressão em inglês *“for each”* pode ser traduzida como **“para cada”**. Em Java, o laço de repetição **for-each** é utilizado para iterar listas, arrays e outras coleções de forma simplificada. Sua principal vantagem é **tornar o código mais legível e menos propenso a erros**, ao eliminar a necessidade de manipular índices manualmente.

O laço **for-each** percorre todos os elementos de um array ou coleção automaticamente, evitando problemas comuns, como começar o contador pelo índice errado (por exemplo, 1 em vez de 0) ou ultrapassar os limites da estrutura. Dessa forma, ele facilita a escrita e a manutenção do código.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> Mantenha a Orientação ao Futuro!
>
> Se os termos **Coleções** ou **Collections** ainda não forem familiares para você, não se preocupe. Em breve, teremos um conteúdo dedicado exclusivamente a esse assunto.

<br />

**Sintaxe:**

```bash
for(tipo identificador : array){
    // comando a serem executados
}
```

<br />

<h3>2.1. Tipo</h3>



Refere-se ao tipo dos elementos contidos no array (ou coleção) que será percorrido pelo laço **for-each**.

**Exemplo:** Se o array é do tipo `String[]`, a variável também será do tipo `String`.

<br />

<h3>2.2. Identificador</h3>



É o nome da variável que representa o elemento atual da iteração, eliminando a necessidade de manipular índices. Funciona como uma referência direta ao item do array ou coleção, similar a `nome_do_array[indice]` em um laço de repetição tradicional.

<br />

<h3>2.3. Array</h3>



É a estrutura de dados que terá seus elementos percorridos, podendo ser um array ou uma coleção.

Vamos criar um programa que exibe, no console, os nomes dos alunos armazenados em um vetor. Na primeira versão, utilizaremos o **laço `for`** e na segunda utilizaremos o **laço `for-each`**, permitindo uma comparação entre as abordagens.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 11 - Percorrendo um Vetor com o for...each

<br />

**Código Java - Versão 01**

```java
package exemplos_arrays;

public class Exemplo11 {

	public static void main(String[] args) {

		String alunos[] = { "Felipe", "Jonas", "Julia", "Marcos", "Janaína" };

        for(int indice = 0; indice < alunos.length; indice++) {
            System.out.println(alunos[indice]);
        }

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Felipe
Jonas
Julia
Marcos
Janaína
```

<br />

**Código Java - Versão 02**

```java
package exemplos_arrays;

public class Exemplo11 {

	public static void main(String[] args) {

		String alunos[] = { "Felipe", "Jonas", "Julia", "Marcos", "Janaína" };

        for (String aluno : alunos) {
            System.out.println(aluno);
        }

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
Felipe
Jonas
Julia
Marcos
Janaína
```

Observe que, na **segunda versão do código**, com o uso do laço **`for-each`**, foi necessário declarar apenas **uma única variável (`aluno)**, que representa diretamente cada elemento do vetor. Isso torna o código **mais simples, limpo e fácil de compreender**, especialmente para quem está iniciando na programação.

Em termos de **performance**, na maioria dos casos **não há diferença significativa** entre o laço `for` tradicional e o laço `for-each`. Isso ocorre porque, durante a execução, ambos são interpretados e processados de forma semelhante pela máquina virtual Java (JVM). A principal diferença está na **legibilidade e na praticidade de uso**, e não no desempenho.

Apesar da simplicidade e legibilidade que o laço **`for-each`** proporciona, ele possui uma limitação importante: **não é possível acessar diretamente o índice dos elementos durante a iteração**.

Isso acontece porque o `for-each` foi projetado para **percorrer os elementos de forma sequencial**, sem se preocupar com sua posição na estrutura. A variável declarada dentro do laço representa apenas o **valor atual**, e **não a sua posição** dentro do array ou da coleção.

<br />

Para fixar o conteúdo, vamos atualizar o exemplo do **Cardápio Digital de uma Cantina Italiana**, adicionando um vetor para guardar os produtos do cardápio.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 12 - Cardápio - Versão Matriz

```java
package exemplos_arrays;

import java.util.Scanner;

public class Exemplo12 {

    public static void main(String[] args) {

        Scanner leia = new Scanner(System.in);
        char categoria;

        // Arrays com os itens e preços para cada categoria
        String[] antipasti = {
            "Bruschetta al Pomodoro ......... R$ 16,00",
            "Carpaccio di Manzo ............. R$ 24,90",
            "Caprese com Pesto .............. R$ 21,50"
        };

        String[] primiPiatti = {
            "Spaghetti alla Carbonara ....... R$ 36,90",
            "Lasagna alla Bolognese ......... R$ 39,50",
            "Gnocchi al Pesto ................ R$ 34,00"
        };

        String[] bevande = {
            "Água com gás .................... R$ 5,00",
            "Suco de Uva Integral ............ R$ 9,00",
            "Vinho Tinto (taça) .............. R$ 18,00"
        };

        String[] dolci = {
            "Tiramisu Tradicional ............ R$ 12,00",
            "Cannoli Siciliani ............... R$ 10,50",
            "Panna Cotta com Frutas Vermelhas R$ 11,90"
        };

        System.out.println("=== Cardápio da Cantina Italiana ===");
        System.out.println("E - Antipasti (Entradas)");
        System.out.println("P - Primi Piatti (Pratos principais)");
        System.out.println("B - Bevande (Bebidas)");
        System.out.println("D - Dolci (Sobremesas)");
        System.out.println("S - Sair");

        do {
            System.out.print("\nDigite a letra da categoria desejada: ");
            String entrada = leia.next().trim().toUpperCase();

            if (entrada.length() > 0) {
                categoria = entrada.charAt(0);
            } else {
                categoria = ' ';
            }

            switch (categoria) {
                case 'E':
                    System.out.println("\n-- Antipasti --");
                    for (String item : antipasti) {
                        System.out.println("• " + item);
                    }
                    break;
                case 'P':
                    System.out.println("\n-- Primi Piatti --");
                    for (String item : primiPiatti) {
                        System.out.println("• " + item);
                    }
                    break;
                case 'B':
                    System.out.println("\n-- Bevande --");
                    for (String item : bevande) {
                        System.out.println("• " + item);
                    }
                    break;
                case 'D':
                    System.out.println("\n-- Dolci --");
                    for (String item : dolci) {
                        System.out.println("• " + item);
                    }
                    break;
                case 'S':
                    System.out.println("Grazie! Volte sempre à nossa cantina!");
                    break;
                default:
                    System.out.println("Categoria inválida. Por favor, tente novamente.");
            }
        } while (categoria != 'S');

        leia.close();
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Código:**

```bash
=== Cardápio da Cantina Italiana ===
E - Antipasti (Entradas)
P - Primi Piatti (Pratos principais)
B - Bevande (Bebidas)
D - Dolci (Sobremesas)
S - Sair

Digite a letra da categoria desejada: e

-- Antipasti --
• Bruschetta al Pomodoro ......... R$ 16,00
• Carpaccio di Manzo ............. R$ 24,90
• Caprese com Pesto .............. R$ 21,50

Digite a letra da categoria desejada: d

-- Dolci --
• Tiramisu Tradicional ............ R$ 12,00
• Cannoli Siciliani ............... R$ 10,50
• Panna Cotta com Frutas Vermelhas R$ 11,90

Digite a letra da categoria desejada: s
Grazie! Volte sempre à nossa cantina!
```

Nesta atualização, realizamos as seguintes melhorias:

- Os **itens do cardápio foram organizados em vetores do tipo `String[]`**, separados por categoria (entradas, pratos principais, bebidas e sobremesas), o que facilita o acesso e a exibição dos dados.
- A **categoria escolhida pelo usuário passou a ser representada por uma variável do tipo `char`**, tornando o código mais enxuto e direto ao comparar a opção digitada.
- Ao digitar a letra correspondente à categoria (`E`, `P`, `B` ou `D`), o programa identifica o vetor associado e exibe os itens formatados com nome e preço.
- Também foi mantida a opção `S` para **encerrar a execução com uma mensagem personalizada de despedida**.

Com essas mudanças, o código ficou mais **organizado, legível e fácil de manter**, além de proporcionar uma navegação simples e objetiva para o usuário do sistema.

<br />

## 🆚 Tabela Comparativa: `for` vs `for...each`

| **For**                                                      | **for...each**                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Requer a declaração explícita de controle de repetição, incluindo inicialização, condição e incremento ou decremento. | O controle da repetição é feito automaticamente, com incremento interno a cada iteração. Não permite personalização do fluxo. |
| Apropriado quando é necessário acessar ou modificar elementos com base no índice. | Não é indicado quando há necessidade de acessar o índice ou modificar diretamente os elementos com base em sua posição. |
| Permite o acesso direto ao índice dos elementos do array ou coleção. | Não oferece acesso ao índice; apenas ao valor de cada elemento. |

<br />

------

## 🔑**Pontos chave:**

1. **Arrays** são estruturas de dados que armazenam múltiplos elementos do **mesmo tipo**, acessados por meio de **índices numéricos**. O índice do primeiro elemento é sempre `0`.
2. Os arrays em Java possuem **tamanho fixo**, definido no momento da sua criação. A memória é alocada de forma **contígua**, o que permite acesso rápido aos elementos, mas impede redimensionamento sem realocação.
3. Existem **três tipos principais de arrays** em Java:
   - **Unidimensionais (Vetores):** Representam uma sequência linear de dados (exemplo: lista de nomes).
   - **Bidimensionais (Matrizes):** São tabelas com linhas e colunas (exemplo: tabela de preços).
   - **Multidimensionais:** São arrays com três ou mais dimensões, como uma matriz tridimensional (exemplo: cubo de dados).
4. A sintaxe de declaração de um array pode incluir ou não a atribuição inicial de valores.
5. Para acessar ou modificar um elemento do array, utilizamos o nome do array seguido do índice entre colchetes.
6. A propriedade `.length` retorna o **tamanho do array**, ou seja, a quantidade de elementos. Esta propriedade pode ser usada para automatizar laços de repetição.
7. O laço **`for-each`** permite percorrer todos os elementos de um array de forma mais simples e legível, sem a necessidade de controlar manualmente os índices.
8. O **`for-each`** é ideal para **leitura** dos elementos. No entanto, não permite acesso direto ao índice, sendo limitado para casos onde é necessário modificar elementos em posições específicas.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
