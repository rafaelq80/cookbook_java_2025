<h1>Arrays - Vetores</h1>



**Array** √© uma estrutura de dados muito popular, simples e amplamente utilizada no dia a dia por pessoas desenvolvedoras. Trata-se de uma cole√ß√£o **indexada**, ou seja, cada elemento √© referenciado por um **√≠ndice num√©rico**, geralmente iniciando em zero. Arrays possuem **tamanho fixo** e armazenam **elementos do mesmo tipo de dado**, definidos no momento da cria√ß√£o.

Fazendo uma analogia com o mundo real, o **Array** √© como uma **caixa com v√°rias divis√≥rias**, onde cada divis√≥ria guarda um valor e tem um n√∫mero para identific√°-la (o √≠ndice). Esses valores s√£o todos do **mesmo tipo** (n√∫meros, textos etc.), e o n√∫mero de divis√≥rias √© fixo ‚Äî ou seja, definido na cria√ß√£o da caixa.

Os arrays podem ser classificados em tr√™s categorias principais:

1. **Unidimensionais (Vetores):** S√£o arrays com apenas uma dimens√£o. Podem ser visualizados como uma linha com *N* posi√ß√µes (ou colunas), onde *N* representa a quantidade m√°xima de elementos que o vetor pode armazenar.
2. **Bidimensionais (Matrizes):** S√£o arrays com duas dimens√µes, organizados em **linhas (i)** e **colunas (j)**. Podem ser comparados a uma tabela, onde cada c√©lula √© acessada por um par de √≠ndices. 
3. **Multidimensionais:** S√£o arrays com tr√™s ou mais dimens√µes. Um array tridimensional, por exemplo, pode ser visto como um conjunto de matrizes bidimensionais. Apesar de, na pr√°tica, ser poss√≠vel declarar arrays com muitas dimens√µes, a representa√ß√£o espacial humana geralmente se limita a at√© 3 dimens√µes. 

Nos pr√≥ximos t√≥picos, abordaremos a implementa√ß√£o e uso de **arrays unidimensionais (vetores)** e **bidimensionais (matrizes)**, com exemplos pr√°ticos para facilitar a compreens√£o.

<br />

<h2>1. Vetores</h2>



Os **vetores**, ou **arrays unidimensionais**, s√£o estruturas de dados que permitem armazenar e acessar uma grande quantidade de informa√ß√µes na mem√≥ria utilizando apenas **um √∫nico nome de vari√°vel**. Essa vari√°vel especial √© declarada de forma que a pessoa desenvolvedora possa acessar m√∫ltiplas posi√ß√µes de mem√≥ria de maneira **organizada e controlada**.

Um vetor √© sempre composto por **elementos do mesmo tipo** (por exemplo, `int`, `float`, `String`, entre outros), que podem ser manipulados tanto individualmente quanto como um conjunto. Ao declarar um vetor, estamos **reservando na mem√≥ria principal** (RAM) uma sequ√™ncia cont√≠nua de posi√ß√µes para armazenar os dados desse tipo. O **nome do vetor** referencia a **posi√ß√£o inicial (base)** da estrutura na mem√≥ria, enquanto cada elemento √© acessado por meio de um **√≠ndice num√©rico**, geralmente iniciando em zero.

Essa abordagem torna o acesso aos dados **r√°pido e eficiente**, sendo ideal para situa√ß√µes em que se conhece previamente a quantidade de elementos a serem armazenados.

<div align="center"><img src="https://i.imgur.com/WML81no.png" title="source: imgur.com" /></div>

Na imagem acima, temos um **vetor com 5 posi√ß√µes alocadas na mem√≥ria**. √â importante observar que, por padr√£o, o **√≠ndice inicia em 0**, ou seja, o primeiro elemento est√° na posi√ß√£o 0, o segundo na posi√ß√£o 1, e assim sucessivamente at√© a √∫ltima posi√ß√£o, que neste caso √© a 4.

Cada posi√ß√£o do vetor representa uma **c√©lula de mem√≥ria** onde um dado do tipo definido √© armazenado. O acesso a esses dados √© feito por meio do **√≠ndice**, o que permite localizar e manipular rapidamente qualquer elemento do vetor.

>**Como funciona a aloca√ß√£o da mem√≥ria de um array?**
>
>A aloca√ß√£o de mem√≥ria de um array √© feita de forma **cont√≠gua**, ou seja, todas as posi√ß√µes ocupam espa√ßos sequenciais na mem√≥ria RAM. Quando o array √© declarado, o sistema operacional reserva um **bloco cont√≠nuo de mem√≥ria**, suficiente para armazenar todos os elementos do tipo definido.
>
>O **nome do array** referencia o **endere√ßo da primeira posi√ß√£o** (posi√ß√£o base). A partir desse endere√ßo, os demais elementos s√£o acessados por meio de **c√°lculos de deslocamento com base no √≠ndice**, considerando o tamanho de cada elemento. Por exemplo, se cada elemento ocupa 4 bytes, o elemento de √≠ndice 3 estar√° a 12 bytes da posi√ß√£o base.
>
>Essa organiza√ß√£o permite um **acesso direto e eficiente** aos elementos, mas exige que o tamanho do array seja conhecido no momento da aloca√ß√£o, pois n√£o √© poss√≠vel redimensionar arrays fixos sem realocar a mem√≥ria.

<br />

**Sintaxe - Vetor com atribui√ß√£o de valores**

```java
tipo_de_dado identificadorDoVetor[] = {v1, v2, v3,..., vn};
```

ou

```java
tipo_de_dado[] identificadorDoVetor = {v1, v2, v3,..., vn};
```

Nesta forma, os valores s√£o atribu√≠dos diretamente no momento da declara√ß√£o. A quantidade de elementos √© definida automaticamente com base nos dados informados. 

`v1, ... , vn` s√£o os valores atribu√≠dos, separados por v√≠rgulas.

<br />

**Sintaxe - Vetor sem atribui√ß√£o de valores:**

```java
tipo_de_dado identificadorDoVetor[] = new tipo_de_dado[tamanho];
```

ou

```java
tipo_de_dado[] identificadorDoVetor = new tipo_de_dado[tamanho];
```

Nesse formato, o vetor √© declarado sem valores iniciais. O tamanho do vetor √©  definido manualmente, e os elementos recebem valores padr√£o conforme o tipo de dado.

<br />

<h3>1.1. Tipo</h3>



Este par√¢metro define o **tipo de dado** que ser√° armazenado no vetor. Assim como nas vari√°veis comuns, o tipo deve ser declarado no momento da cria√ß√£o e determina os valores que o vetor poder√° armazenar.

Abaixo, alguns tipos primitivos e de refer√™ncia mais utilizados em vetores:

| Tipo     | Descri√ß√£o                               | Exemplo de valor    |
| -------- | --------------------------------------- | ------------------- |
| `int`    | N√∫meros inteiros                        | `10`, `25`, `-3`    |
| `double` | N√∫meros decimais com dupla precis√£o     | `3.14`, `7.89`      |
| `float`  | N√∫meros decimais com menor precis√£o     | `2.5f`, `8.7f`      |
| `char`   | Caracteres √∫nicos                       | `'A'`, `'Z'`, `'1'` |
| `String` | Cadeias de texto (objeto de refer√™ncia) | `"Ol√°"`, `"Java"`   |

O tipo deve ser **compat√≠vel com os valores** que se deseja armazenar no vetor e n√£o pode ser alterado ap√≥s a declara√ß√£o.

<br />

<h3>1.2. Identificador do Vetor</h3>



Na programa√ß√£o Java, **vetores** s√£o **vari√°veis especiais** e, por isso, seguem as mesmas **regras e conven√ß√µes de nomea√ß√£o** usadas para vari√°veis comuns. Isso garante clareza, organiza√ß√£o e legibilidade no c√≥digo.

#### ‚úÖ **Regras para nomear vetores (identificadores):**

- Utilize o padr√£o *Camel Case*, ou seja, **a primeira palavra com letra min√∫scula, pr√≥ximas iniciam com mai√∫scula**, que √© o mesmo padr√£o usado pelo Java para nomear vari√°veis.
- O nome **pode conter** letras, n√∫meros, sublinhado (`_`) e cifr√£o (`$`).
- O nome **deve come√ßar com** uma letra, um `_` ou um `$`.
- **N√£o pode come√ßar com n√∫mero.**
- **N√£o pode usar palavras reservadas** do Java (como `int`, `for`, `class`, `null`, etc.).
- O nome **deve ser √∫nico** dentro do escopo e representar claramente o que o vetor armazena.
- O nome **pode ter qualquer tamanho**, mas recomenda-se que seja **curto e descritivo**.
- Utilize **nomes no plural** para vetores: `notas`, `contas`, `produtos`, `listaDeCompras`, entre outros.

<br />

> [!IMPORTANT]
>
> Seguindo as Boas Pr√°ticas, o identificador do vetor deve expressar exatamente o seu conte√∫do. Evite utilizar nomes gen√©ricos como v1, vetor_01, entre outros.

<br />

<h3>1.3. Declarando Vetores</h3>



Vamos entender como declarar um vetor:

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - Vetor com dados do tipo inteiro

```java
int numeros[] = {10, 15, 35, 70, 140};
```

<br />

<div align="center"><img src="https://i.imgur.com/YILRPx6.png" title="source: imgur.com" /></div>

Na imagem acima, √© poss√≠vel observar a aloca√ß√£o de mem√≥ria para um vetor de n√∫meros inteiros. Cada elemento do vetor ocupa uma posi√ß√£o espec√≠fica, onde seu valor est√° armazenado de forma organizada e sequencial.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - Vetor com dados do tipo String

```java
String racasCaes[] = {"Boxer", "Pastor Alem√£o", "Pinscher", "Husky Siberiano", "Corgi"};
```

<br />

<div align="center"><img src="https://i.imgur.com/Tw9GfYr.png" title="source: imgur.com" /></div>

Na imagem acima, observa-se a aloca√ß√£o de mem√≥ria para um vetor composto por caracteres, representado pelo tipo String. Cada palavra est√° armazenada em uma posi√ß√£o distinta do vetor.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Vetor vazio

```java
float descontos[] = new float[5];
```

<br />

<div align="center"><img src="https://i.imgur.com/WML81no.png" title="source: imgur.com" /></div>

Na imagem acima, √© ilustrada a **aloca√ß√£o de mem√≥ria** para um **vetor do tipo `float`**, ainda **sem valores atribu√≠dos**.

Observe que todas as posi√ß√µes ser√£o preenchidas com o **valor padr√£o `0.0f`**, pois, em Java, ao declarar uma matriz de tipos num√©ricos sem atribui√ß√£o expl√≠cita, cada elemento recebe automaticamente o valor padr√£o correspondente ao seu tipo.

Para inserir dados nesse vetor, seria necess√°rio **atribuir valores de forma direta** ou utilizar a **classe Scanner**, permitindo a entrada de dados via teclado durante a execu√ß√£o do programa.

<br />

<h3>1.4. Acessar uma posi√ß√£o do Vetor</h3>



Para acessar os dados armazenados em uma posi√ß√£o espec√≠fica do vetor, utilizamos o **nome do vetor seguido de colchetes**. Dentro dos colchetes, indicamos o **√≠ndice**, que corresponde √† posi√ß√£o cujos dados queremos obter.

**Sintaxe:**

```java
identificador_do_vetor[indice];
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 04 - Exibindo os dados do vetor

<br />

**C√≥digo Java - Vers√£o 01**

```java
package exemplos_arrays;

public class Exemplo04 {

	public static void main(String[] args) {

		String racasCaes[] = {"Boxer","Pastor Alem√£o","Pinscher","Husky Siberiano","Corgi"};
	    
        System.out.println("1¬∫ elemento: " + racasCaes[0]);
        System.out.println("2¬∫ elemento: " + racasCaes[1]);
        System.out.println("3¬∫ elemento: " + racasCaes[2]);
        System.out.println("4¬∫ elemento: " + racasCaes[3]);
        System.out.println("5¬∫ elemento: " + racasCaes[4]);

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
1¬∫ elemento: Boxer
2¬∫ elemento: Pastor Alem√£o
3¬∫ elemento: Pinscher
4¬∫ elemento: Husky Siberiano
5¬∫ elemento: Corgi
```

Observe no exemplo, que o √≠ndice √© uma sequ√™ncia num√©rica, e o comando `System.out.println()` √© repetido cinco vezes com o mesmo conte√∫do, alterando apenas o √≠ndice do vetor. 

Como se trata de uma repeti√ß√£o, podemos simplificar esse c√≥digo utilizando um la√ßo de repeti√ß√£o. Vamos reescrever este exemplo adicionando um la√ßo de repeti√ß√£o. 

<br />

**C√≥digo Java - Vers√£o 02**

```java
package exemplos_arrays;

public class Exemplo04 {

	public static void main(String[] args) {

		String racasCaes[] = { "Boxer", "Pastor Alem√£o", "Pinscher", "Husky Siberiano", "Corgi" };

		for (int indice = 0; indice < 5; indice++) {
			System.out.println((indice + 1) + "¬∫ elemento: " + racasCaes[indice]);
		}

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
1¬∫ elemento: Boxer
2¬∫ elemento: Pastor Alem√£o
3¬∫ elemento: Pinscher
4¬∫ elemento: Husky Siberiano
5¬∫ elemento: Corgi
```

Observe que o resultado foi o mesmo; no entanto, ao utilizar o **la√ßo de repeti√ß√£o**, o c√≥digo ficou mais simples e mais f√°cil de manter.

<br />

<h3>1.5. Entrada de dados - Vetor vazio</h3>



Os dados em um vetor podem ser inseridos diretamente por atribui√ß√£o ou por meio da entrada via teclado. Embora a atribui√ß√£o direta seja simples, utilizar o teclado para inserir valores torna o programa mais din√¢mico e interativo. Para isso, usamos uma inst√¢ncia da classe **Scanner**, que chamaremos de **leia**.

```java
Scanner leia = new Scanner(System.in);
```

Para armazenar um valor em cada posi√ß√£o do vetor, utilizamos o nome do vetor (identificador) seguido do √≠ndice correspondente, onde ser√° atribu√≠do o dado digitado pelo usu√°rio atrav√©s do comando **leia**.

**Sintaxe:**

```java
identificador_do_vetor[indice] = leia.metodo_entrada(); 
```

*O M√©todo de entrada do Objeto leia depender√° do tipo de dado do vetor.*

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 05 - Inserindo dados no vetor vazio

```java
package exemplos_arrays;

import java.util.Scanner;

public class Exemplo05 {

	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int numeros[] = new int[5];

		for (int indice = 0; indice < 5; indice++) {
			System.out.println("Digite o " + (indice + 1) + "¬∫ N√∫mero: ");
			numeros[indice] = leia.nextInt();
		}

		System.out.println("\nOs n√∫meros digitados foram: \n");

		for (int indice = 0; indice < 5; indice++) {
			System.out.println((indice + 1) + "¬∫ n√∫mero: " + numeros[indice]);
		}

		leia.close();
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Digite o 1¬∫ N√∫mero: 
10
Digite o 2¬∫ N√∫mero: 
20
Digite o 3¬∫ N√∫mero: 
30
Digite o 4¬∫ N√∫mero: 
40
Digite o 5¬∫ N√∫mero: 
50

Os n√∫meros digitados foram: 

1¬∫ n√∫mero: 10
2¬∫ n√∫mero: 20
3¬∫ n√∫mero: 30
4¬∫ n√∫mero: 40
5¬∫ n√∫mero: 50
```

Neste exemplo, o vetor foi preenchido com os dados obtidos via teclado e, ao concluir o preenchimento, os valores armazenados foram exibidos na tela.

<br>

<h3>1.6. Tamanho de um Vetor</h3>



Nos exemplos anteriores, definimos manualmente o tamanho do vetor dentro do la√ßo de repeti√ß√£o. Por√©m, na pr√°tica, cada vetor pode ter um tamanho diferente, e seria interessante automatizar esse processo. 

Para automatizar este processo, vamos utiliza a propriedade **length**, que identifica automaticamente o tamanho do vetor, permitindo que o c√≥digo se adapte a diferentes tamanhos de forma din√¢mica.

**Sintaxe:**

```java
identificador_do_vetor.length;
```

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 06 - Tamanho do vetor - Propriedade length

```java
package exemplos_arrays;

public class Exemplo06 {

	public static void main(String[] args) {

		String racasCaes[] = { "Boxer", "Pastor Alem√£o", "Pinscher", "Husky Siberiano", "Corgi" };

		System.out.println("Itens aramazenados no vetor: \n");

		for (int indice = 0; indice < racasCaes.length; indice++) {
			System.out.println(racasCaes[indice]);
		}

		System.out.println("\nO tamanho do seu vetor √©: " + racasCaes.length);
	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Itens armazenados no vetor: 

Boxer
Pastor Alem√£o
Pinscher
Husky Siberiano
Corgi

O tamanho do seu vetor √©: 5
```

Observe que, neste exemplo, utilizamos o m√©todo **length** n√£o apenas para exibir o tamanho do vetor, mas tamb√©m dentro do la√ßo de repeti√ß√£o **for**, como segundo par√¢metro, para definir a **condi√ß√£o de parada**. Dessa forma, n√£o √© necess√°rio informar manualmente um n√∫mero fixo, tornando o c√≥digo mais flex√≠vel e adapt√°vel ao tamanho real do vetor.

<br />

<h3>1.7. M√©todos da Classe Arrays</h3>



A **classe `Arrays`** pertence ao pacote `java.util` e oferece diversos m√©todos utilit√°rios para facilitar a manipula√ß√£o de arrays. Esses m√©todos s√£o compat√≠veis com arrays de qualquer tipo ‚Äî sejam eles de tipos primitivos ou de objetos.

### ‚úÖ **Principais m√©todos da classe Arrays:**

| M√©todo                                           | Descri√ß√£o                                                    |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `Arrays.sort(array)`                             | Ordena os elementos de um array de tipos primitivos em ordem crescente. |
| `Arrays.sort(array, Collections.reverseOrder())` | Ordena os elementos de um array de objetos em ordem decrescente.Para utilizar com tipos primitivos, √© necess√°rio convert√™-los para **Wrappers** (veremos isso mais adiante). |
| `Arrays.equals(array1, array2)`                  | Compara dois arrays, retornando `true` se ambos tiverem o mesmo conte√∫do, nas mesmas posi√ß√µes e forem do mesmo tipo. |
| `Arrays.binarySearch(array, chave)`              | Retorna o √≠ndice do elemento procurado em um array. O array deve estar previamente ordenado e sem valores duplicados. |
| `Arrays.fill(array, valor)`                      | Preenche todas as posi√ß√µes do array com o valor especificado. |
| `Arrays.compare(array1, array2)`                 | Compara dois arrays com base em seu conte√∫do, retornando `0` se forem iguais, valor negativo se o primeiro for "menor" ou positivo se for "maior". |

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 07 - Ordenando um vetor de Strings

```java
package exemplos_arrays;

import java.util.Arrays;
import java.util.Collections;

public class Exemplo07 {

	public static void main(String[] args) {
		
		String arrayNomes[] = { "Samantha", "Amanda", "Vinicius", "Cau√™", "Leonardo" };

		Arrays.sort(arrayNomes);

		System.out.println("Array em Ordem Crescente \n");
		for (int indice = 0; indice < arrayNomes.length; indice++) {
			System.out.println(arrayNomes[indice]);
		}

		Arrays.sort(arrayNomes, Collections.reverseOrder());

		System.out.println("\nArray em Ordem Decrescente \n");
		for (int indice = 0; indice < arrayNomes.length; indice++) {
			System.out.println(arrayNomes[indice]);
		}

	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Array em Ordem Crescente 

Amanda
Cau√™
Leonardo
Samantha
Vinicius

Array em Ordem Decrescente 

Vinicius
Samantha
Leonardo
Cau√™
Amanda
```

Este exemplo demonstra como utilizar a classe **`Arrays`** para ordenar um vetor de nomes do tipo `String`. Inicialmente, o array `arrayNomes` √© ordenado em **ordem crescente** com o m√©todo `Arrays.sort()`, exibindo os nomes em ordem alfab√©tica. Em seguida, o mesmo array √© reordenado em **ordem decrescente** utilizando `Arrays.sort()` em conjunto com `Collections.reverseOrder()`. 

Como se trata de um vetor de objetos (`String`), √© poss√≠vel aplicar essa ordena√ß√£o reversa diretamente, sem necessidade de convers√£o para wrappers. O resultado √© exibido no console com dois la√ßos `for`, um para cada ordena√ß√£o.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 08 - Ordenando um vetor de primitivos

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo08 {

    public static void main(String[] args) {
        
        int vetorInteiros[] = { 3, 2, 1, 6, 5, 10, 7, 4, 9, 8 };

		Arrays.sort(vetorInteiros);

		System.out.println("Array de primitivos em Ordem Crescente \n");
		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			System.out.println(vetorInteiros[indice]);
		}

		System.out.println("\nArray de primitivos em Ordem Decrescente \n");
		
		int[] reverseArray = new int[vetorInteiros.length];

		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			reverseArray[indice] = vetorInteiros[(vetorInteiros.length - 1) - indice];
		}

		for (int indice = 0; indice < vetorInteiros.length; indice++) {
			System.out.println(reverseArray[indice]);
		}
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Array de primitivos em Ordem Crescente 

1
2
3
4
5
6
7
8
9
10

Array de primitivos em Ordem Decrescente 

10
9
8
7
6
5
4
3
2
1
```

Este exemplo mostra como ordenar um vetor de n√∫meros inteiros (tipos primitivos) em **ordem crescente e decrescente** utilizando a classe **`Arrays`**. Primeiro, o vetor `vetorInteiros` √© ordenado em ordem crescente com o m√©todo `Arrays.sort()`. 

Como n√£o √© poss√≠vel usar `Collections.reverseOrder()` diretamente com tipos primitivos, para exibir os valores em **ordem decrescente**, foi criado um novo vetor (`reverseArray`), preenchido manualmente com os elementos do vetor original em ordem inversa. Por fim, ambos os resultados s√£o exibidos no console por meio de la√ßos de repeti√ß√£o `for`.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 09 - Comparando vetores

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo09 {

	public static void main(String[] args) {

		String grupoA[] = { "Amanda", "Elen", "Vinicius" };
		String grupoB[] = { "Samantha", "Let√≠cia", "Alan" };

		System.out.println("Os Arrays s√£o iguais? ");

		if (Arrays.equals(grupoA, grupoB)) {
			System.out.println("Sim, s√£o iguais.");
		} else {
			System.out.println("N√£o, s√£o diferentes.");
		}

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Os Arrays s√£o iguais? 
N√£o, s√£o diferentes.
```

Este exemplo ilustra o uso do m√©todo **`Arrays.equals()`** para comparar dois vetores do tipo `String`. Os arrays `grupoA` e `grupoB` cont√™m nomes diferentes, e a compara√ß√£o verifica se ambos possuem os **mesmos elementos, na mesma ordem e do mesmo tipo**. Como os valores s√£o distintos, o m√©todo retorna `false`, e a mensagem exibida √© "N√£o, s√£o diferentes." Esse m√©todo √© √∫til para verificar a igualdade exata entre arrays em aplica√ß√µes que exigem valida√ß√£o de conte√∫do.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 10 - Localizando um dado no vetor - M√©todo binarySearch()

```java
package exemplos_arrays;

import java.util.Arrays;

public class Exemplo10 {

	public static void main(String[] args) {

		float descontos[] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 10.0f, 7.0f, 6.0f, 9.0f, 8.0f };

		// Ordena o vetor
		Arrays.sort(descontos);

		System.out.println("\nVetor Ordenado");

		for (int indice = 0; indice < descontos.length; indice++) {
			System.out.println(descontos[indice]);
		}

		System.out.println("\nO elemento 10.0 existe? Qual √© a posi√ß√£o?");

		int posicao = Arrays.binarySearch(descontos, 10.0f);

		// Se a posi√ß√£o for positiva = Encontrou
		if (posicao >= 0) {
			System.out.println("\nO elemento foi encontrado e est√° na posi√ß√£o: " + posicao);
		} else {
			System.out.println("\nElemento n√£o encontrado!");
		}
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash

Vetor Ordenado
1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0

O elemento 10.0 existe? Qual √© a posi√ß√£o?

O elemento foi encontrado e est√° na posi√ß√£o: 9
```

Este exemplo demonstra a utiliza√ß√£o da classe **`Arrays`** com um vetor do tipo **`float`**. O vetor `descontos` √© preenchido com valores reais e, em seguida, ordenado em ordem crescente utilizando o m√©todo **`Arrays.sort()`**. Ap√≥s a ordena√ß√£o, os valores s√£o exibidos no console por meio de um la√ßo `for`. 

Na sequ√™ncia, o c√≥digo realiza a busca do valor `10.0f` no vetor ordenado utilizando o m√©todo **`Arrays.binarySearch()`**, que retorna o √≠ndice da posi√ß√£o onde o valor foi encontrado. Caso o valor esteja presente, sua posi√ß√£o √© exibida; caso contr√°rio, uma mensagem informa que o elemento n√£o foi encontrado. 

> [!WARNING]
>
> Ao atribuir um valor para uma vari√°vel do tipo `float`, **√© obrigat√≥rio incluir casas decimais** (mesmo que seja `.0`) e **acrescentar a letra `f` ou `F` no final**, para indicar que o valor √© do tipo `float` e n√£o `double` (que √© o padr√£o para n√∫meros com ponto flutuante).

<br />

<h2>2. O La√ßo de Repeti√ß√£o for...each</h2>



A express√£o em ingl√™s *‚Äúfor each‚Äù* pode ser traduzida como **‚Äúpara cada‚Äù**. Em Java, o la√ßo de repeti√ß√£o **for-each** √© utilizado para iterar listas, arrays e outras cole√ß√µes de forma simplificada. Sua principal vantagem √© **tornar o c√≥digo mais leg√≠vel e menos propenso a erros**, ao eliminar a necessidade de manipular √≠ndices manualmente.

O la√ßo **for-each** percorre todos os elementos de um array ou cole√ß√£o automaticamente, evitando problemas comuns, como come√ßar o contador pelo √≠ndice errado (por exemplo, 1 em vez de 0) ou ultrapassar os limites da estrutura. Dessa forma, ele facilita a escrita e a manuten√ß√£o do c√≥digo.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> Mantenha a Orienta√ß√£o ao Futuro!
>
> Se os termos **Cole√ß√µes** ou **Collections** ainda n√£o forem familiares para voc√™, n√£o se preocupe. Em breve, teremos um conte√∫do dedicado exclusivamente a esse assunto.

<br />

**Sintaxe:**

```bash
for(tipo identificador : array){
    // comando a serem executados
}
```

<br />

<h3>2.1. Tipo</h3>



Refere-se ao tipo dos elementos contidos no array (ou cole√ß√£o) que ser√° percorrido pelo la√ßo **for-each**.

**Exemplo:** Se o array √© do tipo `String[]`, a vari√°vel tamb√©m ser√° do tipo `String`.

<br />

<h3>2.2. Identificador</h3>



√â o nome da vari√°vel que representa o elemento atual da itera√ß√£o, eliminando a necessidade de manipular √≠ndices. Funciona como uma refer√™ncia direta ao item do array ou cole√ß√£o, similar a `nome_do_array[indice]` em um la√ßo de repeti√ß√£o tradicional.

<br />

<h3>2.3. Array</h3>



√â a estrutura de dados que ter√° seus elementos percorridos, podendo ser um array ou uma cole√ß√£o.

Vamos criar um programa que exibe, no console, os nomes dos alunos armazenados em um vetor. Na primeira vers√£o, utilizaremos o **la√ßo `for`** e na segunda utilizaremos o **la√ßo `for-each`**, permitindo uma compara√ß√£o entre as abordagens.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 11 - Percorrendo um Vetor com o for...each

<br />

**C√≥digo Java - Vers√£o 01**

```java
package exemplos_arrays;

public class Exemplo11 {

	public static void main(String[] args) {

		String alunos[] = { "Felipe", "Jonas", "Julia", "Marcos", "Jana√≠na" };

        for(int indice = 0; indice < alunos.length; indice++) {
            System.out.println(alunos[indice]);
        }

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Felipe
Jonas
Julia
Marcos
Jana√≠na
```

<br />

**C√≥digo Java - Vers√£o 02**

```java
package exemplos_arrays;

public class Exemplo11 {

	public static void main(String[] args) {

		String alunos[] = { "Felipe", "Jonas", "Julia", "Marcos", "Jana√≠na" };

        for (String aluno : alunos) {
            System.out.println(aluno);
        }

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Felipe
Jonas
Julia
Marcos
Jana√≠na
```

Observe que, na **segunda vers√£o do c√≥digo**, com o uso do la√ßo **`for-each`**, foi necess√°rio declarar apenas **uma √∫nica vari√°vel (`aluno)**, que representa diretamente cada elemento do vetor. Isso torna o c√≥digo **mais simples, limpo e f√°cil de compreender**, especialmente para quem est√° iniciando na programa√ß√£o.

Em termos de **performance**, na maioria dos casos **n√£o h√° diferen√ßa significativa** entre o la√ßo `for` tradicional e o la√ßo `for-each`. Isso ocorre porque, durante a execu√ß√£o, ambos s√£o interpretados e processados de forma semelhante pela m√°quina virtual Java (JVM). A principal diferen√ßa est√° na **legibilidade e na praticidade de uso**, e n√£o no desempenho.

Apesar da simplicidade e legibilidade que o la√ßo **`for-each`** proporciona, ele possui uma limita√ß√£o importante: **n√£o √© poss√≠vel acessar diretamente o √≠ndice dos elementos durante a itera√ß√£o**.

Isso acontece porque o `for-each` foi projetado para **percorrer os elementos de forma sequencial**, sem se preocupar com sua posi√ß√£o na estrutura. A vari√°vel declarada dentro do la√ßo representa apenas o **valor atual**, e **n√£o a sua posi√ß√£o** dentro do array ou da cole√ß√£o.

<br />

Para fixar o conte√∫do, vamos atualizar o exemplo do **Card√°pio Digital de uma Cantina Italiana**, adicionando um vetor para guardar os produtos do card√°pio.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" width="5%"/>Exemplo 12 - Card√°pio - Vers√£o Matriz

```java
package exemplos_arrays;

import java.util.Scanner;

public class Exemplo12 {

    public static void main(String[] args) {

        Scanner leia = new Scanner(System.in);
        char categoria;

        // Arrays com os itens e pre√ßos para cada categoria
        String[] antipasti = {
            "Bruschetta al Pomodoro ......... R$ 16,00",
            "Carpaccio di Manzo ............. R$ 24,90",
            "Caprese com Pesto .............. R$ 21,50"
        };

        String[] primiPiatti = {
            "Spaghetti alla Carbonara ....... R$ 36,90",
            "Lasagna alla Bolognese ......... R$ 39,50",
            "Gnocchi al Pesto ................ R$ 34,00"
        };

        String[] bevande = {
            "√Ågua com g√°s .................... R$ 5,00",
            "Suco de Uva Integral ............ R$ 9,00",
            "Vinho Tinto (ta√ßa) .............. R$ 18,00"
        };

        String[] dolci = {
            "Tiramisu Tradicional ............ R$ 12,00",
            "Cannoli Siciliani ............... R$ 10,50",
            "Panna Cotta com Frutas Vermelhas R$ 11,90"
        };

        System.out.println("=== Card√°pio da Cantina Italiana ===");
        System.out.println("E - Antipasti (Entradas)");
        System.out.println("P - Primi Piatti (Pratos principais)");
        System.out.println("B - Bevande (Bebidas)");
        System.out.println("D - Dolci (Sobremesas)");
        System.out.println("S - Sair");

        do {
            System.out.print("\nDigite a letra da categoria desejada: ");
            String entrada = leia.next().trim().toUpperCase();

            if (entrada.length() > 0) {
                categoria = entrada.charAt(0);
            } else {
                categoria = ' ';
            }

            switch (categoria) {
                case 'E':
                    System.out.println("\n-- Antipasti --");
                    for (String item : antipasti) {
                        System.out.println("‚Ä¢ " + item);
                    }
                    break;
                case 'P':
                    System.out.println("\n-- Primi Piatti --");
                    for (String item : primiPiatti) {
                        System.out.println("‚Ä¢ " + item);
                    }
                    break;
                case 'B':
                    System.out.println("\n-- Bevande --");
                    for (String item : bevande) {
                        System.out.println("‚Ä¢ " + item);
                    }
                    break;
                case 'D':
                    System.out.println("\n-- Dolci --");
                    for (String item : dolci) {
                        System.out.println("‚Ä¢ " + item);
                    }
                    break;
                case 'S':
                    System.out.println("Grazie! Volte sempre √† nossa cantina!");
                    break;
                default:
                    System.out.println("Categoria inv√°lida. Por favor, tente novamente.");
            }
        } while (categoria != 'S');

        leia.close();
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
=== Card√°pio da Cantina Italiana ===
E - Antipasti (Entradas)
P - Primi Piatti (Pratos principais)
B - Bevande (Bebidas)
D - Dolci (Sobremesas)
S - Sair

Digite a letra da categoria desejada: e

-- Antipasti --
‚Ä¢ Bruschetta al Pomodoro ......... R$ 16,00
‚Ä¢ Carpaccio di Manzo ............. R$ 24,90
‚Ä¢ Caprese com Pesto .............. R$ 21,50

Digite a letra da categoria desejada: d

-- Dolci --
‚Ä¢ Tiramisu Tradicional ............ R$ 12,00
‚Ä¢ Cannoli Siciliani ............... R$ 10,50
‚Ä¢ Panna Cotta com Frutas Vermelhas R$ 11,90

Digite a letra da categoria desejada: s
Grazie! Volte sempre √† nossa cantina!
```

Nesta atualiza√ß√£o, realizamos as seguintes melhorias:

- Os **itens do card√°pio foram organizados em vetores do tipo `String[]`**, separados por categoria (entradas, pratos principais, bebidas e sobremesas), o que facilita o acesso e a exibi√ß√£o dos dados.
- A **categoria escolhida pelo usu√°rio passou a ser representada por uma vari√°vel do tipo `char`**, tornando o c√≥digo mais enxuto e direto ao comparar a op√ß√£o digitada.
- Ao digitar a letra correspondente √† categoria (`E`, `P`, `B` ou `D`), o programa identifica o vetor associado e exibe os itens formatados com nome e pre√ßo.
- Tamb√©m foi mantida a op√ß√£o `S` para **encerrar a execu√ß√£o com uma mensagem personalizada de despedida**.

Com essas mudan√ßas, o c√≥digo ficou mais **organizado, leg√≠vel e f√°cil de manter**, al√©m de proporcionar uma navega√ß√£o simples e objetiva para o usu√°rio do sistema.

<br />

## üÜö Tabela Comparativa: `for` vs `for...each`

| **For**                                                      | **for...each**                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Requer a declara√ß√£o expl√≠cita de controle de repeti√ß√£o, incluindo inicializa√ß√£o, condi√ß√£o e incremento ou decremento. | O controle da repeti√ß√£o √© feito automaticamente, com incremento interno a cada itera√ß√£o. N√£o permite personaliza√ß√£o do fluxo. |
| Apropriado quando √© necess√°rio acessar ou modificar elementos com base no √≠ndice. | N√£o √© indicado quando h√° necessidade de acessar o √≠ndice ou modificar diretamente os elementos com base em sua posi√ß√£o. |
| Permite o acesso direto ao √≠ndice dos elementos do array ou cole√ß√£o. | N√£o oferece acesso ao √≠ndice; apenas ao valor de cada elemento. |

<br />

------

## üîë**Pontos chave:**

1. **Arrays** s√£o estruturas de dados que armazenam m√∫ltiplos elementos do **mesmo tipo**, acessados por meio de **√≠ndices num√©ricos**. O √≠ndice do primeiro elemento √© sempre `0`.
2. Os arrays em Java possuem **tamanho fixo**, definido no momento da sua cria√ß√£o. A mem√≥ria √© alocada de forma **cont√≠gua**, o que permite acesso r√°pido aos elementos, mas impede redimensionamento sem realoca√ß√£o.
3. Existem **tr√™s tipos principais de arrays** em Java:
   - **Unidimensionais (Vetores):** Representam uma sequ√™ncia linear de dados (exemplo: lista de nomes).
   - **Bidimensionais (Matrizes):** S√£o tabelas com linhas e colunas (exemplo: tabela de pre√ßos).
   - **Multidimensionais:** S√£o arrays com tr√™s ou mais dimens√µes, como uma matriz tridimensional (exemplo: cubo de dados).
4. A sintaxe de declara√ß√£o de um array pode incluir ou n√£o a atribui√ß√£o inicial de valores.
5. Para acessar ou modificar um elemento do array, utilizamos o nome do array seguido do √≠ndice entre colchetes.
6. A propriedade `.length` retorna o **tamanho do array**, ou seja, a quantidade de elementos. Esta propriedade pode ser usada para automatizar la√ßos de repeti√ß√£o.
7. O la√ßo **`for-each`** permite percorrer todos os elementos de um array de forma mais simples e leg√≠vel, sem a necessidade de controlar manualmente os √≠ndices.
8. O **`for-each`** √© ideal para **leitura** dos elementos. No entanto, n√£o permite acesso direto ao √≠ndice, sendo limitado para casos onde √© necess√°rio modificar elementos em posi√ß√µes espec√≠ficas.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
