<h1>Optional</h1>



A classe **`Optional`**, introduzida no Java 8, tem como principal objetivo simplificar o c√≥digo, tornando-o mais seguro e leg√≠vel, especialmente ao lidar com valores que podem estar ausentes (*null*). Esse recurso facilita a vida dos desenvolvedores ao ajudar a evitar erros comuns, como o temido **`NullPointerException`**.

A proposta central do `Optional` √© **encapsular valores de retorno de m√©todos**, permitindo indicar de forma expl√≠cita se um valor do tipo gen√©rico `<T>` est√° presente ou ausente.

> **Java Generics** permitem que classes, interfaces e m√©todos operem sobre tipos parametrizados. A classe `Optional`, por exemplo, √© uma classe gen√©rica, definida como `Optional<T>`, onde **`T`** representa o tipo do valor que pode ou n√£o estar presente.
>
> Essa abordagem evita a necessidade de *casts* (convers√µes de tipo), tornando o c√≥digo mais seguro em tempo de compila√ß√£o, al√©m de mais limpo e expressivo.

Fazendo uma analogia simples, o `Optional` pode ser visto como uma **caixa que guarda (encapsula) um valor**, com mecanismos que ajudam a verificar se h√° algo dentro antes de acess√°-lo. Isso reduz consideravelmente a ocorr√™ncia de acessos indevidos a refer√™ncias nulas e promove pr√°ticas de programa√ß√£o mais robustas e seguras.

<div align="center"><img src="https://i.imgur.com/7JzXM53.png" title="source: imgur.com" /></div>

O `Optional` √© ideal para retornos de m√©todos em que a aus√™ncia de valor √© uma possibilidade esperada. No entanto, **n√£o deve ser utilizado para atributos de inst√¢ncia de classes**, nem para representar valores cuja exist√™ncia √© obrigat√≥ria, pois isso pode comprometer o desempenho e a clareza do modelo.

Sempre que for necess√°rio acessar o valor encapsulado em um objeto `Optional`, podemos utilizar os **m√©todos fornecidos pela classe**. Os principais m√©todos ser√£o apresentados na sequ√™ncia deste conte√∫do.

A classe `Optional` contribui de forma significativa para as seguintes tarefas:

- **Evitar erros do tipo `NullPointerException`**, ao encapsular valores que podem estar ausentes;
- **Eliminar a necessidade de verifica√ß√µes manuais** com `if (variavel != null)`, tornando o c√≥digo mais fluido e expressivo;
- **Permitir a escrita de c√≥digos mais concisos, limpos e elegantes**, ao adotar uma abordagem funcional e segura para lidar com valores opcionais.

**Sintaxe:**

```java
// Cria um Optional vazio (sem valor)
Optional<String> optional = Optional.empty();

// Cria um Optional com um valor que n√£o pode ser nulo
Optional<String> optional = Optional.of(palavra[5]);

// Cria um Optional com valor que pode ser nulo
Optional<String> optional = Optional.ofNullable(palavra[5]);
```

Como vimos acima, existem **tr√™s m√©todos principais** para criar um objeto da classe `Optional`:

| M√©todo                    | Descri√ß√£o                                                    |
| ------------------------- | ------------------------------------------------------------ |
| **`empty()`**             | Retorna uma inst√¢ncia vazia de `Optional`. √â equivalente a `Optional.ofNullable(null)` e geralmente usada quando se deseja representar a aus√™ncia expl√≠cita de valor. |
| **`of(T value)`**         | Retorna um `Optional` contendo o valor fornecido, desde que ele **n√£o seja nulo**. Caso contr√°rio, uma exce√ß√£o `NullPointerException` ser√° lan√ßada. |
| **`ofNullable(T value)`** | Retorna um `Optional` contendo o valor, caso ele n√£o seja nulo. Se o valor for nulo, retorna um `Optional` vazio. Este m√©todo √© recomendado quando h√° possibilidade de aus√™ncia do valor. |

<br />

## üÜö Tabela Comparativa:  Null Check Tradicional vs Optional

| Null Check Tradicional          | Optional                                        |
| ------------------------------- | ----------------------------------------------- |
| `if (objeto != null)`           | `Optional.ofNullable(objeto).isPresent()`       |
| Propenso a NullPointerException | Encapsula e obriga o tratamento seguro          |
| C√≥digo mais verboso             | C√≥digo fluido e expressivo (m√©todos encadeados) |

<br />

<h3>1.1. Principais M√©todos  da Classe Optional</h3>



A classe `Optional` fornece uma s√©rie de m√©todos utilit√°rios que permitem manipular valores de forma segura, funcional e expressiva. Esses m√©todos ajudam a:

- Verificar a presen√ßa ou aus√™ncia de um valor;
- Executar a√ß√µes condicionais;
- Aplicar transforma√ß√µes (como `map` e `flatMap`);
- Fornecer valores alternativos ou lan√ßar exce√ß√µes, caso o valor esteja ausente.

Essa abordagem reduz a necessidade de condicionais expl√≠citos (`if/else`) e promove um estilo de programa√ß√£o mais limpo, principalmente quando combinada com express√µes lambda.

| M√©todo              | Descri√ß√£o                                                    |
| ------------------- | ------------------------------------------------------------ |
| **`filter()`**      | Retorna o valor se ele atender a uma condi√ß√£o; caso contr√°rio, retorna `Optional.empty()`. |
| **`isPresent()`**   | Retorna `true` se houver valor presente; caso contr√°rio, retorna `false`. |
| **`isEmpty()`**     | Retorna `true` se **n√£o houver valor presente**; equivalente a `!isPresent()`. |
| **`get()`**         | Retorna o valor, se presente. Caso contr√°rio, lan√ßa `NoSuchElementException`. Deve ser usado com cautela. |
| **`ifPresent()`**   | Executa uma a√ß√£o **somente se** o valor estiver presente.    |
| **`map()`**         | Transforma o valor presente e retorna um novo `Optional` com o resultado. Se vazio, retorna `Optional.empty()`. |
| **`flatMap()`**     | Igual ao `map()`, mas evita `Optional` aninhado quando a transforma√ß√£o j√° retorna um `Optional`. |
| **`orElse()`**      | Retorna o valor, se presente; caso contr√°rio, retorna um valor padr√£o informado. |
| **`orElseGet()`**   | Retorna o valor, se presente; caso contr√°rio, executa um c√≥digo para gerar o valor padr√£o. |
| **`orElseThrow()`** | Retorna o valor, se presente; caso contr√°rio, lan√ßa uma exce√ß√£o definida pelo desenvolvedor. |

<br />

### ‚úÖ Observa√ß√µes importantes

- Os m√©todos `map()` e `flatMap()` s√£o frequentemente utilizados **em conjunto com Express√µes Lambda**, que veremos mais adiante, permitindo composi√ß√£o fluente de opera√ß√µes.
- M√©todos como `orElse()`, `orElseGet()` e `orElseThrow()` s√£o comumente utilizados ap√≥s chamadas a `map()` ou `flatMap()` para tratar valores ausentes, **mas n√£o dependem diretamente desses m√©todos**. Eles operam sobre qualquer inst√¢ncia de `Optional` e podem ser utilizados em qualquer contexto onde seja necess√°rio fornecer um valor alternativo ou lan√ßar uma exce√ß√£o quando o valor estiver ausente.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Optional.html" target="_blank"><b>Documenta√ß√£o: Classe Optional</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank"><b>Documenta√ß√£o: Java Generics</b></a></div>

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 01 - C√≥digo sem Optional



Primeiramente, vamos criar o c√≥digo abaixo, que resultar√° em um erro do tipo **`NullPointerException`**. Neste exemplo, **n√£o utilizaremos a classe `Optional`**:

```java
package com.generation.optional01;

public class Optional01 {

	public static void main(String[] args) {
        
		String[] palavras = new String[10];
		String palavra = palavras[5].toLowerCase();
		System.out.println(palavra);
        
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```java
Exception in thread "main" java.lang.NullPointerException: 
Cannot invoke "String.toLowerCase()" because "palavras[5]" is null
	at exemplos_optional.Exemplo01.main(Exemplo01.java:8)
```

Este erro ocorre porque a posi√ß√£o `5` do vetor `palavras` cont√©m `null`, ou seja, **o vetor foi instanciado, mas nenhum valor foi atribu√≠do √†s suas posi√ß√µes**. Ao tentar invocar o m√©todo `.toLowerCase()` sobre um elemento nulo, o programa lan√ßa a exce√ß√£o `NullPointerException`.

Na sequ√™ncia, vamos reescrever o c√≥digo implementando o Optional:

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 02 - C√≥digo com Optional

```java
package exemplos_optional;

import java.util.Optional;

public class Exemplo02 {

	public static void main(String[] args) {

		String[] palavras = new String[10];

		Optional<String> checaNulo = Optional.ofNullable(palavras[5]);

		if (checaNulo.isPresent()) {
			String palavra = palavras[5].toLowerCase();
			System.out.print(palavra);
		} else {
			System.out.println("A palavra √© nula!");
		}

	}

}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```java
A palavra √© nula!
```

Neste exemplo, o conte√∫do da posi√ß√£o `5` do vetor `palavras` foi **encapsulado em um objeto da classe `Optional`**, chamado `checaNulo`.

Em seguida, utilizamos o m√©todo booleano **`isPresent()`** para verificar se o `Optional` cont√©m um valor (ou seja, se o valor n√£o √© `null`).

- Se o valor estiver presente, ele ser√° convertido para letras min√∫sculas com o m√©todo **`toLowerCase()`** da classe `String` e exibido no console.
- Caso contr√°rio, a mensagem **"A palavra √© nula!"** ser√° exibida.

O uso da classe `Optional` permite realizar essa verifica√ß√£o de forma **mais segura, elegante e intuitiva**, evitando o erro `NullPointerException`. Al√©m disso, o `Optional` oferece diversos outros m√©todos √∫teis para manipula√ß√£o de valores opcionais ‚Äî como veremos nos pr√≥ximos exemplos.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>Exemplo 03 - Optional - M√©todos



Vamos desenvolver um exemplo pr√°tico que demonstra o uso da classe `Optional` no contexto de um e-commerce, focando na busca de um cliente cadastrado a partir de um e-mail informado. A proposta √© ilustrar como a API `Optional` pode ser aplicada para lidar com valores que podem ou n√£o estar presentes, substituindo o uso direto de `null` e reduzindo o risco de erros em tempo de execu√ß√£o.

Neste cen√°rio, utilizaremos os m√©todos **`empty()`**, **`get()`** e **`isPresent()`** da classe `Optional`. 

**Classe Cliente**

```java
package exemplos_optional;

public class Cliente {

    private String nome;
    private String email;

    public Cliente(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    public String getNome() {
        return nome;
    }

    public String getEmail() {
        return email;
    }

	public void setNome(String nome) {
		this.nome = nome;
	}

	public void setEmail(String email) {
		this.email = email;
	}
    
	public void visualizar() {
    	System.out.println("\n=========================================");
    	System.out.println("Dados do Cliente");
    	System.out.println("=========================================");
    	System.out.printf("Nome do cliente: %s%n", this.nome);
    	System.out.printf("E-mail do cliente: %s%n", this.email);
    }
	
}
```

**Classe Exemplo03 (classe principal)**

```java
package exemplos_optional;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class Exemplo03 {

    private static List<Cliente> listaClientes = new ArrayList<>();

    public static void main(String[] args) {

        // Simula cadastro de clientes
        listaClientes.add(new Cliente("Bruna Silva", "bruna@email.com"));
        listaClientes.add(new Cliente("Maria Oliveira", "maria@email.com"));

        // Teste com e-mail existente
        buscarCliente("bruna@email.com");

        // Teste com e-mail inexistente
        buscarCliente("cliente@naoexiste.com");
    }

    public static void buscarCliente(String email) {
        Optional<Cliente> clienteOptional = buscarClientePorEmail(email);

        if (clienteOptional.isPresent()) {
            Cliente cliente = clienteOptional.get();
            System.out.println("‚úÖ Cliente encontrado: " + cliente.getNome());
        } else {
            System.out.println("‚ùå Cliente com e-mail '" + email + "' n√£o foi encontrado.");
        }
    }

    public static Optional<Cliente> buscarClientePorEmail(String email) {
        for (Cliente cliente : listaClientes) {
            if (cliente.getEmail().equalsIgnoreCase(email)) {
                return Optional.of(cliente); // Cliente encontrado
            }
        }
        return Optional.empty(); // Cliente n√£o encontrado
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```java
‚úÖ Cliente encontrado: Bruna Silva
‚ùå Cliente com e-mail 'cliente@naoexiste.com' n√£o foi encontrado.
```

No exemplo acima, a l√≥gica est√° encapsulada no m√©todo `buscarCliente()`, que recebe o par√¢metro  `String email`, faz uma chamada ao m√©todo `buscarClientePorEmail()` e recebe como resposta um `Optional<Cliente>`. 

O uso do m√©todo `isPresent()` permite verificar se o valor retornado est√° presente (ou seja, se o cliente foi encontrado):

- Caso esteja, o m√©todo `get()` √© usado para acessar o objeto `Cliente`. 
- Caso contr√°rio, uma mensagem de erro √© exibida.

> [!WARNING]
>
> O m√©todo `get()` deve ser usado ap√≥s garantir que o valor est√° presente, preferencialmente com m√©todos como `isPresent()` e `ifPresent()`, ou em cen√°rios onde a aus√™ncia do valor j√° foi tratada.

O m√©todo `buscarClientePorEmail()` percorre a lista de clientes cadastrados e compara os e-mails ignorando mai√∫sculas e min√∫sculas: 

- Se o cliente √© encontrado, ele √© retornado dentro de um `Optional.of(cliente)`, encapsulando o valor para indicar presen√ßa. 
- Se nenhum cliente for encontrado, o m√©todo retorna `Optional.empty()`, representando aus√™ncia de valor. 

Essa abordagem substitui o tradicional `null` e evita poss√≠veis `NullPointerException`, tornando o c√≥digo mais seguro e f√°cil de manter. 

Ao utilizar `Optional`, os m√©todos deixam expl√≠cito que o retorno pode estar vazio, for√ßando a pessoa desenvolvedora a lidar com essa possibilidade de forma consciente.

Os demais m√©todos da classe `Optional`, como `map()`, `flatMap()`, `orElseGet()` e `orElseThrow()`, ser√£o explorados durante o estudo das **express√µes lambda**. Isso porque esses m√©todos foram projetados para receber **fun√ß√µes como argumentos**, e o uso de lambdas torna sua aplica√ß√£o mais direta, leg√≠vel e concisa. Embora seja poss√≠vel utilizar esses m√©todos com classes an√¥nimas, como fizemos at√© aqui, a abordagem com lambda √© amplamente adotada na pr√°tica e favorece um estilo mais funcional de programa√ß√£o em Java.

Ao dominar as express√µes lambda, ser√° poss√≠vel aproveitar todo o potencial da API `Optional`, tornando o c√≥digo mais enxuto e expressivo. Por esse motivo, optamos por introduzir primeiro os conceitos fundamentais do `Optional` com estruturas tradicionais, para ent√£o aprofundar nos m√©todos mais avan√ßados juntamente com o uso de fun√ß√µes lambda. Essa progress√£o garante uma base s√≥lida antes de introduzir a sintaxe funcional que caracteriza a programa√ß√£o moderna em Java.

<br />

------

## üîë**Pontos chave:**

1. **Optional** √© uma classe introduzida no **Java 8** com o objetivo de encapsular valores que podem estar presentes ou ausentes, oferecendo uma abordagem mais segura e leg√≠vel para lidar com poss√≠veis refer√™ncias nulas, evitando erros como o **NullPointerException**.

2. A utiliza√ß√£o do **Optional** elimina a necessidade de verifica√ß√µes expl√≠citas de nulidade (`if (variavel != null)`), promovendo um c√≥digo mais limpo, conciso e robusto.

3. Optional fornece m√©todos para:

   - Criar inst√¢ncias (`empty()`, `of()`, `ofNullable()`),

   - Verificar presen√ßa de valor (`isPresent()`, `isEmpty()`, `ifPresent()`),

   - Transformar dados (`map()`, `flatMap()`),

   - Fornecer valores alternativos ou lan√ßar exce√ß√µes (`orElse()`, `orElseGet()`, `orElseThrow()`).

4. O uso correto do **Optional** promove uma programa√ß√£o mais segura, deixando expl√≠cita a possibilidade de aus√™ncia de valor e favorecendo pr√°ticas modernas baseadas em programa√ß√£o funcional.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>	